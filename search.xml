<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo 使用教程</title>
      <link href="/2021/08/24/hexo/"/>
      <url>/2021/08/24/hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="新建一篇博客"><a href="#新建一篇博客" class="headerlink" title="新建一篇博客"></a>新建一篇博客</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><h3 id="提交修改到my-blog上"><a href="#提交修改到my-blog上" class="headerlink" title="提交修改到my-blog上"></a>提交修改到my-blog上</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit -m <span class="token string">"msg"</span><span class="token function">git</span> push origin master:my-blog</code></pre><h3 id="自动开启自动化部署"><a href="#自动开启自动化部署" class="headerlink" title="自动开启自动化部署"></a>自动开启自动化部署</h3><pre class="language-bash" data-language="bash"><code class="language-bash">打开https://jingwzeng.github.io就可以自动部署</code></pre><h3 id="表情包"><a href="#表情包" class="headerlink" title="表情包"></a>表情包</h3><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f616.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f623.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>表情包代码地址:<a href="https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-3">https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-3</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web存储</title>
      <link href="/2021/08/24/web-cun-chu/"/>
      <url>/2021/08/24/web-cun-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><code>Cookie</code>是S端发送C端的一个小数据,下次请求的时候C端带上该数据,S端确认是不是同一个浏览器发送过来的数据。</p><blockquote><p>用处</p></blockquote><ol><li>保持登录的状态</li><li>个性化设置(主题)</li><li>浏览器的行为跟踪<br>缺点: <code>Cookie</code>会造成额外的性能开销，每次请求的时候会携带。</li></ol><p><strong>S端收到<code>http</code>请求的时候，S端在响应报文首部添加一个<code>set-cookie</code>的选项， C端收到之后会保存下<code>Cookie</code>,之后的C端每次请求通过请求头部将<code>Cookie</code>信息携带上</strong><br><code>set-Cookie</code>:<strong>&lt;cookie名&gt;=&lt;cookie值&gt;</strong><br><strong>cookie的分类</strong></p><ul><li>会话期的<code>cookie</code>(浏览器关闭之后就没有了，不需要设置过期的时间)</li><li>持久性的<code>cookie</code>(有一个过期时间,设定的时间只跟C端有关，和S端无关的)</li><li>第三方的<code>cookie</code>(<code>cookie</code>是同源的，第三方的<code>cookie</code>就是域和页面的域不同，只用于广告追踪)</li></ul><p><strong>cookie的属性</strong></p><ol><li><code>secure</code>:表示<code>cookie</code>只可以通过<code>https</code>进行传输，不可以使用<code>http</code>进行</li><li><code>httpOnly</code>:避免<code>xss</code>攻击的，就是该<code>cookie</code>设置了<code>httpOnly</code>的话,<code> JavaScript</code>脚本是不可以对该<code>cookie</code>进行调用的，只可以发送给服务器</li><li>作用域属性:规定哪些页面可以使用该<code>cookie</code>.通过<code>domian</code>和<code>path</code>属性来设置。<code>domain</code>包含子域名也可以得到该<code>cookle</code><br><code>path</code>的话指定主机的路径哪些可以接受<code>cookie</code>(指定根路径之后,下面的子路径也可以拿到)<pre class="language-none"><code class="language-none">path = /docs则以下可以拿到cookie/docs/web//docs/web/http/</code></pre></li><li><code>SameSite cookleSameSite=Strict</code></li></ol><p>可以取下面3个值</p><ul><li><p><code>None</code>没有做设置</p></li><li><p><code>Strict</code>只发送给相同站点请求的<code>cookle</code>(就是当前页面的<code>URL</code>与请求目标的<code>URL</code>完全一致)如果请求来自的网址和当前的<code>location</code>的地址不一样，则该<code>cookie</code>不会被发送</p></li><li><p><code>Lax</code>默认的</p></li></ul><p>5.过期时间</p><ul><li><code>session</code>: 表示会话性<code>cookie</code></li></ul><p><code>set-cookie</code> 响应头是服务器返回的响应头，用来在浏范器中种下<code>cookie</code>,一旦被种下，当浏范器访问符合条件的<code>url</code>地址的时候，会自动带上这个<code>cookie</code></p><h4 id="Session待定"><a href="#Session待定" class="headerlink" title="Session待定"></a>Session待定</h4><h4 id="token待定"><a href="#token待定" class="headerlink" title="token待定"></a>token待定</h4><h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><blockquote><p>勾引用户进入第三方的网站，在第三方的网站中，向被攻击的网站发送跨站清求，利用用户在被攻击的网站的登凭证<code>cookie</code>,绕过了后台的用户验证，达到冒充用户访问被攻击的网站进行相关的操作。</p></blockquote><ol><li>CSRF通常是第二方的网站发起</li><li>CSRF攻击者不可以获取到cookle等信息，只是使用而已</li></ol><blockquote><p>防护策略</p></blockquote><ol><li>阻止不明外域的访问</li></ol><ul><li>同源策略</li><li><code>Samesite Cookle</code></li></ul><ol start="2"><li>提交时要求附加本域才能获取信息</li></ol><ul><li><code>SCRF Token</code></li><li>双重的<code>Cookie</code>认证</li></ul><blockquote><p>Token解释</p></blockquote><ol><li>将<code>Token</code>输入到页面中，不能存在<code>Cookie</code>中,否则样被冒充,只能放在服务器的<code>session</code>中</li><li>页面请求携带这个<code>Token</code></li><li>服务器会验证<code>Token</code>是否正确</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期总结</title>
      <link href="/2021/08/24/vue-sheng-ming-zhou-qi-zong-jie/"/>
      <url>/2021/08/24/vue-sheng-ming-zhou-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li><code>beforeCreate</code><br><code>data</code>和<code>methods</code>中的数据还没有被初始化</li><li><code>created</code><br><code>data</code>和<code>methods</code>中的数据已经被初始化，最早在这里进行操作他们的数据</li><li><code>beforeMounte</code><br>模板已经在内存中编辑完成了，但是还没有把模板渲染到页面中去。此时对dom元素无法进行相关的操作，页面中的元素还没有真正的替换出来，页面还是旧的</li><li><code>mounted</code><br>内存中的模板，已经真实的挂载到了页面中，用户可以看到已经渲染好的页面。实例披创建好的最后步，如果没有其他操作，他就安安静静的保存在内存之中<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4></li><li><code>beforeUpdote</code><br><code>data</code>里面的数据发生改变的时候才会触发0次或者多次。表示界面还没有被更新，但是数据已经被更新了。数据与页面不同步更新的，虚拟dom的特性</li><li><code>updated</code><br>数据和页面更新已经同步了，就是虚拟<code>dom</code>已经被变成了真实的<code>dom</code><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4></li><li><code>beforeDestroy</code><br><code>vue</code>实例的销毁阶段，实例身上所有的<code>data</code>、 <code>methods</code>以及指令和过这器等等还是可用的状态。</li><li><code>destroy</code><br>这里组件以及被完全销毁，实例身上所有的<code>data</code>、<code>methods</code>以及指令和过这器等已经是不可用的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Router文档总结</title>
      <link href="/2021/08/24/vue-router-wen-dang-zong-jie/"/>
      <url>/2021/08/24/vue-router-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h4><p>路由的跳转是个大的过程，分为跳转前中后等等细小的过程，在每一个过程中有一 个相应的函教， 这个函数可以让你操作一些其他事情</p><ol><li>全局的(就是当触发路由的时候就会触发)<ul><li><code>beforeEach</code><br>路由还没有跳转之前就通知，防止跳转之后再告知就晚了，经常用来做登录的验证。</li><li><code>beforeResolve</code><br>导航被确认之前，同时组件内守卫和异步路由组件被解析之后执行也就是在<code>beforeEach</code>和组件内的<code>beforeRouteEnter</code>之后,<code>afterEach</code>之前调用。</li><li><code>afterEach</code><br>路由跳转完成之后触发</li></ul></li><li>路由独享的(就是在配路由的时候可以设置的钩子，该路由才有的)<ul><li><code>beforeEnter</code><br>和beforeEach是样的作用</li></ul></li><li>组件内部的(是指在组件内部执行的钩子函数，给该组件被配置在的路由添加生命周期的钩子函数)<ul><li><code>beforeRouterEnter</code><br>在<code>beforeCreated</code>之前调用，是拿不到<code>this</code>的，用<code>this</code>是访问不了组件的实例对象的，可以通过<code>next</code>函数，参数传入一个回调函数来获取组件实例，这个回调函数在路由被确认的时候就会调用。组件实例作为回调函故的参数。可以获取服务端的数据，当成功获取并能进入路由的时候，调用<code>next</code>通过<code>vm</code>访问组件实例进行赋值等操作。<code>next</code>中的函数调用在进入<code>mounted</code>之后。</li></ul></li></ol><ul><li><code>beforeRouterUpdate</code><br>当前路由改变的时候，并且该组件可以通过<code>this</code>访问实例。<code>/foo/1</code> 和<code>/foo/2</code>之间跳转组件会被复用，当前的<code>query</code>改变的时候，组件会被复用。</li><li><code>beforeRouterLeave</code><br>导航离开该组件的路由的时候调用，可以访问该组件的实例<code>this</code></li></ul><p><strong>参数</strong></p><ol><li><code>to</code> (目标路由对象)</li><li><code>from</code> (即将离开的路由对象)</li><li><code>next</code> (佛珠的线)<ul><li>但凡涉及到<code>next</code>的钩子，必须调用<code>next()</code>才可以继续执行下一个钩子，否则路由跳转就会停止</li><li>中断导航用<code>next(false)</code>。如果浏览器的地址改变了(用户手动、浏览器后退操作) <code>url</code>会重置到<code>from</code>的地址(登录验证失败的时候处理)</li><li><code>next('/')</code>或者<code>next(path:'/')</code>当前的导航被中断，然后进行新的导航</li><li>在<code>beforeRouterEnter</code>中<code>next(vm=&gt;{})</code>内接受的回调函数的参数为当前组件的实例<code>vm</code>,这个回调函数是在<code>mounted</code>之后调用的，也就是说，他是所有的导航守卫和生命周期函数最后执行的</li><li><code>next(error)</code>，导航被中断而且错误给<code>router.onError()</code>注册过的回调函数</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中问题</title>
      <link href="/2021/08/24/vue-xiang-mu-zhong-wen-ti/"/>
      <url>/2021/08/24/vue-xiang-mu-zhong-wen-ti/</url>
      
        <content type="html"><![CDATA[<ul><li><code>computer</code>中传参数的话需要使用闭包的方式</li><li><code>filter</code>中无法访问<code>this</code>，使用<code>filter</code>的前提是有个现成的变量</li><li>数字千分位处理并保留两位小数<code>nums.toFixed(2).replace(/(\d)(?=(\d{3}+.)/g,'$1')</code></li><li><code>splice(index,1)</code>返回的数据是被删除的那个数据或者数组 —– 会改变原数组</li><li><code>try/catch</code> 只能捕获同步函数的异常，包括async/await</li><li><code>Vue</code>项目中报错<code>Already include file name 'xxxx' differs from files name...</code>,解决办法是：去掉后面<code>.vue</code>后缀名既可</li><li>页面刷新之后，会重新加载<code>Vue</code>实例，<code>store</code>里面的值会被重新赋值，这样会造成页面刷新只会<code>Vuex</code>中数据丢失的问题，解决办法是：利用<code>Web</code>存储<code>(cookie\localStorage\sessionStorage)</code></li><li>每一个页面都是一个组件，路由跳转的时候组件就会被<code>销毁和重新建立</code>，跳转会经历一个完整的生命周期</li><li><code>babel</code> 又名通天塔，它的作用是<code>ES6</code>、<code>ES7</code>转成<code>ES5</code></li><li><code>CSS</code>中的行内元素水平居中直接在父元素中<code>text-align:center</code>，垂直居中设置行高和高度相等:<code>height:10px;line-height:10px</code></li><li><code>SSR</code>服务端渲染<ul><li>前后端分离的缺点(适合后台管理项目或者大量路由的项目)<ul><li><code>SEO</code>不友好:因为页面中只有一个<code>div</code>，其他页面的操作是通过JS来进行的，<code>SEO</code>是通过爬取<code>html</code>代码的，而不是<code>JS</code>代码</li><li>首屏加载慢:更多的加载和渲染的工作是由浏览器来完成的</li><li>性能的问题:理由同上，频繁的和服务端进行数据交互</li></ul></li><li>解决上述办法-&gt;<code>SSR</code>服务端渲染(适合官网项目和推广页项目)<ul><li>简单来说就是服务端拿到数据进行解析渲染，直接生成<code>html</code>片段返回给前端</li><li>传统的服务端模板引擎渲染整个页面</li><li>服务端渲染生成的<code>html</code>代码块，前端通过<code>ajax</code>获取然后通过<code>JS</code>动态的添加</li></ul></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用跨域</title>
      <link href="/2021/08/24/chang-yong-kua-yu/"/>
      <url>/2021/08/24/chang-yong-kua-yu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端访问服务器的时候数据因为跨域无法直接得到<br>服务端和服务端之间的通信是不存在跨域的，都是同源<br>前后端不分离的时候就是同源，前端和后端代码在同一个电脑上</p></blockquote><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li>script</li><li>img</li><li>link</li><li>iframe<blockquote><p>它们不受同源策略的影响</p></blockquote></li></ul><hr><p>它们通过<code>script</code>标签的<code>src</code>，<code>src</code>指向服务器的<code>api</code>地址,因为不受同源的影响，因此可以访问带数据，之后把本地浏览器端的一个函数<code>func</code>作为回调函数传递给服务器。服务器收到请求，同时也可以拿到传过来的函数<br>之后服务器做两件事</p><ol><li>服务端准备数据<code>data</code></li><li>给客户端返回数据(利用传过来的函数进行包装<code>data</code>数据=&gt;<code>func('JSON.stringify(data)+')</code>。客户端收到响应，发现数据格式就是自己全局函数<code>func</code>，于是对函数<code>fun</code>进行调用，执行<code>JSON.parse</code>得到<code>data</code></li></ol><p><em><strong>特点</strong></em></p><ul><li><code>JSONP</code>需要服务端的支持</li><li><code>func</code>必须为全局函数</li><li>服务端需要利用<code>func</code>进行数据包装</li><li>只支持<code>get</code>请求(限制了我平时在开发中，基本用不到它！！！)</li></ul><hr><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><ul><li>C端发送<code>axios/ajax</code>请求并做一些基本的配置</li><li>S端设置响应头的相关信息，但是需要做<code>options</code>试探性的请求(如果是利用<code>node</code>开服务的话，可以利用中间件进行相关的设置) </li></ul><h4 id="http-proxy-gt-webpack-webpack-dev-server"><a href="#http-proxy-gt-webpack-webpack-dev-server" class="headerlink" title="http proxy =>webpack + webpack-dev-server"></a>http proxy =&gt;webpack + webpack-dev-server</h4><p>正常开发的<code>Vue</code>项目的时候，下载<code>webpack-dev-serve</code>直接设置<code>webpack</code>配置文件既可以。<code>Vue-cli</code>已经集成,在<code>vue.config.js</code>中进行配置</p><h4 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a>document.domain+iframe</h4><p>只能实现同一个主域，不同子域之间的同源</p><pre class="language-none"><code class="language-none">v.qq.comsports.qq.comqq.com是主域</code></pre><h4 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h4><p>不需要前端参与，后端在<code>linux</code>中进行配置</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-S数据基本过程</title>
      <link href="/2021/08/24/c-s-shu-ju-ji-ben-guo-cheng/"/>
      <url>/2021/08/24/c-s-shu-ju-ji-ben-guo-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一次http请求至少进行两次的数据转换，发送请求的时候一次，获取响应数据的时候一次</p></blockquote><table><thead><tr><th>顺序</th><th>层名</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>应用层</td><td>数据</td></tr><tr><td>2</td><td>传输层</td><td>数据+源端口+目标端口</td></tr><tr><td>3</td><td>网络层</td><td>数据+源端口+目标端口+源IP+目标IP</td></tr><tr><td>4</td><td>链路层</td><td>转换成数字信息进行传输</td></tr></tbody></table><h4 id="从客户端-1-gt-2-gt-3-gt-4"><a href="#从客户端-1-gt-2-gt-3-gt-4" class="headerlink" title="从客户端 1->2->3->4"></a>从客户端 1-&gt;2-&gt;3-&gt;4</h4><h4 id="从服务端-4-gt-3-gt-2-gt-1"><a href="#从服务端-4-gt-3-gt-2-gt-1" class="headerlink" title="从服务端 4->3->2->1"></a>从服务端 4-&gt;3-&gt;2-&gt;1</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/08/24/bi-bao/"/>
      <url>/2021/08/24/bi-bao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS的函数内部可以访问全局变量，但是在函数的外部是不可以读取内部的局部变量<br>闭包其实就是提供一个方式来读取函数内部的变量</p></blockquote><h4 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h4><ul><li><p>单纯的觉得闭包是拿到函数内部的变量是不对的，以下这种方式也可以拿到，但它不是闭包</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 外部可以拿到a，但不是闭包</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span><span class="token number">100</span>    <span class="token keyword">return</span> a<span class="token punctuation">}</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//101</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//101   此时函数f3已经被垃圾回收了，再次调用就是重新开始创建变量等一系列的过程</span></code></pre></li><li><p>闭包真正的原因是局部变量无法长久保存，全局变量又容易污染环境，希望可以找到一种既可以长久保存又不会造成全局污染的方法，这就是<code>闭包的机制</code>。所以看似代码复杂化，其实大有来头。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f2<span class="token punctuation">}</span><span class="token keyword">let</span> f <span class="token operator">=</span> f1 <span class="token comment">// f1执行的结果，其实就是return出来的f2函数 ===== 闭包</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 101</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 102</span><span class="token comment">/** * 1、f1的调用结果被赋给了全局变量f，全局变量f一直存在于内存中，f1函数执行完毕之后就会被释放，但是return出来了一个函数，也就是会造成内存泄漏的原因（变量a没有被释放） * 2、a是局部变量但是他不会被销毁。因为f2还保持着对a的引用（JS的垃圾回收机制之中的引用计数原则）*/</span></code></pre><p>用匿名函数简写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li></ul><ol><li>注意全局变量一直存在于内存中，局部变量执行完之后被垃圾回收（包括函数），再次执行该函数的时候又得重新开始</li><li>闭包的代码复杂的真正原因<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//1</span><span class="token function">s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token function">s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//3</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode中使用git</title>
      <link href="/2021/08/20/vscode-zhong-shi-yong-git/"/>
      <url>/2021/08/20/vscode-zhong-shi-yong-git/</url>
      
        <content type="html"><![CDATA[<p><strong>在VsCode中使用Git提交的过程</strong></p><ol><li>先确定提交的分支,”+”是提交到暂缓区,相当于<code>git add .</code></li><li>“√”是将暂缓区的代码提交到本地代码仓库,相当于<code>git commit -m ""</code></li><li>提交到<code>github</code>远程仓库之前，应该先”拉取”远程仓库，用来和本地的仓库做同步，如果有冲突，VsCode会自动跳出冲突，编辑解决完冲突之后，再进行下一步</li><li>最后一步”推送”，本地仓库的代码同步到<code>github</code>远程仓库</li></ol>]]></content>
      
      
      <categories>
          
          <category> VsCode </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bom知识总结</title>
      <link href="/2021/08/20/bom-zhi-shi-zong-jie/"/>
      <url>/2021/08/20/bom-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>好记性不如烂笔头！</p><h3 id="1-BOM-Browser-Object-Model"><a href="#1-BOM-Browser-Object-Model" class="headerlink" title="1.BOM: Browser Object Model"></a>1.BOM: Browser Object Model</h3><p>什么是: 专门操作浏览器窗口的API<br>没有标准, 导致浏览器兼容性问题<br>包括:<br>window<br>history<br>location<br>navigator<br>dom<br>event<br>screen</p><h3 id="2-window"><a href="#2-window" class="headerlink" title="2.window:"></a>2.window:</h3><p>属性: .innerWidth, .innerHeight 浏览器窗口中，文档显示区的宽和高<br>方法: .open() .close() .open(“url”,”name”)</p><p>三种:</p><pre class="language-none"><code class="language-none">CODE1.在当前窗口打开，可后退: .open("url","_self")2.在新窗口打开，可打开多个: .open("url","_blank")3.在新窗口打开，只能打开一个:   .open("url","自定义窗口名")</code></pre><h3 id="3-history-保存当前窗口打开后，成功访问过的url的历史记录栈"><a href="#3-history-保存当前窗口打开后，成功访问过的url的历史记录栈" class="headerlink" title="3.history: 保存当前窗口打开后，成功访问过的url的历史记录栈"></a>3.history: 保存当前窗口打开后，成功访问过的url的历史记录栈</h3><p>在当前窗口中，每访问一个新url，都会将新url压入history<br>API: history.go(n)</p><p>3种:</p><pre class="language-none"><code class="language-none">CODE前进: history.go(1)  后退: history.go(-1)  刷新: history.go(0)</code></pre><h3 id="4-location-保存当前窗口正在打开的url的对象"><a href="#4-location-保存当前窗口正在打开的url的对象" class="headerlink" title="4.location: 保存当前窗口正在打开的url的对象"></a>4.location: 保存当前窗口正在打开的url的对象</h3><p>属性:<br>.href 完整url地址<br>.protocol 协议<br>.host 主机名+端口号<br>.hostname 主机名<br>.port 端口号<br>.pathname 相对路径<br>.hash #锚点地址<br>.search ?查询字符串</p><p>方法:</p><ol><li>在当前窗口打开，可后退:<br>location.assign(url) =&gt; location.href=url =&gt; location=url</li><li>在当前窗口打开，禁止后退:<br>location.replace(url)</li><li>重新加载页面: 刷新: 2种:<ol><li>普通刷新:<br>优先从浏览器本地缓冲获取资源:<br>F5<br>history.go(0)<br>location.reload(/<em>false</em>/)</li><li>强制刷新:<br>无论本地是否有缓存，总是强制从服务器获取资源<br>location.reload(true)</li></ol></li></ol><h3 id="5-定时器-2种"><a href="#5-定时器-2种" class="headerlink" title="5.定时器: 2种:"></a>5.定时器: 2种:</h3><ol><li><p>周期性定时器:<br>什么是: 让程序每隔指定的时间间隔，反复执行一项任务<br>何时: 只要让程序按照指定的时间间隔，自动执行一项任务<br>如何: 3件事:<br>1.任务函数: 让定时器反复执行的任务<br>2.启动定时器: timer=setInterval(task, interval)</p><pre class="language-none"><code class="language-none">CODE让程序，每隔interval 毫秒自动执行一次task任务</code></pre><p>3.停止定时器: clearInterval(timer)</p><pre class="language-none"><code class="language-none">CODEtimer: 定时器的序号, 在内存中唯一标识定时器的整数 专门用于停止定时器 如何获得: 只能在启动定时器时获得。 何时: 只要一个定时器可能被停止，就要在启动时，先保存定时器序号 好的习惯: 在clearInterval之后，手动清除timer中残留的序号: timer=null;</code></pre><p>停止定时器: 2种情况:</p><ol><li>用户手动停止:</li><li>定时器可自动停止:<br>在任务函数中，设定临界值，如果没有达到临界值，则继续执行任务，否则，如果达到临界值，就自动调用clearInterval</li></ol></li></ol><p>2.一次性定时器:<br>什么是: 让程序先等待一段时间，再执行一次任务。执行后，自动停止。<br>何时: 只要让程序延迟执行一件事时<br>如何: 3件事:<br>1.task<br>2.启动定时器: timer=setTimeout(task,wait)</p><pre class="language-none"><code class="language-none">CODE让程序等待wait毫秒后，自动执行一次task，执行后自动停止</code></pre><p>3.停止定时器: clearTimeout(timer)</p><h3 id="6-定时器原理"><a href="#6-定时器原理" class="headerlink" title="6.定时器原理:"></a>6.定时器原理:</h3><p>定时器中的任务函数，必须等待主程序所有语句执行后，才能执行。</p><h3 id="7-navigator"><a href="#7-navigator" class="headerlink" title="7.navigator:"></a>7.navigator:</h3><p>1.什么是: 保存浏览器配置信息的对象<br>包括:<br>.cookieEnabled: 判断当前浏览器是否启用cookie</p><p>2.什么是cookie: 在客户端持久存储用户私密数据的小文件<br>为什么: 内存中所有数据都是临时的! 程序关闭，内存中一切变量都释放!<br>何时: 只要希望在客户端持久保存数据，都用cookie<br>.plugins: 包含浏览器所有插件信息的集合</p><p>3.什么是插件: 为浏览器添加新功能的小软件</p><pre class="language-none"><code class="language-none">CODE如何判断是否安装指定插件: </code></pre><p>.userAgent: 保存浏览器名称和版本号的字符串<br>何时: 只要判断浏览器名称和版本号</p><h3 id="8-event"><a href="#8-event" class="headerlink" title="8.event:"></a>8.event:</h3><p>什么是事件: 人为触发的，或浏览器自动触发的页面内容状态的改变。<br>什么是事件处理函数: 当事件发生时，自动执行的函数。<br>如何绑定: 3种:</p><ol><li>在HTML中绑定:<br>绑定:<br>当事件发生时: 自动执行js语句<br>问题: 不符合内容与行为分离的原则，不便于维护和重用<br>但是: 在组件开发中，反而要求内容，行为和样式集中定义在一个小组件内，自成体系。</li><li>在js中绑定, 每个事件只能绑定一个处理函数:<br>ANY.on事件名=function(){ … }<br>当事件发生时: ANY.on事件名() //this-&gt;ANY<br>问题: 用赋值方式绑定事件处理函数</li><li>在js中绑定，每个事件可绑定多个处理函数:<br>ANY.addEventListener(‘事件名’,handler)<br>在浏览器中为ANY元素的指定事件，添加一个事件监听对象。将事件监听对象加入到浏览器的监听队列中。<br>触发事件时: 浏览器会遍历监听队列中的每个监听对象，找到触发事件元素上对应事件的监听对象，调用其处理函数<br>移除事件监听:<br>ANY.removeEventListener(‘事件名’,handler)<br>说明: handler必须是绑定时使用的原函数对象<br>强调: 如果一个处理函数，有可能被移除，则不能使用匿名函数绑定。应使用有名的函数绑定</li></ol><h3 id="9-DOM事件模型"><a href="#9-DOM事件模型" class="headerlink" title="9.DOM事件模型:"></a>9.DOM事件模型:</h3><p>什么是: 从事件触发到处理函数执行，所经过的过程<br>3个阶段:</p><ol><li>捕获capture: 由外向内，记录各级父元素上绑定的事件处理函数。——仅记录，不触发!</li><li>目标触发: 优先触发实际点击的元素上绑定的处理函数</li><li>冒泡执行: 由内向外，按捕获阶段记录的处理函数的倒序，依次执行父元素上的处理函数。</li></ol><h3 id="10-事件对象"><a href="#10-事件对象" class="headerlink" title="10.事件对象:"></a>10.事件对象:</h3><p>什么是: 当事件发生时，自动创建的，封装事件信息的对象<br>何时: 只要希望获得事件信息，或修改事件的默认行为时<br>如何获取: 事件对象默认总是以处理函数第一个参数，自动传入<br>如何使用:</p><ol><li><p>取消冒泡: e.stopPropagation()</p></li><li><p>利用冒泡:<br>优化: 尽量减少事件监听的个数<br>为什么: 浏览器查找事件监听，采用的是遍历的方式</p><pre class="language-none"><code class="language-none">CODE事件监听多，浏览器查找就慢</code></pre><p>何时: 如果对多个子元素绑定相同事件时，都要利用冒泡<br>如何: 只要在父元素绑定一次，所有子元素共用即可!<br>2个难题:</p><pre class="language-none"><code class="language-none">CODE1. 获得目标元素:  目标元素: 最初实际触发事件的当前元素  如何获得:    错误: this-&gt;父元素   正确: e.target2. 筛选目标元素:  比如: 通过nodeName, class, 内容。。。</code></pre></li><li><p>阻止默认行为:<br>何时: 只要事件的默认行为不是想要的<br>如何: e.preventDefault();<br>何时:</p><ol><li>用a当按钮时，a会自动向地址栏中添加#锚点地址。</li><li>提交表单时，如果验证没通过，可阻止提交<br>自定义表单提交:<br>input button + onclick + form.submit<br>input submit + form.onsubmit事件 + e.preventDefault()</li><li>HTML5中拖拽API: 首先要阻止浏览器默认的拖拽行为</li></ol></li></ol><h3 id="11-鼠标坐标-3组"><a href="#11-鼠标坐标-3组" class="headerlink" title="11.鼠标坐标:(3组)"></a>11.鼠标坐标:(3组)</h3><pre class="language-none"><code class="language-none">CODE1. 相对于屏幕左上角: e.screenX,  e.screenY2. 相对于文档显示区左上角: e.clientX,  e.clientY3. 相对于当前元素左上角:  e.offsetX,   e.offsetY</code></pre><h3 id="12-页面滚动"><a href="#12-页面滚动" class="headerlink" title="12.页面滚动:"></a>12.页面滚动:</h3><p>事件: window.onscroll<br>获得页面滚动过的高度: body顶部超出文档显示区顶部的距离</p><pre class="language-none"><code class="language-none">CODEscrollTop=document.documentElement.scrollTop        ||document.body.scrollTop;</code></pre><p>滚动API:<br>window.scrollTo(left, top)<br>window.scrollBy(left的增量,top的增量)</p>]]></content>
      
      
      <categories>
          
          <category> BOM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css知识总结</title>
      <link href="/2021/08/20/css-zhi-shi-zong-jie/"/>
      <url>/2021/08/20/css-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前端知识点总结——CSS"><a href="#前端知识点总结——CSS" class="headerlink" title="前端知识点总结——CSS"></a><strong>前端知识点总结——CSS</strong></h2><p>好记性不如烂笔头！</p><h3 id="1-CSS的概述"><a href="#1-CSS的概述" class="headerlink" title="1.CSS的概述"></a>1.CSS的概述</h3><p>1.什么是CSS?</p><pre class="language-none"><code class="language-none">CODECSS：Cascading Style Sheets层叠样式表，级联样式表（简称：样式表）</code></pre><p>2.作用</p><pre class="language-none"><code class="language-none">CODE设置HTML网页元素的样式</code></pre><p>3.HTML与CSS的关系</p><pre class="language-none"><code class="language-none">CODEHTML：负责内容的展示CSS：负责内容（元素）的修饰</code></pre><p>4.HTML与CSS之间的使用原则</p><pre class="language-none"><code class="language-none">CODEW3C建议尽量使用CSS属性去取代HTML属性来修饰元素</code></pre><h3 id="2-CSS语法规范"><a href="#2-CSS语法规范" class="headerlink" title="2.CSS语法规范"></a>2.CSS语法规范</h3><p>1.使用CSS样式的方式(重点)</p><pre class="language-none"><code class="language-none">CODE 1.内联样式   又称为行内样式   特点：将CSS样式定义在HTML开始标记中   语法：     &lt;ANY style="样式声明1；样式声明2"&gt;&lt;/ANY&gt; 样式声明：      1.由样式属性和值来组成      2.属性名与值之间用 冒号 连接      3.多个样式声明之间用 分号 分割        常用的CSS样式属性 和 值：      1.设置文本颜色的属性和值        属性：color    值：合法的颜色值（英文）      2.设置背景颜色的属性和值        属性：background    值：合法的颜色值（英文）      3.设置文字大小的属性和值        属性：font-size    值：以px或pt为单位的数字    ex：font-size:30px;      2.内部样式   在网页的头元素中增加一对&lt;style&gt;标记，在&lt;style&gt;标记声明该网页用到的样式规则   语法： &lt;head&gt;             &lt;style&gt;        /*注释*/        样式规则1        样式规则2        ...     &lt;/style&gt;      &lt;/head&gt;    样式规则：由选择器和样式声明组成选择器：规范了页面中哪些元素能够使用定义好的样式（就是把声明好的样式匹配给页面中的元素）元素选择器：由元素的名称作为选择器div,p,h1,span,a,img选择器{}ex：div{}    p{}样式规则：   选择器{      样式声明；   }ex:div{   color:red;   font-size:20px;}p{  color:blue;}h1{...} 3.外部样式   独立于任何网页的位置处，声明一个样式表文件（***.css为后缀），   在.css文件中保存样式规则，然后在网页中引入.css文件。   使用步骤：       1.创建样式表文件，并编写样式规则   2.在网页中引入样式表文件     &lt;head&gt;        &lt;link rel="stylesheet" href="**.css"&gt;     &lt;/head&gt;</code></pre><h3 id="3-CSS样式特征"><a href="#3-CSS样式特征" class="headerlink" title="3.CSS样式特征"></a>3.CSS样式特征</h3><pre class="language-none"><code class="language-none">CODE1.继承性  大部分样式可以被继承（子元素继承父元素的样式特征）  必须是有层级关系的嵌套  &lt;div style="color:red;"&gt;     &lt;p&gt;p&lt;/p&gt;  &lt;/div&gt;2.层叠性   可以为一个元素定义多个样式，当样式属性不冲突时，可以同时将这些样式应用到元素上  div{     color:red;  }  div{     font-size:20px;  }  div{     background:gray;  }3.优先级  如果样式声明冲突时，会按照样式的优先级来应用定义的样式规则      由低到高：     浏览器默认设置       最低     内部样式和外部样式   中(就近原则)     内联样式             最高4.调整显示的优先级  !important规则：  调整显示的优先级  将!important添加在属性值之后，与值之间用空格隔开，就能优先使用当前样式  ex:    color:red !important;</code></pre><h3 id="4-CSS基础选择器（重点）"><a href="#4-CSS基础选择器（重点）" class="headerlink" title="4.CSS基础选择器（重点）"></a>4.CSS基础选择器（重点）</h3><pre class="language-none"><code class="language-none">CODE1.选择器的作用  规范页面中哪些元素能够使用定义好的样式2.选择器详解  1.通用选择器    作用：可以修饰页面上的任何元素语法：*{样式声明}效率较低，尽量少用ex:  *{    color:red;    font-size:40px;  }</code></pre><p>2.元素选择器</p><pre class="language-none"><code class="language-none">CODE    作用：设置页面上某种（类）元素的样式语法：标记名称{声明样式}ex：  div{}  p{}  span{}  </code></pre><p>3.类选择器</p><pre class="language-none"><code class="language-none">CODE    作用：定义页面上某个或某些元素的样式(谁想用谁就可以引用)特点：通过元素的class属性进行引用语法：   1.声明     .类名{样式声明}     注意：       1.类名是自定义的，但是注意类名不能以数字开头       2.类名不能包含特殊符号（&amp;,^,%,$,#,@）       3.可以包含（_,-）   2.引用     &lt;ANY class="类名"&gt;    特殊用法：       1.多类选择器     让一个元素同时引用多个类选择器     语法：     &lt;ANY class="类名1 类名2 类名3 ..."&gt;       2.分类选择器     将元素选择器和类选择器联合使用     对同一类元素中某些特殊的内容进行修饰     语法：元素名称.类选择器{样式声明}        ex:div.text{color:red;}      &lt;div class="text"&gt;dddd&lt;/div&gt;      &lt;div&gt;d1d1d1&lt;/div&gt;</code></pre><p>4.id选择器</p><pre class="language-none"><code class="language-none">CODE作用：设置指定ID元素的样式（专属定制）语法：#id值{样式声明}ex:  &lt;div id="one"&gt;&lt;/div&gt;  #one{    color:red;  }</code></pre><p>5.群组选择器</p><pre class="language-none"><code class="language-none">CODE作用：将多个选择器放在一起进行样式的声明定义语法：选择器1,选择器2,选择器3,...{样式声明} ex:   div,#main,.mycolor,p.text{color:red;}   等同于： div{color:red}; #main{color:red}; .mycolor{color:red}; p.text{color:red};</code></pre><p>6.后代选择器</p><pre class="language-none"><code class="language-none">CODE作用：通过元素的后代关系匹配元素（多级嵌套）语法：选择器1 选择器2 选择器3{样式声明}</code></pre><p>7.子代选择器</p><pre class="language-none"><code class="language-none">CODE作用：通过元素的子代（一层层级关系）关系匹配元素语法：选择器1&gt;选择器2{样式声明}</code></pre><p>8.伪类选择器</p><pre class="language-none"><code class="language-none">CODE作用：匹配元素不同的状态的选择器语法：   所有的伪类都是以：作为开始   选择器：伪类选择器{样式声明}1.连接伪类     :link 匹配元素尚未访问的状态 :visited 匹配元素访问过的状态2.动态伪类     :hover 匹配鼠标悬停在元素上时的状态 :active 匹配元素被激活时的状态（超链接，文本框，密码框点击的时候） :focus 匹配元素获取焦点时的状态（文本框和密码框）3.选择器的优先级  权值：标识当前选择器的重要程度，权值越大优先级越高。    元素选择器：1类选择器：  10伪类选择器：10ID选择择器：100内联样式：  1000选择器的权值加到一起，大的优先权值相同，以后定义的为主</code></pre><h3 id="5-尺寸与边框"><a href="#5-尺寸与边框" class="headerlink" title="5.尺寸与边框"></a>5.尺寸与边框</h3><p>1.单位</p><pre class="language-none"><code class="language-none">CODE1.尺寸单位  1.px：像素    1024*768  2.in:英寸    1in=2.54cm  3.pt：磅(1pt=1/72in)    多数用于表示文字的大小  4.cm:厘米  5.mm:毫米  6.em:相对于父元素乘以倍数(多个父元素2em)  7.rem:根相对（元素字体大小乘以倍数，html\body）2.颜色单位（颜色取值）  1.英文单词    red,blue,gray,green,yellow,black....  2.rgb(r,g,b)    r:0-255g:0-255b:0-255  3.rgba(r,g,b,alpha)    alpha:透明度，取值为0-1之间的小数，值越大，不透明度越高  4.#rrggbb    由6位16进制的数字\字母表示一个颜色0-9或A-f#000000:黑色#ffffff:白色#eeeeee:灰色#ff11aa  5.#rgb是上面的缩写形式    #000:黑色#fff:白色#f1a</code></pre><p>2.尺寸属性</p><pre class="language-none"><code class="language-none">CODE1.作用  设置元素的宽度和高度2.语法  1.宽度    width:宽度min-width:最小宽度max-width:最大宽度  2.高度    height：高度min-height:最小高度max-height:最大高度3.页面中哪些元素允许设置尺寸属性  1.所有的块级元素都允许设置尺寸    div,p,h1,h2..h6,ul,ol,dl,结构标记  2.本身具备width和height属性的行内元素是可以设置的    img,table  3.行内块允许设置尺寸    大部分的表单控件（单选按钮，复选框）  4.大部分的行内元素是无法设置尺寸    a,span,b,i,u,s等</code></pre><p>3.溢出处理</p><pre class="language-none"><code class="language-none">CODE当内容多，元素区域小的时候，就会产生溢出的效果，默认都是纵向溢出。属性：overflow,overflow-x,overflow-y取值：   1.visible     可见的，默认值，溢出可见   2.hidden     隐藏的，溢出的内容全部隐藏，溢出内容不可见   3.scroll     显示滚动条，溢出时，可用   4.auto     自动，溢出时才显示滚动条并可用</code></pre><p>4.边框</p><pre class="language-none"><code class="language-none">CODE1.边框属性  1.简写方式    border:width style color;     width:边框的宽度，以px为单位的数值     style:边框的样式       取值：         solid:实线     dotted:虚线边框(点)     dashed:虚线边框(线)     color:边框的颜色         取值：合法的颜色值     transparent:透明色     注意：       取消边框：border:0;或border:none;  2.单边定义    只设置某一条边的边框属性：border-方向:width style color;    方向：top/bottom/left/right       上   下     左   右  3.单属性定义    只设置四条边框的一个属性属性：border-width/style/color:值；  ex:border-width:3px;     border-style:dotted;     border-color:red;  4.单边单属性的定义    只设置某一个方向的某一个属性属性：  border-方向-属性：值；  方向：top/bottom/left/right  属性：width/style/color  ex：    border-left-color:blue;    border-right-style:solid;    border-bottom-width:6px;2.边框倒角  将元素的直角倒换成圆角  属性：border-radius  取值：        1.以px为单位的数值        2.百分比 %  设置圆形（50%）  单角设置：     border-top-left-radius:左上角 border-top-right-radius:右上角 border-bottom-left-radius:左下角 border-bottom-right-radius:右下角3.边框阴影 属性：box-shadow 取值：h-shadow v-shadow blur spread color inset    h-shadow:阴影在水平方向的偏移距离，必须值        取值为正：阴影向右偏移     取值为负：阴影向左偏移v-shadow:阴影在垂直方向的偏移距离，必须值        取值为正：阴影向下偏移     取值为负：阴影向上偏移blur:阴影模糊距离，取值越大，模糊效果越明显，以px为单位的数值（可选值）spread:阴影的大小，指定要在基础阴影上扩充出来的大小，取值以px为单位的数值（可选值）color:阴影颜色（可选值）inset:将默认的外阴影改为内阴影（可选值）4.轮廓  轮廓指的是边框的边框，绘制于边框外围的一条线  属性：     outline:width style color; widht:轮廓的宽度 style:轮廓的样式      取值：solid/dotted/dashed color:轮廓的颜色  取消轮廓：       outline:none/0;</code></pre><h3 id="6-框模型"><a href="#6-框模型" class="headerlink" title="6.框模型"></a>6.框模型</h3><p>1.什么是框模型</p><pre class="language-none"><code class="language-none">CODE框模型：box model,定义了元素框处理元素的内容，内边距，外边距以及边框的一种计算方式。外边距：元素与元素之间的空白间距内边距：元素边框与元素内容之间的间距框模型的计算模式：    元素的实际占地宽度=左右外边距+左右边框+左右内边距+width;元素的实际占地高度=上下外边距+上下边框+上下的内边距+height</code></pre><h3 id="7-外边距"><a href="#7-外边距" class="headerlink" title="7.外边距"></a>7.外边距</h3><p>1.什么是外边距</p><pre class="language-none"><code class="language-none">CODE围绕在元素边框外的空白距离，就是外边距也能表示当前元素与其他元素之间的空白距离</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：   margin 定义某个元素四个方向的外边距   margin-top/bottom/left/right 定义单边的外边距取值：   1.具体数值，以px为单位   2.取值为负     让元素向相反的方向移动 margin-left:  取值为正，让元素向右移动  取值为负，让元素向左移动 margin-top:  取值为正，让元素向下移动  取值为负，让元素向上移动   3.取值为%     外边距的值，是父元素的宽或高的占比（50%）   4.取值为auto     自动计算外边距的值（控制块级元素水平居中对齐）简写方式：    1.margin:value  四个方向的外边距2.margin:v1 v2;  v1:上下外边距  v2:左右外边距3.margin:v1 v2 v3;  v1:上外边距  v2:左右外边距  v3:下外边距3.margin:v1 v2 v3 v4;         上 右 下 左  （顺时针方向）</code></pre><p>3.自带外边距的元素</p><pre class="language-none"><code class="language-none">CODEbody,h1~h6,p,ul,ol,dl,dd,pre通过CSS Reset(css重写)的手段，来重置具备外边距的元素 body,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd,pre{    margin:0; }</code></pre><p>4.外边距的特殊效果</p><pre class="language-none"><code class="language-none">CODE1.外边距合并  当两个垂直外边距相遇时，他们将合并为一个，最终取决于两个外边距中距离较大的那个。  如果两个外边距相遇时值相等，那么取其中一个值。2.外边距的溢出  在某些条件下，为子元素设置上外边距时，有可能会作用到父元素上。      1.父元素没有上边框  2.为子元素设置上外边距时2.在d2中嵌套一个子元素div,id="d3",设置其尺寸为100*100，并设置其背景颜色3.设置d3的上外边距为50px,观察其结果。 解决溢出方案：    1.为父元素增加上边框  弊端：对父元素的高度有影响2.使用父元素的上内边距来取代子元素的上外边距  弊端：对父元素的高度有影响3.在父元素的第一个子元素位置处，增加一个空(table) 行内元素以及行内块元素的垂直外边距     1.行内元素垂直外边距无效（img除外） 2.行内块元素，设置垂直外边距时，整行元素都跟着发生改变</code></pre><h3 id="8-内边距"><a href="#8-内边距" class="headerlink" title="8.内边距"></a>8.内边距</h3><p>1.什么是内边距</p><pre class="language-none"><code class="language-none">CODE元素边框与内容之间的空白距离内边距会扩大元素边框占地区域</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：   padding 四个方向的内边距   padding-top/bottom/left/right 设置单边内边距取值：      以px为单位的数值      以%形式设置简写方式：      1.padding:value;  四个方向的内边距  2.padding:v1 v2;     v1:上下内边距    v2:左右内边距  3.padding:v1 v2 v3;    v1:上    v2:左右    v3:下  4.padding:v1 v2 v3 v4;            上 右 下 左 （顺时针）</code></pre><h3 id="9-属性：box-sizing"><a href="#9-属性：box-sizing" class="headerlink" title="9.属性：box-sizing"></a>9.属性：box-sizing</h3><p>作用：指定框模型的计算方式</p><pre class="language-none"><code class="language-none">CODE取值：   1.content-box     默认值，采用默认的计算元素的占地区域 实际占地宽度=左右边框+左右外边距+左右内边距+width; 实际占地高度=上下边框+上下外边距+上下内边距+height;   2.border-box     元素的尺寸，会包含border以及padding的值 实际占地宽度=width(包含了border和padding) 实际占地高度=height(包含了border和padding)</code></pre><p>3.背景属性<br>背景：可以是单一颜色或图片填充元素<br>1.背景色</p><pre class="language-none"><code class="language-none">CODE属性：background-color取值：合法的颜色值注意：背景颜色默认是从边框的位置处开始填充的</code></pre><p>2.背景图片</p><pre class="language-none"><code class="language-none">CODE属性：background-image取值：url(图片的路径);ex:background-image:url(a.jpg);</code></pre><p>3.背景图片平铺</p><pre class="language-none"><code class="language-none">CODE属性：background-repeat取值：   repeat 默认值，横向纵向都平铺   no-repeat 不平铺（图片只显示一次）   repeat-x 只在水平方向平铺   repeat-y 只在垂直方向平铺</code></pre><p>4.背景图片尺寸</p><pre class="language-none"><code class="language-none">CODE属性：background-size取值：   1.width/height  (ex:200px 300px)   2.width%/height%  (ex:50% 50% 是元素自己的高宽占比)   3.cover     将背景图等比放大，直到背景图完全覆盖到元素的所有区域为止。   4.contain     将背景图等比放大，直到背景图碰到元素的某一个边缘为止</code></pre><p>5.背景图片固定</p><pre class="language-none"><code class="language-none">CODE作用：将背景图固定在网页的某个位置处，一直在可视区域中，不会随着滚动条而发生位置的变化。属性：background-attachment取值：   1.scroll 默认值，滚动   2.fixed 固定</code></pre><p>6.背景图片定位</p><pre class="language-none"><code class="language-none">CODE作用：改变背景图在元素中的位置属性：background-position取值：   1.x y  具体的数值（px）     x:   背景图水平偏移距离   取值为正，向右移动   取值为负，向左移动 y:   背景图垂直偏移距离   取值为正，向下移动   取值为负，向上移动   2.x% y%     0% 0% 背景图在左上角 100% 100% 背景图在右下角 50% 50% 背景图在中间位置   3.关键字 x:left/center/right y:top/center/bottom ex:background-position:right top;</code></pre><p>7.背景简写属性</p><pre class="language-none"><code class="language-none">CODE在一个属性中指定背景的多个属性值属性：background取值：color url() repeat attachment positionex：  background:gray url(a.jpg);注意：  如果不设置其中某个属性值的话，该位置采用默认值。</code></pre><h3 id="8-渐变"><a href="#8-渐变" class="headerlink" title="8.渐变"></a>8.渐变</h3><p>1.什么是渐变</p><pre class="language-none"><code class="language-none">CODE渐变指定是多种颜色平缓变换的一种显示效果。</code></pre><p>2.渐变的主要因素</p><pre class="language-none"><code class="language-none">CODE1.色标：一种颜色及其出现的位置2.一个渐变是由多个色标组成（至少两个）</code></pre><p>3.渐变分类</p><pre class="language-none"><code class="language-none">CODE1.线性渐变  以直线的方向来填充效果2.径向渐变  以圆形的方式来实现填充3.重复渐变  将线性渐变或径向渐变 重复几次实现填充</code></pre><p>4.渐变详解</p><pre class="language-none"><code class="language-none">CODE1.线性渐变  属性：background-image  取值：linear-gradient(angle,color-point1,color-point2,....);    1.angle  表示渐变填充的方向或角度  取值：    1.关键字      to top 从下向上填充渐变色      to bottom 从上向下填充渐变色      to left 从右向左填充渐变色      to right 从左向右填充渐变色    2.角度值     0deg 从下向上填充，等同于to top     90deg 从左向右填充，等同于to right     180deg 从上到下填充，等同于to bottom     270deg 从右向左填充，等同于to left    2.color-point  色标：颜色 及其 位置  取值：颜色 以及 位置的组合，中间用空格分开  ex:    1.red 0%      在填充方向的开始位置处颜色为红色    2.green 50%      到填充方向一半的位置处，颜色变为绿色    3.blue 200px      到填充方向的200px的位置处，颜色变为蓝色2.径向渐变  属性：  background-image:radial-gradient([size at position],  color-point1,color-point2,...);  size at position:       size:半径，以px为单位的数值  position:圆心所在位置       1.x y 具体数值       2.x% y% 元素宽和高的占比       3.关键字         x:left,center,right     y:top,center,bottom  ex：    100px at right top 半径     右上角位置3.重复渐变  1.重复线性渐变    background-image:repeating-linear-gradient    (angle,color-point1,color-point2,...);color-point:位置一定要给绝对数值（px）,不要用相对单位%  2.重复径向渐变    background-image:repeating-radial-gradient    ([size at position],color-point1,color-point2,...);</code></pre><h3 id="9-浏览器兼容性"><a href="#9-浏览器兼容性" class="headerlink" title="9.浏览器兼容性"></a>9.浏览器兼容性</h3><pre class="language-none"><code class="language-none">CODE 各个浏览器的新版本都支持渐变属性对于不支持的浏览器版本，可以通过增加浏览器前缀的方式，让浏览器支持渐变属性Firefox:-moz-Chrome &amp; Sagari:-webkit-Opera:-o-IE:-ms-</code></pre><p>2.文本格式化属性<br>1.字体属性</p><pre class="language-none"><code class="language-none">CODE1.指定字体  属性：font-family  取值：字体名称，名称之间用逗号隔开  ex：  font-family:"微软雅黑",Arial,"黑体";2.字体大小  属性：font-size  取值：以px或pt为单位的数字3.字体加粗  属性：font-weight  取值：     1.bold 加粗（b,hn） 2.normal 正常 3.value 无单位的数字（整百倍）   400-900   400：等同于normal   900：等同于bold4.字体样式  属性：font-style  取值：     1.normal 正常显示  2.italic 斜体显示5.小型大写字母   将小写字符变成大写，但文本的大小与小写字符一致   属性：font-variant   取值：      1.normal 正常  2.small-caps 小型的大写字符6.字体属性简写  属性：font  取值：style variant weight size family;  注意：    如果用简写方式，必须设置family的值，否则无效。font:12px; 错误font:12px "黑体"; 正确</code></pre><p>2.文本格式</p><pre class="language-none"><code class="language-none">CODE1.文本颜色  属性：color  取值：合法的颜色值2.文本排列  作用：指定文本，行内，行内块元素的水平对齐方式。  属性：text-align  取值：left/center/right/justify(两端对齐)3.文字修饰（线条）  属性：text-decoration  取值：    none:无任何线条修饰underline:下划线修饰overline:上划线修饰    line-through:删除线修饰4.行高  作用:定义一行文本的高度  特点：如果行高的高度大于字体本身的大小，那么该行文本将在指定的行高内呈现垂直居中的效果。  属性:line-height  取值：以px为单位数值5.首行文本缩进  属性：text-indent  取值：以px为单位的数值6.文本阴影  属性：text-shadow  取值：h-shadow v-shadow blur color;</code></pre><h3 id="10-表格"><a href="#10-表格" class="headerlink" title="10.表格"></a>10.表格</h3><p>1.表格的常用属性</p><pre class="language-none"><code class="language-none">CODE1.边距属性：padding2.边框属性：border3.尺寸属性：width,height4.文本格式化属性：font-*,text-*,line-height5.背景属性：颜色，图片，渐变6.vertical-align  作用：指定单元格数据垂直对齐方式  取值：     top:上对齐 middle:居中对齐 bottom:下对齐 练习：创建网页，并在网页中添加表格     1.表格尺寸为400*400，4行4列; 2.每个单元格的尺寸为100*100,内容随意; 3.设置表格和单位元格的边框为1px solid #000; 4.设置每个单元格的左内边距为20px; 5.尝试为每个单元格增加上外边距15px。</code></pre><p>2.表格的特殊属性</p><pre class="language-none"><code class="language-none">CODE1.边框合并  取值：border-collapse  取值：     1.separate   默认值，即分离边框模式 2.collapse   边框合并2.边框边距  作用：设置单元格之间或单元格与表格之间的距离  属性：border-spacing  取值：    1.给定一个值：水平和垂直的间距相同2.给两个值：  第一个值 表示水平间距  第二个值 表示垂直间距注意：只有在边框分离模式下，边框边距才有效果，即border-collapse:separate时，border-spacing才有效。</code></pre><p>3.表格标题位置</p><pre class="language-none"><code class="language-none">CODE属性：caption-side取值：    1.top:默认值，标题在表格内容之上2.bottom:标题在表格内容之下</code></pre><p>4.显示规则</p><pre class="language-none"><code class="language-none">CODE作用：用来帮助浏览器指定如何布局一张表，也就是指定td尺寸的计算方式。属性：table-layout取值：   1.auto     默认值，即自动布局表格，列的尺寸实际上由内容来决定的。   2.fixed     固定表格布局，列的尺寸由设置的值为准自动表格布局VS固定表格布局：    1.自动表格布局  1.单元格的大小会适应内容  2.表格复杂时，加载速度较慢（缺点）  3.自动表格布局会比较灵活（优点）  4.适用于不确定每列大小时使用    2.固定表格布局  1.单元格的尺寸取决于设定的值  2.任何情况下都会加载显示表格（优点）  3.适用于确定每列大小时使用  4.固定表格布局不够灵活（缺点）</code></pre><h3 id="11-定位-浮动定位"><a href="#11-定位-浮动定位" class="headerlink" title="11.定位-浮动定位"></a>11.定位-浮动定位</h3><p>1.定位</p><pre class="language-none"><code class="language-none">CODE定位：指的是改变元素在页面中的默认位置</code></pre><p>2.定位的分类</p><pre class="language-none"><code class="language-none">CODE按照定位的效果，可以分成以下几类：   1.普通流定位（默认的定位方式）   2.浮动定位   3.相对定位   4.绝对定位   5.固定定位</code></pre><p>3.定位详解</p><pre class="language-none"><code class="language-none">CODE1.普通流定位  又称为文档流定位，页面中元素的默认定位方式  1.每个元素在页面中都有自己的空间  2.每个元素默认都是在其父元素的左上角开始显示  3.页面中的块级元素都是从上往下排列，每个元素独占一行  4.页面中的行内元素以及行内块都是按照从左到右的顺序来排列的  要解决的问题：让多个块级元素在一行中显示2.浮动定位  1.什么是浮动&amp;特点    1.元素一旦浮动起来，将不占据页面空间（脱离了文档流），其它未浮动元素将上前补位。2.浮动元素会停靠在父元素的左边或右边，或其它已经浮动的元素的边缘上。3.浮动定位解决的问题：能够让多个块级元素在一行中显示。  2.语法    属性：float取值：   1.left     左浮动，让元素停靠在父元素的左边或挨着左侧已经浮动的元素   2.right     右浮动，让元素停靠在父元素的右边或挨着右侧已经浮动的元素   3.none     默认值，即无任何浮动效果</code></pre><h3 id="12-浮动引发的特殊效果"><a href="#12-浮动引发的特殊效果" class="headerlink" title="12.浮动引发的特殊效果"></a>12.浮动引发的特殊效果</h3><p>1.元素一旦浮动起来以后就会变成块级元素</p><pre class="language-none"><code class="language-none">CODE允许修改尺寸能正常处理垂直方向外边距</code></pre><p>2.当父元素显示不下所有已浮动元素时，最后一个将换行，但是，有可能被卡住；<br>3.元素一旦浮动起来后，宽度将以内容为主（未指定宽度情况下）；<br>4.文本，行内元素，行内块元素是采用环绕的方式来排列的，是不会别浮动元素压在底下的，而会巧妙的避开浮动元素。</p><h3 id="13-清除浮动带来的影响"><a href="#13-清除浮动带来的影响" class="headerlink" title="13.清除浮动带来的影响"></a>13.清除浮动带来的影响</h3><p>元素一旦浮动起来之后，就会对后续元素带来一定的位置影响（后续元素要上前补位），如果后续元素不想被影响（不想补位），那么就可以通过清除浮动的方式来解决<br>属性：clear<br>取值：</p><pre class="language-none"><code class="language-none">CODE1.left  清除当前元素前面的元素左浮动所带来的影响2.right  清除当前元素前面的元素右浮动所带来的影响3.both  清除当前元素前面元素任何一种浮动所带来的影响4.none  默认值，不做任何的清除浮动操作</code></pre><h3 id="14-浮动元素对父元素高度的影响"><a href="#14-浮动元素对父元素高度的影响" class="headerlink" title="14.浮动元素对父元素高度的影响"></a>14.浮动元素对父元素高度的影响</h3><p>1.元素的高度都是以未浮动元素的高度为准的，浮动元素是不占页面的高度的</p><pre class="language-none"><code class="language-none">CODE 解决父元素的高度方案如下：    1.直接设置父元素的高度  弊端：不是每次都知道父元素的高度2.设置父元素也浮动  弊端：不是任何时候父元素都需要浮动，而且浮动会影响后续元素3.为父元素设置overflow  取值：hidden或auto  弊端：如果有内容需要溢出显示的话，也会一同被隐藏4.在父元素中，追加空子元素(块级)，并设置其clear:both;</code></pre><h3 id="15-显示"><a href="#15-显示" class="headerlink" title="15.显示"></a>15.显示</h3><p>1.显示方式</p><pre class="language-none"><code class="language-none">CODE1.什么是显示方式  决定了元素在网页中的表现形式（块级，行内，行内块）2.语法  属性：display  取值：     1.none 不显示元素-隐藏   特点：脱离文档流，不占据页面空间 2.block   让元素表现的和块级元素一致   特点：      独占一行，可是修改高宽 3.inline   让元素表现的和行内元素一致   特点：      不允许修改尺寸      多个元素在一行中显示      无法设置垂直外边距 4.inline-block   让元素表现的和行内块元素一致   特点：     多个元素在一行中显示，但是可以修改尺寸 5.table   让元素表现的与表格一致   特点：      尺寸以内容为准      每个元素独占一行      允许修改尺寸</code></pre><p>2.显示效果</p><pre class="language-none"><code class="language-none">CODE1.显示/隐藏  属性：visibility  取值：      1.visible:默认值，元素可见  2.hidden:元素不可见-隐藏  面试：display:none和visibility:hidden的区别        display:none 不占页面空间    visibility:hidden 占页面空间2.透明度  属性：opacity  取值：0.0（完全透明）~1.0（完全不透明）之间的小数3.垂直方向对齐方式  属性：vertical-align  场合：     1.表格中使用   取值：top/bottom/middle 2.图片（img）中使用   取值：      top：上      bottom：下      middle：中间      baseline:基线对齐，默认值</code></pre><h3 id="16-光标"><a href="#16-光标" class="headerlink" title="16.光标"></a>16.光标</h3><p>1.作用</p><pre class="language-none"><code class="language-none">CODE改变鼠标悬停在元素上时，鼠标的状态</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：cursor取值：    1.default: 默认2.pointer: 小手3.crosshair: +4.text: I5.wait: 等待6.help: 帮助 练习：   新建一个div元素，当鼠标移入到div上时，让光标变成小手状态。</code></pre><h3 id="17-列表"><a href="#17-列表" class="headerlink" title="17.列表"></a>17.列表</h3><p>1.列表项标记</p><pre class="language-none"><code class="language-none">CODE属性：list-style-type取值：   1.none   2.disc   3.circle   4.square</code></pre><p>2.列表项图像</p><pre class="language-none"><code class="language-none">CODE作用：使用自定义图像作为列表项标识属性：list-style-image取值：url(图像路径);</code></pre><p>3.列表项位置</p><pre class="language-none"><code class="language-none">CODE作用：将默认的列表项标识的位置，放到li里面属性：list-style-position取值：   1.outside 默认值，将标识显示在li外面的   2.inside 将标识放于li里面</code></pre><p>4.列表属性简写</p><pre class="language-none"><code class="language-none">CODE属性：list-style取值：type url() position;常用方式：list-style:none;列表的使用场合：   横向排列或纵向排列的内容，都可以使用列表来实现。</code></pre><h3 id="18-定位"><a href="#18-定位" class="headerlink" title="18.定位"></a>18.定位</h3><p>相对定位，绝对定位，固定定位<br>1.定位相关属性</p><pre class="language-none"><code class="language-none">CODE属性：position取值：   1.static:静态，默认值   2.relative:相对定位   3.absolute:绝对定位   4.fixed:固定定位</code></pre><p>2.偏移属性</p><pre class="language-none"><code class="language-none">CODEtop/bottom/left/right以上四个属性的取值均为数字ex:  top:150px 元素向下移动150px  left:20px 元素向右移动20px  right:-150px 元素向右移动150px注意：  只有已定位元素才能使用偏移属性</code></pre><p>3.定位详解</p><pre class="language-none"><code class="language-none">CODE1.相对定位  1.什么是相对定位    元素相对于它原来的位置偏移某个距离  2.使用场合    做元素位置微调时使用  3.语法      position:relative;      配合偏移属性来实现位置的移动      left:10px;      top:10px;2.绝对定位  1.什么是绝对定位&amp;特点    1.绝对定位的元素会脱离文档流-不占页面空间2.绝对定位的元素会相对于离他最近的，已定位的，祖先元素 去实现位置的初始化。3.如果没有已定位的祖先元素，那么该元素就相对于body去实现位置的初始化4.配合偏移属性 实现元素位置的修改  2.语法    position:absolute;配合偏移属性实现位置的修改  3.使用场合    1.有堆叠效果的元素2.弹出菜单  4.注意：    1.脱离文档流-不占据页面空间2.绝对定位元素会变成块级元素  5.堆叠顺序    一旦元素变为已定位元素的话，元素们则有可能出现堆叠的效果属性：z-index取值：无单位的数字，数字越大越靠上    注意：  1.只有已定位元素才能实现堆叠顺序的改变（z-index）  2.父子元素间，z-index无效，永远都是子元素压在父元素上方3.固定定位  1.什么是固定定位    将元素固定在网页的某个位置处，位置不会随着滚动条而发生改变，固定在可视区域中。  2.语法    position:fixed;配合偏移属性使用  注意：    1.固定定位的元素永远都是相对于body去实现位置的初始化和偏移。2.固定定位的元素会变成块级元素3.固定定位元素会脱离文档流-不占页面空间</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
