<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo 使用教程</title>
      <link href="/2021/09/26/hexo/"/>
      <url>/2021/09/26/hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="新建一篇博客"><a href="#新建一篇博客" class="headerlink" title="新建一篇博客"></a>新建一篇博客</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><h3 id="提交修改到my-blog上"><a href="#提交修改到my-blog上" class="headerlink" title="提交修改到my-blog上"></a>提交修改到my-blog上</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit -m <span class="token string">"msg"</span><span class="token function">git</span> push origin master:my-blog</code></pre><h3 id="自动开启自动化部署"><a href="#自动开启自动化部署" class="headerlink" title="自动开启自动化部署"></a>自动开启自动化部署</h3><pre class="language-bash" data-language="bash"><code class="language-bash">打开https://jingwzeng.github.io就可以自动部署</code></pre><h3 id="表情包"><a href="#表情包" class="headerlink" title="表情包"></a>表情包</h3><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f616.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f623.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>表情包代码地址:<a href="https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-3">https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-3</a></p><p><span class="github-emoji"><span>🆖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f196.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  <span class="github-emoji"><span>8⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0038-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🅰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f170.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尾调用</title>
      <link href="/2021/09/26/wei-diao-yong/"/>
      <url>/2021/09/26/wei-diao-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><blockquote><p>尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p></blockquote><p>需要注意的是最后一步不是指最后一行代码，甚至<code>return fn() - 1</code>,即使在同一行，也不是尾调用。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除<code>f()</code>的调用记录，只保留<code>g(3)</code>的调用记录。</p><p>这就叫做”尾调用优化”（<code>Tail call optimization</code>），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><blockquote><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p></blockquote><p>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（<code>stack overflow</code>）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">===</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 改成尾递归</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>total</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">===</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> total    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">*</span>total<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>递归函数的改写：</p><p>就是把内部变量改写成函数的参数。上述中需要用到的是total变量，把它改成函数的参数就可以。但是不太直观。这个时候可以利用柯里化<code>currying</code>,它的意思就是将多参数的函数转换成单参数的函数。例如：</p></blockquote><pre class="language-none"><code class="language-none">function currying(fx(),n){    return function(m){        return fx.call(this,m,n) // call用来绑定作用域，防止乱跑，绑定的是f的作用域，m是f的函数参数，这个例子可以不用call    }}function fn(n,total){    if(n===1) return total    return fn(n-1,n*total) }const f  = currying(fn,1)f(5)  // 120</code></pre><p>递归的本质是循环，循环可以用递归代替，但是用递归，就最好使用尾递归。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p><code>ES6的</code>尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><blockquote><p><code>arguments</code>：返回调用时函数的参数。</p><p><code>func.caller</code>：返回调用当前函数的那个函数。</p></blockquote><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真（不真实，看起来没有优化，如下图）。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109261152460.png"></p><p>看起来函数调用记录为5条，原因是没有开启严格模式，如果开启严格模式的话，禁止调式了,无法跟踪调用栈。</p>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2021/09/24/http/"/>
      <url>/2021/09/24/http/</url>
      
        <content type="html"><![CDATA[<h3 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h3><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109240942964.png" alt="image-20210924094205809"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>目的是为了保证客户端和服务端各自的可分发，就是为了确保对方是否确认收到，连接是否成功，也就是为啥<code>TCP</code>是可靠的连接</p><p>简要的说明就是利用<code>TCP</code>的标志<code>SYN</code>和<code>ACK</code>。发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名断。<code>TCP</code> 协议会再次以相同的顺序发送相同的数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109240946219.png" alt="image-20210924094620148"></p><h3 id="http无状态保存"><a href="#http无状态保存" class="headerlink" title="http无状态保存"></a>http无状态保存</h3><p><code>http</code>协议自身不具备保存之前发送的请求和响应的功能。如果为了实现保存状态的功能，可以利用cookie技术，<code>cookie</code>与<code>http</code>配合，就可以管理状态了。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241001237.png" alt="image-20210924100144178"></p><h3 id="URL和URI"><a href="#URL和URI" class="headerlink" title="URL和URI"></a>URL和URI</h3><p><code>URL</code>统一资源定定位符，也就是在浏览器中输入的地址，<code>URI</code>统一资源标识符，用来标识服务器中具体的某一个资源，也就是请求体内容。<code>URI</code>包含<code>URL</code></p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p><code>HEAD</code>方法和<code>GET</code>方法一样，只是不返回报文主体部分。用于确认<code>URI</code>的有效性及资源更新的日期时间等。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p><code>DELETE</code> 方法用来删除文件，是与<code>PUT</code>相反的方法(上传文件)。<code>DELETE</code>方法按请求<code>URI</code>删除指定的资源。但是，<code>HTTP/1.1</code>的<code>DELETE</code>方法本身和<code>PUT</code>方法一样不带验证机制，所以一般的<code>Web</code>网站也不使用<code>DELETE</code>方法。当配合<code>Web</code>应用程序的验证机制，或遵守<code>REST</code>标准时还是有可能会开放使用的。</p><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p> <code>OPTIONS</code>方法用来查询针对请求<code>URI</code>指定的资源支持的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241014932.png" alt="image-20210924101436881"></p><h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>TRACE 方法是让 Web 服务器端将之前的请求经过的路径返回的发放。发送请求时，在<code>Max-Forwards</code>首部字段中填入数值，每经过一个服务器端就将该数字减<code>1</code>，当数值刚好减到<code>0 </code>时，就停止继续传输，最后接收到请求的服务器端则返回状态码<code>200 OK</code>的响应。客户端通过 <code>TRACE</code>方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，<code>TRACE</code>方法就是用来确认连接过程中发生的一系列操作。但是，<code>TRACE</code>方法本来就不怎么常用，再加上它容易引发<code>XST</code>（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241017163.png" alt="image-20210924101739103"></p><h3 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h3><p><code>CONNECT</code>方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行<code>TCP</code>通信。主要使用<code>SSL</code>（Secure Sockets Layer，安全套接层）和<code>TLS</code>（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<code>CONNECT</code>方法的格式如下所示。</p><p><code>CONNECT 代理服务器名:端口号 HTTP版本</code></p><h3 id="http1-1新增的持久连接alive"><a href="#http1-1新增的持久连接alive" class="headerlink" title="http1.1新增的持久连接alive"></a>http1.1新增的持久连接alive</h3><p>持久连接就是建立一次<code>TCP</code>连接，只要任意一段没有断开连接，就可以保持<code>TCP</code>的连接，可以在这个连接中发送多次的<code>http</code>请求。在<code>http1.1</code>中，所有的连接默认都是持久连接。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241028553.png" alt="image-20210924102855479"></p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241032880.png" alt="image-20210924103216826"></p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><code>Cookie</code>会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存<code>Cookie</code>。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 <code>Cookie</code>值后发送出去。服务器端发现客户端发送过来的<code>Cookie</code>后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241036362.png" alt="image-20210924103615311"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241036604.png" alt="image-20210924103624559"></p><h3 id="服务端两种编码方式"><a href="#服务端两种编码方式" class="headerlink" title="服务端两种编码方式"></a>服务端两种编码方式</h3><ul><li>压缩</li></ul><p><code>gzip</code>压缩之后发给客户端，客户端解压缩该实体。属于内容编码的一种，内容编码指明应用在实体内容上的编码格式，并报出实体信息原样的压缩。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241049574.png" alt="image-20210924104947519"></p><ul><li>分割</li></ul><p>在<code>HTTP</code>通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码<code>Chunked TransferCoding</code></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241051913.png" alt="image-20210924105147859"></p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>比如一个图片下载中断，从中断处开始返回数据给客户端，就是范围请求。用<code>Range</code>来指定<code>byte</code>的范围</p><p><code>Range: bytes = 5001-10000</code></p><p>针对范围请求，响应会返回状态码为206 <code>Partial Content</code>(部分内容),对于多重范围的范围请求，响应会在首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code>后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码<code>200 OK</code>和完整的实体内容</p><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。比如需要显示中文还是英文。</p><p><code>Accept</code></p><p><code>Accept-Charset</code></p><p><code>Accept-Encoding</code></p><p><code>Accept-Language</code></p><p><code>Content-Language</code></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table><thead><tr><th align="center"></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息性状态码</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">成功状态码</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">重定向状态码</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误状态码</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">服务器错误状态码</td><td align="center">服务器处理请求出错</td></tr></tbody></table><ul><li>204 No Content</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241400622.png" alt="image-20210924140001523"></p><ul><li><p>206 Partial Content </p><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241400521.png" alt="image-20210924140040466"></p><ul><li>301 Moved Permanently(永久性的) 永久重定向</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241402164.png" alt="image-20210924140247109"></p><ul><li>302 Found 临时重定向</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241403706.png" alt="image-20210924140353652"></p><ul><li>303 See Other</li></ul><p>表示由于请求对应的资源存在另一个<code>url</code>,应该使用<code>get</code>方向定向获取请求的资源，与302有相同的功能，但是303明确表示客户端应该使用<code>get</code>方法获取</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241404090.png" alt="image-20210924140432027"></p><ul><li>304 Not Modified</li></ul><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 <code>3XX</code>类别中，但是和重定向没有关系。附带条件的请求是指采用<code>GET</code>方法的请求报文中包含<code>If-Match</code>，<code>If-Modified-Since</code>，<code>If-None-Match</code>，<code>If-Range</code>，<code>If-Unmodified-Since</code> 中任一首部。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241408325.png" alt="image-20210924140830269"></p><ul><li>307 Temporary(临时的) Redirect</li></ul><p>临时重定向，和302的含义相同。不同的就是307不会把<code>post</code>请求变成<code>get</code>请求，而302会把<code>post</code>请求变成<code>get</code>请求再重新向新的<code>url</code>发一次请求。</p><ul><li>400 Bad Request </li></ul><p>请求报文中存在语法错误，需要修改请求的内容后再次发送请求。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241413872.png" alt="image-20210924141359814"></p><ul><li>401 Unauthorized(未经授权的)</li></ul><p>需要认证的时候会返回401，第一次返回一个窗口用来填认证信息。第二次返回401，表示认证信息错误。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241415442.png" alt="image-20210924141558351"></p><ul><li>403 Forbidden 禁止访问</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241417243.png" alt="image-20210924141732185"></p><ul><li>500 Internal Server Error</li></ul><p>服务器在执行请求的时候发生了错误</p><ul><li>503 Service Unavailable（无法使用）</li></ul><p>服务器无法使用</p><h3 id="网关、代理、隧道"><a href="#网关、代理、隧道" class="headerlink" title="网关、代理、隧道"></a>网关、代理、隧道</h3><ul><li>代理就是充当”中间人”的角色,作用有 ①利用缓存技术，缓存资源在代理服务器上②对网站做访问控制③获取访问日志</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241431465.png" alt="image-20210924143126370"></p><ul><li>网关和代理类似，也是”中间人”的角色，但是网关还可以进行协议的转换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241431063.png" alt="image-20210924143114001"></p><ul><li>隧道的目的是为了保证客户端和服务端进行安全的通行。与服务器之间建立一条通信线路，加<code>ssl</code>等加密手段进行通行。隧道不会解析<code>http</code>请求，隧道会在通信双方断开连接时结束。它是透明的，客户端不用在意隧道是否存在。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241434105.png" alt="image-20210924143454048"></p><h3 id="常用的首部字段说明"><a href="#常用的首部字段说明" class="headerlink" title="常用的首部字段说明"></a>常用的首部字段说明</h3><p><strong>全部字段表</strong></p><ol><li>通用首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241523112.png" alt="image-20210924152325070"></p><ol start="2"><li>请求首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241524827.png" alt="image-20210924152336694"></p><ol start="3"><li>响应首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241524179.png" alt="image-20210924152432141"></p><ol start="4"><li>实体首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241524746.png" alt="image-20210924152459708"></p><p><strong>Cache-Control</strong> </p><p>HTTP/1.1之前的字段是<code>Pragma</code>,为了兼容可以这样写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Cache<span class="token operator">-</span>Control<span class="token operator">:</span> no<span class="token operator">-</span>cachePragma<span class="token operator">:</span> no<span class="token operator">-</span>cache</code></pre><blockquote><p>缓存请求指令</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241456764.png" alt="image-20210924145651720"></p><blockquote><p>缓存响应指令</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241457014.png" alt="image-20210924145724967"></p><ul><li><code>no-cache</code>指令的目的是为了防止从缓存中返回过期的资源。客户端不接受缓存过的响应，必须向服务器转发该请求。<code>no-cache</code>代表不缓存过期的资源，而<code>no-store</code>才是代表不缓存。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241459585.png" alt="image-20210924145931526"></p><ul><li><code>max-age</code>，没有超过这个时间，缓存服务器直接返回资源就可以，不需要通知源服务器，为0的时候代表缓存服务器需要将请求转发给源服务器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241507772.png" alt="image-20210924150717700"></p><ul><li><code>no-transform</code>可以防止缓存服务器或者代理服务器压缩图片等操作。</li></ul><p><strong>Connection</strong></p><ol><li>控制不再转发给代理的首部字段</li></ol><p><code>Connection:不再转发的首部字段名</code></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241516619.png" alt="image-20210924151610550"></p><ol start="2"><li>管理持久化连接</li></ol><p><code>Connection:close</code></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241516041.png" alt="image-20210924151652996"></p><p><code>HTTP/1.1</code>的默认连接都是持久连接<code>Connection:keep-alive</code></p><p><strong>If-xxx</strong> </p><p>这种请求首部字段被称为条件请求。服务器接收到附带的条件之后，只有判断指定条件为真，才会执行请求。</p><ul><li><code>If-Match</code>和服务器的<code>ETag</code>一致，服务器会接受请求。设置为*的时候，只要资源存在就进行处理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241547218.png" alt="image-20210924154757101"></p><ul><li><code>If-Modified-Since</code>指定的日期时间后，资源发生了更新，服务器会接受请求</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241549636.png" alt="image-20210924154924519"></p><ul><li><code>If-None-Match</code> 字段值与服务器的<code>ETag</code>不一致的时候，可处理该请求。与<code>If-Match</code>相反。通常在<code>get</code>方法中用来获取最新的资源，随便指定一个服务器没有的数据，就可以了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241553487.png" alt="image-20210924155359416"></p><ul><li><code>If-Range</code> 也是需要和服务端的<code>ETag</code>进行比较的，如果一致的话就返回需要的范围资源，如果不一致的话就返回需要的所有的资源。如果不使用<code>If-Range</code>的话，那么遇到这种情况客户端和服务端之间需要进行两次请求。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251336101.png" alt="image-20210925133639867"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251337330.png" alt="image-20210925133707273"></p><ul><li><code>Referer（来路）</code>可以查看请求的<code>URL</code>是从哪个<code>Web</code>页面发起的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251348612.png" alt="image-20210925134831560"></p><ul><li><code>ETag</code>是将资源以字符串的形势作为唯一标识的方式。服务器会为每份资源分配对应的<code>ETag</code>值。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251353514.png" alt="image-20210925135339470"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251354945.png" alt="image-20210925135414911"></p><ul><li><code>Vary</code>规定代理服务器只能缓存相同字段值的资源。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251358223.png" alt="image-20210925135831172"></p><ul><li><p><code>Content-MD5</code>客户端会对接受的报文主体执行相同的<code>MD5</code>算法，然后用来跟该字段的值进行比较。从而保证报文内容的完整性，但是需要注意的是这样是没有办法知道报文是否被篡改的，因为如果报文内容被篡改的话，那么报文的<code>MD5</code>也一样可以被篡改。</p></li><li><p><code>Expries(过期)</code>告诉客户端该资源的失效日期。如果是缓存服务器的话，在这个日期之前，资源的副本一直保存着，过了这个日期之后呢，就会转向源服务器请求资源。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251410919.png" alt="image-20210925141034872"></p><ul><li><p><code>Last-Modified</code>资源的最后修改时间</p></li><li><p><code>Cookie</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251412001.png" alt="image-20210925141248958"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251413667.png" alt="image-20210925141309637"></p><blockquote><ol><li><p>expires 不显示指定的话，就是会话的Cookie。Cookie一旦被发送到客户端，服务端是没有办法显示删除该Cookie的，但是可以通过覆盖过期的Cookie，来间接的对客户端的Cookie进行删除</p></li><li><p>path 收到cookie的文件目录范围</p></li><li><p>domain 比如，当指定 <code>example.com</code> 后，除 <code>example.com</code> 以外，<code>www.example.com</code>或 <code>www2.example.com</code> 等都可以发送 Cookie</p></li><li><p>HttpOnly 无法使用<code>document.cookie</code>拿到Cookie的内容</p></li></ol></blockquote><h3 id="HTTPS的加密原理"><a href="#HTTPS的加密原理" class="headerlink" title="HTTPS的加密原理"></a>HTTPS的加密原理</h3><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251433704.png" alt="image-20210925143346605"></p><p>简单来说就是利用非对称加密来传输对称加密需要用到的密钥。而证书机构就是用来判断该服务器是我想要访问的那个服务器。</p><h3 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h3><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251450631.png" alt="image-20210925145036564"></p><p>步骤 1：客户端把用户<code>ID</code>和密码等登录信息放入报文的实体部分，通常是以<code>POST</code>方法把请求发送给服务器。而这时，会使用<code>HTTPS</code>通信来进行<code>HTML</code>表单画面的显示和用户输入数据的发送。</p><p>步骤 2：服务器会发放用以识别用户的<code>Session ID</code>。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与<code>Session ID </code>绑定后记录在服务器端。向客户端返回响应时，会在首部字段 <code>Set-Cookie</code> 内写入 <code>SessionID</code>（如PHPSESSID=028a8c…）。你可以把 <code>Session ID</code> 想象成一种用以区分不同用户的等位号。然而，如果<code>Session ID</code>被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止<code>Session ID</code>被盗，或被猜出。为了做到这点，<code>Session ID</code> 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（<code>XSS</code>）造成的损失，建议事先在<code>Cookie</code>内加上<code>httponly </code>属性。</p><p>步骤 3：客户端接收到从服务器端发来的<code>Session ID</code>后，会将其作为<code>Cookie</code>保存在本地。下次向服务器发送请求时，浏览器会自动发送<code>Cookie</code>，所以<code>Session ID</code>也随之发送到服务器。服务器端可通过验证接收到的<code>Session ID</code>识别用户和其认证状态。</p><ul><li>还有一种方式是利用”加盐”处理,密码加盐<code>salt</code>，然后使用散列函数计算出散列值进行保存。<code>salt</code>其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。当两个用户使用了同一个密码时，由于随机生成的<code>salt</code>值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解</li></ul><h3 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h3><ol><li><code>AJax</code>异步更新</li><li><code>WebsScoket</code>客户端和服务端之间建立全双工的通信</li></ol><h3 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h3><ol><li>主动攻击，攻击的对象是服务器的资源，代表的有<code>SQL</code>注入攻击和<code>OS</code>命令注入</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251507169.png" alt="image-20210925150757117"></p><ol start="2"><li>被动攻击，利用圈套执行攻击代码。比如<code>Xss</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251509357.png" alt="image-20210925150903303"></p><ul><li><p>跨站脚本攻击（<code>Cross-Site Scripting，XSS</code>）是指通过存在安全漏洞的<code>Web</code>网站注册用户的浏览器内运行非法的<code>HTML</code>标签或<code>JavaScript</code>进行的一种攻击。动态创建的HTML代码可能是恶意的。</p></li><li><p><code>SQL</code>注入攻击：是指针对<code>Web</code>应用使用的数据库，通过运行非法的<code>SQL</code>而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。</p></li><li><p><code>OS</code>命令注入攻击（<code>OS Command Injection</code>）是指通过<code>Web</code>应用，执行非法的操作系统命令达到攻击的目的。只要在能调用<code>Shell</code>函数的地方就有存在被攻击的风险。</p></li><li><p>跨站点请求伪造（<code>Cross-Site Request Forgeries</code>，<code>CSRF</code>）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251535087.png" alt="image-20210925153502013"></p><ul><li>其他</li></ul><ol><li>密码破解: 顾名思义</li><li>点击劫持：点击劫持（<code>Clickjacking</code>）是指利用透明的按钮或链接做成陷阱，覆盖在 <code>Web</code>页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（<code>UIRedressing</code>）。</li><li><code>Dos</code>攻击: 就是利用大量计算机对网站发起请求，导致服务器处理不过来停止掉。多台计算机发起的<code>DoS</code>攻击就叫做<code>DDoS</code>。</li><li>后门程序： 后门程序（<code>Backdoor</code>）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中一些深入概念</title>
      <link href="/2021/09/15/js-zhong-yi-xie-shen-ru-gai-nian/"/>
      <url>/2021/09/15/js-zhong-yi-xie-shen-ru-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>原型对象(<code>Person.prototype</code>) 是通过<code>Object</code>构造函数生成的，而实例的<code>__proto__</code>指向构造函数的<code>prototype</code>。这就是为啥原型链中最后指向的是<code>Object</code>。<code>null</code>代表没有对象，也就是<code>null</code>在此处表明无原型。蓝色的线就是所谓的原型链</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109151017423.png" alt="prototype5"></p><p><em><strong>注意</strong></em></p><ul><li><code>constructor</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><p>当获取 <code>person.constructor </code>时，其实 <code>person </code>中并没有<code>constructor</code>属性,当不能读取到<code>constructor</code> 属性时，会从 <code>person</code>的原型也就是 <code>Person.prototype</code> 中读取，正好原型中有该属性，所以：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor</code></pre><ul><li><code>__proto__</code></li></ul><p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 <code>Person.prototype</code> 中，实际上，它是来自于<code> Object.prototype</code> ，与其说是一个属性，不如说是一个 <code>getter/setter</code>，当使用<code> obj.__proto__</code>时，可以理解成返回了 <code>Object.getPrototypeOf(obj)</code>。</p><ul><li>继承实质</li></ul><p>每一个对象都会从原型”继承”属性，引用《你不知道的JavaScript》中的话:</p><blockquote><p>继承意味着复制操作，然而<code>JavaScript</code>默认并不会复制对象的属性，相反，<code>JavaScript</code> 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p></blockquote><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>啥叫作用域？作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p><code>JavaScript</code>采用词法作用域，也就是静态作用域：函数的作用域在函数定义的时候就决定了。</p><p><strong>动态作用域是在函数调用的时候才决定的</strong></p><p>这个点是经常知道但是又经常搞错的地方，时刻记住函数在哪里调用并不重要，重要的函数定义在哪里。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 结果是 ??? 1</span></code></pre><p>假设<code>JavaScript</code>采用静态作用域，让我们分析下执行过程：</p><p>执行<code> foo</code> 函数，先从<code> foo</code> 函数内部查找是否有局部变量<code> value</code>，如果没有，就根据书写的位置，查找上面一层的代码，也就是 <code>value</code> 等于 1，所以结果会打印 1。</p><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>执行 <code>foo</code> 函数，依然是从 <code>foo</code> 函数内部查找是否有局部变量<code> value</code>。如果没有，就从调用函数的作用域，也就是<code> bar</code> 函数内部查找<code> value</code> 变量，所以结果会打印 2。</p><p>前面我们已经说了，<code>JavaScript</code>采用的是静态作用域，所以这个例子的结果是 1。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p><strong><code>JavaScript</code>永远都不是简单的顺序执行的</strong>。当执行一个函数的时候，就会创建一个执行上下文，并且把该执行上下文压入执行上下文栈。<code>JavaScript</code>创建一个执行上下文栈来管理所有的执行上下文。顾名思义，栈数据结构先进后出。不过，首先做的是把所有的全局变量压入栈底，当函数调用结束的时候，该全局变量依旧还在栈中。</p><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable Object,VO)</li><li>作用域链(Scope chain)</li><li><code>this</code></li></ul><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。包括全局上下文的变量对象和函数上下文的变量对象。全局上下文的变量对象没啥好说的。</p><p><strong>函数上下文变量对象</strong></p><p>执行上下文的执行过程分为两个部分</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><p>在函数上下文中，未进入执行阶段之前，变量对象(<code>VO</code>)中的属性都不能访问！但是进入执行阶段之后，变量对象(<code>VO</code>)转变为了活动对象(<code>AO</code>)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>进入执行上下文后，这时候的<code>OA</code>只包括<code>Arguments</code>对象，就是函数的参数。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>    c<span class="token operator">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">}</span></code></pre><p>执行代码的时候，会按顺序执行，根据代码，修改变量对象的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    c<span class="token operator">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token operator">:</span> reference to FunctionExpression <span class="token string">"d"</span><span class="token punctuation">}</span></code></pre><p><strong>经典例题</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// 执行代码之前，先进入执行上下文</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token keyword">var</span> foo<span class="token operator">=</span> <span class="token number">1</span><span class="token comment">// 打印函数，而不是undefined</span></code></pre><blockquote><p>因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">VO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    foo<span class="token operator">:</span> reference to <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">~</span>foo<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token comment">// 此处疑问: 此处变量声明的foo是否保存在VO中;以何种形式保存</span><span class="token punctuation">}</span></code></pre><p> 执行代码<code>console.log(foo)</code>，查找到了<code>VO</code>中的<code>foo</code>，输出结果。接着执行<code>foo=1</code>,执行后</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">VO</span><span class="token operator">=</span><span class="token punctuation">{</span>    foo<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><h2 id="参数按值传递"><a href="#参数按值传递" class="headerlink" title="参数按值传递"></a>参数按值传递</h2><blockquote><p><code>ECMAScript</code>中所有的函数的参数都是按值传递的</p></blockquote><p> 啥叫按值传递呢？</p><blockquote><p>也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另外一个变量一样</p></blockquote><p>举个简单的例子：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    v <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2}foo(value);console.log(value) // 1</span></code></pre><p>很好理解，当传递 <code>value</code>到函数<code>foo</code>中，相当于拷贝了一份 <code>value</code>，假设拷贝的这份叫 <code>_value</code>，函数中修改的都是 <code>_value</code>的值，而不会影响原来的 <code>value </code>值。</p><p>疑问：难道对象也是按值传递的吗？对象不应该是引用传递吗？通过传递一个指向该对象的指针(地址)，外部修改和函数内部修改都可以直接影响到该对象值的变化？答案是错误的，对象也是按值传递。不过这种”按值传递’’是特殊的,也是特殊的引用传递，叫做共享传递。<strong>引用传递是传递对象的引用，但是共享传递是传递对象的引用的副本</strong>，拷贝一份引用出来给参数。这样在函数里面修改该参数的属性值，并不会改变源对象里面的属性值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2}foo(obj);console.log(obj.value) // 1</span></code></pre><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p><strong>类数组不可以使用数组的方法</strong>。注意数组方法<code>splice</code>和<code>slice</code>,<code>splice</code>改变原数组，<code>slice</code>不改变原数组</p><blockquote><p>间接调用数方法</p></blockquote><pre class="language-javas" data-language="javas"><code class="language-javas">var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // ["name", "age", "sex"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item){    return item.toUpperCase();}); // ["NAME", "AGE", "SEX"]</code></pre><blockquote><p>类数组转数组</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'sex'</span><span class="token punctuation">,</span> length<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token comment">// 1. slice</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "age", "sex"] </span><span class="token comment">// 2. splice</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "age", "sex"] </span><span class="token comment">// 3. ES6 Array.from</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "age", "sex"] </span><span class="token comment">// 4. apply</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arrayLike<span class="token punctuation">)</span><span class="token comment">// 5.es6的...</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arguments</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span><span class="token punctuation">}</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>arguments</code>对象的<code>length</code>属性值的是实参的长度，而不是形参的长度。<code>callee</code>属性可以调用函数自身。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span>     data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>       <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">.</span>xxx<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>xxx <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0</span><span class="token comment">// 1</span><span class="token comment">// 2</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖</title>
      <link href="/2021/09/15/fang-dou/"/>
      <url>/2021/09/15/fang-dou/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote><p>你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行</p></blockquote><p>解决两个问题：</p><ol><li><code>this</code>的指向</li><li><code>event</code>对象</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getUserAction</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//console.log(this) //  此时的this指向的window,本来应该是&lt;div id="container"&gt;&lt;/div&gt;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// container.onmousemove = getUserAction;</span>container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>getUserAction<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>wait</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 修复this指向</span>        <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment">// 修复event对象</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments        <span class="token comment">//先清除掉之前的定时器</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>        <span class="token comment">//设置定时器，wait秒之后执行</span>        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p><strong>需求1-立刻执行</strong></p><p>不希望事件停止触发之后才执行，而是希望立刻执行函数，然后等到停止触发n秒之后，才可以重新执行。简单，只需要加一个判断，是不是立刻执行。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getUserAction</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//console.log(this) //  此时的this指向的window,本来应该是&lt;div id="container"&gt;&lt;/div&gt;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// container.onmousemove = getUserAction;</span>container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>getUserAction<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>wait<span class="token punctuation">,</span>immediate</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 修复this指向</span>        <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment">// 修复event对象</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments        <span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>immediate<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// -&gt;判断是不是立刻执行的</span>            <span class="token comment">// 如果已经执行过，不再执行</span>            <span class="token keyword">var</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timeout            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment">//设置定时器，wait秒之后执行</span>        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span>        <span class="token punctuation">}</span>       <span class="token comment">// + return result // 111</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment">/**如果getUserAction有返回值的话，当immediate为false的时候，因为使用了定时器又不是立刻执行，我们需要将func.apply(that,args)的返回值赋给变量，最后return的时候，值是undefined，所以我们只在immediate为true的时候返回函数的结果           - var timeout           + var timeout,result           - if(callNow) func.apply(that,args)           + if(callNow)  result = func.apply(that,args)           + return result // 111*/</span></code></pre><p><strong>需求2-取消防抖</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout<span class="token punctuation">,</span> result<span class="token punctuation">;</span>    <span class="token keyword">var</span> <span class="token function-variable function">debounced</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果已经执行过，不再执行</span>            <span class="token keyword">var</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timeout<span class="token punctuation">;</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    debounced<span class="token punctuation">.</span><span class="token function-variable function">cancel</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> debounced<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call/apply/bind/new模拟实现</title>
      <link href="/2021/09/15/call-apply-bind-new-mo-ni-shi-xian/"/>
      <url>/2021/09/15/call-apply-bind-new-mo-ni-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="call的模拟实现"><a href="#call的模拟实现" class="headerlink" title="call的模拟实现"></a>call的模拟实现</h2><p><strong>模拟思路</strong></p><ol><li><code>call</code>改变了<code>this</code>的指向，指向到<code>foo</code></li><li><code>bar</code>函数执行了</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p>上面可以用类似逻辑实现</p><ol><li>将函数设置为对象的属性</li><li>执行该函数</li><li>删除该属性(函数)</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 首先要获取调用call的函数，用this可以获取，就是foo函数</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 测试一下</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p><strong>最终版本</strong></p><p>加了三个东西：</p><ul><li>参数</li><li><code>this</code>参数可以传<code>null</code>, 此时指向的是<code>window</code></li><li>函数可以有返回值的</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> context <span class="token operator">||</span> window    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arguments['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//console.log(arguments[1]) // kevin </span>    <span class="token comment">//将数组的多个元素作为参数放进函数的参数里面</span>    <span class="token comment">//eval 会把里面的字符串解析成JavaScript代码进行执行</span>    <span class="token comment">//相当于 eval('context.fn(arguments[1],arguments[2])')  ===&gt; 解析成                  //context.fn(arguments[1],arguments[2])</span>    <span class="token comment">//args 是数组，下面这个语句会自动调用 toString的方法</span>    <span class="token comment">//console.log(args.toString()) // 'arguments[1],arguments[2]'</span>    <span class="token keyword">var</span> result <span class="token operator">=</span>   <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'context.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//console.log(result) // { value: 1, name: 'kevin', age: 18 } 返回值</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token comment">// 测试一下</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        value<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>        name<span class="token operator">:</span>name<span class="token punctuation">,</span>        age<span class="token operator">:</span>age    <span class="token punctuation">}</span><span class="token punctuation">}</span>bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span><span class="token comment">// 18</span><span class="token comment">// 1</span></code></pre><h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p><code>apply</code>和<code>call</code>作用完全一样的，只不过传参数不同。<code>apply </code>方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<code>call </code>方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">apply2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">||</span> window<span class="token punctuation">;</span>   <span class="token comment">// console.log(context) // {value:1} Object(context)-&gt;数组转成对象</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> result<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arr['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'context.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// console.log(result) // { value: 1, name: 'k', age: 'e' } 返回值</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 测试一下</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        value<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>        name<span class="token operator">:</span>name<span class="token punctuation">,</span>        age<span class="token operator">:</span>age    <span class="token punctuation">}</span><span class="token punctuation">}</span>bar<span class="token punctuation">.</span><span class="token function">apply2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span><span class="token comment">// 18</span><span class="token comment">// 1</span></code></pre><h2 id="bind的模拟实现"><a href="#bind的模拟实现" class="headerlink" title="bind的模拟实现"></a>bind的模拟实现</h2><ul><li>返回一个函数</li><li>可以传入参数，<code>bind</code>绑定的时候可以传，返回的函数在<code>bind</code>绑定参数的后面接着传</li><li>当<code>bind</code>返回的函数是构造函数的时候，<code>bind</code>指定的<code>this</code>就会无效，但是传入的参数依旧有效</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Function.prototype.bind - what is trying to be bound is not callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment">//  绑定bind的时候，传进去的参数</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// console.log(args) // [ 'daisy', 'man' ]</span>    <span class="token keyword">var</span> fNOP <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 中转 ，避免直接修改绑定函数的prototype</span>    <span class="token keyword">var</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 这个时候的arguments是执行函数的时候传进去的参数</span>        <span class="token comment">// console.log(bindArgs) // [ '18' ]</span>        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span>        <span class="token comment">// 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span>        <span class="token comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span>        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span>    <span class="token comment">// 原：fBound.prototype = self.prototype;</span>    <span class="token comment">// 现</span>    fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> self<span class="token punctuation">.</span>prototype    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span>sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// console.log(this.value);</span>    <span class="token comment">// console.log(name);</span>    <span class="token comment">// console.log(age);</span><span class="token punctuation">}</span><span class="token keyword">var</span> bindFoo <span class="token operator">=</span> bar<span class="token punctuation">.</span><span class="token function">bind2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'daisy'</span><span class="token punctuation">,</span><span class="token string">'man'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1</span><span class="token comment">// daisy</span><span class="token comment">// 18</span></code></pre><h2 id="new模拟实现"><a href="#new模拟实现" class="headerlink" title="new模拟实现"></a>new模拟实现</h2><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Otaku</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>habit <span class="token operator">=</span> <span class="token string">'Games'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">'something'</span><span class="token punctuation">}</span><span class="token class-name">Otaku</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>strength <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span><span class="token class-name">Otaku</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayYourName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// shift 返回删除的数组第一个元素 也就是构造函数</span>    <span class="token comment">// console.log(arguments) // { '0': 'Kevin', '1': '18' }shift会修改原数组、</span>    <span class="token comment">// 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</span>    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>    <span class="token comment">// 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</span>    <span class="token comment">// Constructor.apply(obj, arguments);</span>    <span class="token comment">// return obj;</span>    <span class="token comment">// +  构造函数有返回值的时候。判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么</span>    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">Constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>    <span class="token comment">// console.log(obj) // Otaku { name: 'Kevin', age: '18', habit: 'Games' }</span>    <span class="token keyword">return</span> <span class="token keyword">typeof</span> ret <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> ret <span class="token operator">:</span> obj<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span>Otaku<span class="token punctuation">,</span> <span class="token string">'Kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// Kevin</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>habit<span class="token punctuation">)</span> <span class="token comment">// Games</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>strength<span class="token punctuation">)</span> <span class="token comment">// 60</span>person<span class="token punctuation">.</span><span class="token function">sayYourName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// I am Kevin</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2021/09/02/she-ji-mo-shi-zhi-dan-li-mo-shi/"/>
      <url>/2021/09/02/she-ji-mo-shi-zhi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>单例就是保证一个类只有一个实例,实例的方法一般先判断实例是否存在,如果存在直接返回出来,如果不存在就先创建了再返回出来。这就可以保证一个类只有一个实例。在JS中,单例是一个命名空间的提供者,从命名空间里提供唯一的访问点来访问该对象。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>单例一般用在系统间各种模式的通信协调上,下面代码是单例的实践</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> Single <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 参数:传递给单例一个参数集合</span>    <span class="token keyword">function</span> <span class="token function">Signleton</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> args <span class="token operator">=</span> args <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Signle'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointX <span class="token operator">=</span> args<span class="token punctuation">.</span>pointX <span class="token operator">||</span> <span class="token number">6</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointY <span class="token operator">=</span> args<span class="token punctuation">.</span>pointY <span class="token operator">||</span> <span class="token number">10</span>    <span class="token punctuation">}</span>   <span class="token keyword">let</span> instance <span class="token comment">// 实例容器</span>   <span class="token keyword">let</span> _static <span class="token operator">=</span> <span class="token punctuation">{</span>       name<span class="token operator">:</span><span class="token string">'Signle'</span><span class="token punctuation">,</span>       <span class="token comment">// 获取实例的方法</span>       <span class="token comment">// 返回Signleton实例</span>       <span class="token function-variable function">getInstance</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token function">Signleton</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token comment">// 没有就创建一个</span>           <span class="token punctuation">}</span>           <span class="token keyword">return</span> instance <span class="token comment">// 有就直接return出来拿到</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> _static <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> s <span class="token operator">=</span> Single<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">{</span>pointX<span class="token operator">:</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>pointX<span class="token punctuation">)</span> <span class="token comment">// 7</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的异步编程</title>
      <link href="/2021/09/02/js-de-yi-bu-bian-cheng/"/>
      <url>/2021/09/02/js-de-yi-bu-bian-cheng/</url>
      
        <content type="html"><![CDATA[<p>异步是啥？程序的不连续执行就是异步,一个任务分几个部分,几个时间段完成</p><p>同步就是程序连续执行,1没执行完2就只能等着</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><blockquote><p><code>JS</code>对异步编程的实现,就是回调函数。把异步任务的第二段单独写在一个函数里面,等异步任务的第一段执行完毕的时候,就调用这个函数啊</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'etc/passwd'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上述代码中,<code>readFile</code>函数的第二个参数,就是回调函数,也就是任务的第二段,等到操作系统返回<code>/etc/passwd</code>这个文件之后,回调函数才会执行。</p><p>回调函数的第一个参数是<code>err</code>(如果没有错误,该参数就是<code>null</code>)?原因是执行分为两段,在这两段之间抛出的错误,程序无法捕捉,只能当成参数,传入第二段.</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身没问题,问题在于多个回调函数的嵌套。假定读取A文件之后,再读取B文件 。造成回调噩梦<code>callback hell</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileA<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err  <span class="token comment">// 捕获读取A失败的错误</span>    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileB<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err <span class="token comment">// 捕获读取B失败的错误  捕获读取A失败的错误其实可以不写,放在B这里捕获</span>        <span class="token comment">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>不是一种新的语法,而是一种新的回调函数的写法,解决了<code>callback hell</code>的问题。<code>then</code>方法加载回调函数,<code>catch</code>方法捕获执行第一段和第二段之间的错误</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> readFile <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs-readfile-promise'</span><span class="token punctuation">)</span><span class="token comment">//返回一个Promise版本的readFile函数</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//加载完fileA文件之后,再去执行then里面的回调函数</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileB<span class="token punctuation">)</span> <span class="token comment">// A读取完毕,开始加载B</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//加载完fileB文件之后,再去执行then里面的回调函数</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">throw</span> err <span class="token comment">// 捕获整个加载过程之中抛出的错误</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>的缺点就是代码冗余,一堆的<code>then</code>,语义不清晰</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p><code>Generator</code>函数是协程在<code>ES6</code>中的实现,最大的特点就是可以交出函数的执行权(即暂停执行)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Genertor可以进行函数体内外部的数据交换和部署错误处理代码</span><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span> <span class="token comment">// yield 就是暂停</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">}</span><span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 返回第一个yield的结果 {value:3,done:false}</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// {value:undefined,done:true} g.next(2)=&gt; {value:2,done:true}</span>g<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span> <span class="token comment">// 可以被里面的try...catch代码块捕获</span></code></pre><p>实际例子</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> fetch <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node-fetch'</span><span class="token punctuation">)</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token string">"https://github.com/users/github"</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment">// 执行代码</span><span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> res <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//得到{value:result(Promise),done:false}</span><span class="token comment">// fetch返回的是一个Promise对象,所以用then方法来调用下一个next,then方法等fetch返回完毕后才执行,里面是任务的第二段.拿到result返回结果,再return结果出来</span>res<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Generator</code>的缺点：流程管理不方便(何时执行第一阶段、何时执行第二阶段) <strong>基本不用它</strong></p><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3><p><code>async/await</code>是Generator的语法糖,<code>*</code>换成了<code>async</code>,<code>yield</code>换成了<code>await</code>。<code>async </code>函数是<code>ES7</code>的语法功能,不过可以在开发中正常使用,因为<code>Babel</code>已经支持,经转码之后就可以使用。</p><ul><li>指定50毫秒之后,输出“hi”</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>ms<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">timeout</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span></code></pre><ul><li><code>await</code>后面的<code>Promise</code>对象,运行的结果可能是<code>rejected</code>,所以最好把<code>awai</code>t命令放在<code>try...catch</code>代码块之中</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">await</span> <span class="token function">somethingReturnPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//另一种写法</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">somethingReturnPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><ul><li><code>forEach</code>方法的参数改成<code>async</code>函数,也会有问题,原因是三个<code>db.post</code>操作是并发执行,也就是同时执行,而不是继发执行</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFunc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token comment">// 可能得到错误的结果</span>    docs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 正确的做法是使用for循环</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> doc <span class="token keyword">of</span> docs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>如果希望多个请求并发执行,可以使用<code>Promise.all</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFunc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 或者使用下面</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFunc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> Promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        doc<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> promise <span class="token keyword">of</span> promises<span class="token punctuation">)</span><span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">await</span> promise<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试功能页</title>
      <link href="/2021/08/31/ce-shi-gong-neng-ye/"/>
      <url>/2021/08/31/ce-shi-gong-neng-ye/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="38f3f22ee21db3680ba53f48b6e1b240efd52229d75f4c99c5bcab51b59f7669">bd25ed9264b080267271e137e33d0ce1874c72b7e3d7ffc49271f9d090e14bb8e7eeef201904066dc5fec581483b6f5b230759b47f327056f2c6087fb4372224ff41dd6a14a51a6f9c19a545b59bb412952ce03ecc8be9d6c47f8d0ee5714a97ce39d1a3050947b9f06c60dbb003869079b26abe7da67db1da28532cb1d35841be69ec6ddfe28bdcab1b34104726ee29f7d23b13cab0b9c924973d25e49b211cf467d4bdf99881bce00692fa10a01be08aff185b49104633183b9060185aafc7ac146a6e5fd2ae7c7b4a277a599d853ccb3bee614272cf7e81bbaff8829d5b77bdbec1568eefe7a02bfd3ef2533380d0bd2993ada136b49b7b8582773bb3fe7f8e98f20c7fe67ba1d5611ecc2d6bc19b1ba1d87e7b1cccbb0f3450f37ae298ca84037710c4a2daea768f8c60d5e6588d4de4e079b5369d91c9fd5d9423bf5588c1d4279ac486baaeeee09567b8c018b7ca43bafe735adeb76b9b798c3aaa86066540f0b64e42bb1bd42f8365f293011b085ce74b79cf1b23bbc66dda6ebf3d9a19f7216da231095cfd3cd45945daa958f9960c994542c51b2975852b5f5a9058e13acfb0a4635a9de1c6aefc05e1ce9c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">测试加密，这里的密码是：test</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github配置cdn注意事项</title>
      <link href="/2021/08/31/github-pei-zhi-cdn-zhu-yi-shi-xiang/"/>
      <url>/2021/08/31/github-pei-zhi-cdn-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="Github-CDN-Jsdelivr"><a href="#Github-CDN-Jsdelivr" class="headerlink" title="Github+CDN+Jsdelivr"></a>Github+CDN+Jsdelivr</h3><p><code>github</code>上新建个仓库存放这些需要<code>cdn</code>加速的资源。在<code>Releases</code>中创建<code>cdn</code>加速。图中<code>Choose a tag</code> 就是版本号,通过链接<code>https://cdn.jsdelivr.net/gh/JingWZeng/blog-CDN@1.0/img/</code>访问<code>cdn</code>加速的文件夹,<code>https://cdn.jsdelivr.net/gh/JingWZeng/blog-CDN@1.0/img/[文件名]</code>访问具体的文件。<br><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202108310924643.png"><br><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202108310920130.png"></p><p><code>picGo</code>如果需要利用<code>cdn</code>加速的话，只需要把默认地址设置成<code>https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg</code>。<code>markdownImg</code>是我的仓库名<br><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202108310931535.png"></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可编辑的div</title>
      <link href="/2021/08/27/ke-bian-ji-de-div/"/>
      <url>/2021/08/27/ke-bian-ji-de-div/</url>
      
        <content type="html"><![CDATA[<p>如果利用<code>textarea</code>的输入框，只能输入文本，无法输入图片等。比较好的方法是利用可编辑的<code>div</code>进行实现。</p><h3 id="div的可编辑"><a href="#div的可编辑" class="headerlink" title="div的可编辑"></a>div的可编辑</h3><p><code>div</code>要完成可编辑，只需要设置<code>contenteditable = "true"</code>即可实现。我们可以监听用户输入的区域,用户输入的时候，获取其中的<code>innerText</code>，之后进行字数的限制判断，重新设置其<code>innerHtML</code>，超出的字数显示成其他颜色。在提交之前，对表单进行预验证，要求用户删除多余的字符，方可提交给后端。</p><p><span class="github-emoji"><span>🍡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f361.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>可编辑的<code>div</code>的难点在于光标难于控制，因此设置<code>html</code>的时候利用两层<code>div</code>重叠的方式进行解决</p><ul><li>上层的<code>div</code>用于文本的输入,背景颜色透明</li><li>下层的<code>div</code>节点用于高亮超出的部分文字，文字颜色设置为透明，超出的部分设置背景颜色进行高亮</li></ul><p><span class="github-emoji"><span>🌭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f32d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>bug1:<code>div</code>的高度自适应</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box"</span> contenteditable<span class="token operator">=</span><span class="token string">"true"</span> ref<span class="token operator">=</span><span class="token string">"box"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"hightLight"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">.</span>box<span class="token punctuation">{</span>    width<span class="token operator">:</span><span class="token number">400</span>px<span class="token punctuation">;</span>    min<span class="token operator">-</span>height<span class="token operator">:</span><span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token comment">//实现自适应</span>    max<span class="token operator">-</span>height<span class="token operator">:</span><span class="token number">400</span>px<span class="token punctuation">;</span>    margin<span class="token operator">-</span>left<span class="token operator">:</span>auto<span class="token punctuation">;</span>    margin<span class="token operator">-</span>right<span class="token operator">:</span>auto<span class="token punctuation">;</span>    padding<span class="token operator">:</span><span class="token number">3</span>px<span class="token punctuation">;</span>    outline<span class="token operator">:</span>none<span class="token punctuation">;</span> <span class="token comment">// div在获取焦点的时候有虚框,让它消失</span>    border<span class="token operator">:</span><span class="token number">1</span>px solid #dedede<span class="token punctuation">;</span>    word<span class="token operator">-</span>wrap<span class="token operator">:</span><span class="token keyword">break</span><span class="token operator">-</span>word<span class="token punctuation">;</span>    overflow<span class="token operator">-</span>x<span class="token operator">:</span>hidden<span class="token punctuation">;</span>    overflow<span class="token operator">-</span>y<span class="token operator">:</span>auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><span class="github-emoji"><span>🌮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f32e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug2:输入框的<code>placeholder</code></strong></p><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">.box:empty::before</span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token function">attr</span><span class="token punctuation">(</span>placehoder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>#dedede<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>之后就可以在<code>html</code>中使用<code>placeholder</code>属性。但是存在一些问题(点击回车的时候,会插入<code>&lt;div&gt;&lt;/div&gt;</code>或者<code>&lt;br&gt;</code>，这会导致一些问题，甚至影响到统计的字数)<br>解决办法:<br><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 通过<code>JS</code>手动的添加、移除<code>class</code>类处理<code>placeholder</code>的显示与隐藏</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>box<span class="token punctuation">.</span>is<span class="token operator">-</span>show<span class="token operator">-</span>ploacehoder<span class="token operator">:</span><span class="token operator">:</span>before<span class="token punctuation">{</span>    content<span class="token operator">:</span><span class="token function">attr</span><span class="token punctuation">(</span>placehoder<span class="token punctuation">)</span><span class="token punctuation">;</span>    color<span class="token operator">:</span>#dedede<span class="token punctuation">;</span>    position<span class="token operator">:</span>absolute<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// JS</span><span class="token keyword">let</span> box <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>refs<span class="token punctuation">.</span>box box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>box<span class="token punctuation">.</span>innerHTML <span class="token operator">===</span> <span class="token string">'&lt;div&gt;&lt;br&gt;&lt;/div&gt;'</span> <span class="token operator">||</span>    box<span class="token punctuation">.</span>innerHTML <span class="token operator">===</span> <span class="token string">'&lt;br&gt;'</span> <span class="token operator">||</span>    box<span class="token punctuation">.</span>innerHTML <span class="token operator">===</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'is-showPlaceholder'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'is-showPlaceholder'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 第一层<code>div</code>使用<code>textarea</code>替换，<code>textarea</code>中有<code>placeholder</code>属性</p><p><span class="github-emoji"><span>🍅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f345.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug3:输入中文的统计字数</strong><br>在中文输入的时候,中文还没有输入到输入框中的时候，字数已经在开始统计了，合理的是中文输入<code>composing</code>组合的过程中不应该计算字数，在<code>composed</code>组合完成输入到输入框中的时候再计算。<br><code>composing</code>:在中文输入中，组合开始<br><code>compsied</code>:在中文输入中，组合完成</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> isComposing <span class="token operator">=</span> <span class="token boolean">false</span>editorArea<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'compositionstart'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  isComposing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span>editorArea<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'compositionend'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  isComposing <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token comment">// 字数统计</span>  <span class="token keyword">let</span> text <span class="token operator">=</span> box<span class="token punctuation">.</span>innerText  <span class="token comment">// 判断字数是否超出限制</span>  <span class="token function">setCounter</span><span class="token punctuation">(</span>limitCnt <span class="token operator">-</span> text<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><span class="github-emoji"><span>🍌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug4:文件选择器于前端预览图片</strong><br>古老的时候是无法直接在前端预览图片的，那时候借助的是ajax预先把图片发送给服务端，服务端返回图片的地址，前端利用img标签进行显示。不论用户需不需要上传该图片，该图片等会被上传到服务器中。<br>现在的做法:</p><ul><li><code>fileReader</code>—&gt;我不用</li><li> <code>URL.creatObjectURL</code> <span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><code>URL.creatObjectURL()</code>方法会创建一份DOMString对象，它包含url，这个url的生命周期跟创建它的窗口绑定，并且这个url就是操作的对象的映射地址（临时地址）<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"file"</span> accept<span class="token operator">=</span><span class="token string">"image/*"</span> ref <span class="token operator">=</span> <span class="token string">'imgFiles'</span> @change<span class="token operator">=</span><span class="token string">"handleChange"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>img <span class="token operator">:</span>src<span class="token operator">=</span><span class="token string">"srcImg"</span><span class="token operator">&gt;</span><span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> fileObj <span class="token operator">=</span> event<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">//对于type="file" input.files[0]得到当前选中的file对象</span>    <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>srcImg <span class="token operator">=</span> file <span class="token operator">?</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>fileObj<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">}</span></code></pre><span class="github-emoji"><span>🍎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug5:拖动于前端预览图片</strong><br>拖动是利用<code>html5</code>中的<code>drop</code>、<code>drogover</code>、<code>drogleave</code>方法<br>drogover:移进到了敏感区域，一直调用<br>注意:<span class="github-emoji"><span>🔊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>需要阻止它们的默认方法,负责网页会自动打开该图片</li><li><code>DataTransfer</code>对象出现在拖拽事件中，具体包括开始拖拽<code>dragstart</code>事件，拖拽进入<code>dragenter</code>事件，拖拽离开<code>dragleave</code>事件，拖拽经过<code>dragover</code>事件，拖拽释放<code>drop</code>事件以及拖拽结束<code>dragend</code>事件。</li><li><code>DataTransfer.items </code>（只读）<br>提供<code>DataTransferItemList</code>对象，该对象是所有拖动数据的列表。<pre class="language-javascript" data-language="javascript"><code class="language-javascript">@drogover <span class="token operator">=</span> <span class="token string">"handleDrogover"</span>@drop<span class="token operator">=</span> <span class="token string">"handleDrop"</span><span class="token function">handleDrogover</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">handleDrop</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> dt <span class="token operator">=</span> e<span class="token punctuation">.</span>dataTransfer    <span class="token keyword">const</span> oFile <span class="token operator">=</span> dt<span class="token punctuation">.</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 文件对象</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">image</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>oFile<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 判断是否为图片对象</span>    <span class="token keyword">const</span> blod <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blod</span><span class="token punctuation">(</span><span class="token punctuation">[</span>oFile <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">// 生成Blod对象</span>    <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> imgSrc <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blod<span class="token punctuation">)</span><span class="token comment">//URL.createObjectURL()可以处理File对象、Blod对象</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc    img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        box<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><span class="github-emoji"><span>🍇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f347.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug6:<code>formData</code>传输多个文件</strong><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>fileObj<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'file[]'</span><span class="token punctuation">,</span>fileObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 不可以直接console.log(formData)----&gt;需要利用formData.get([key])</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 可编辑的div </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 可编辑的div </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly的Tag-Plugins</title>
      <link href="/2021/08/26/butterfly-de-tag-plugins/"/>
      <url>/2021/08/26/butterfly-de-tag-plugins/</url>
      
        <content type="html"><![CDATA[<pre class="language-butterFly-Tag" data-language="butterFly-Tag"><code class="language-butterFly-Tag">{% note red 'fas fa-fan' flat%}这是三片呢？还是四片？{% endnote %}</code></pre><div class="note icon flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>更多信息见:<a href="https://butterfly.js.org/posts/c9711c19/">butterfly官网标签外挂</a></p>]]></content>
      
      
      <categories>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2文档总结</title>
      <link href="/2021/08/25/vue-wen-dang-zong-jie/"/>
      <url>/2021/08/25/vue-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<ol><li><code>data</code>对象所有的属性被加入到Vue的响应式系统(被创建的时候就已经存在才是,临时加入的不是)<br>一开始的声明其实就是让他在创建的时候就存在。如果用如果用<code>Objectfreeze(obj)</code>,阻止<code>obj</code>修改自己的属性,所以响应式系统就不能追踪他的变化</li><li><code>v-once</code>只执行一次插值,当数据改变的时候,插值的内容不会再更新</li><li><code>v-html</code>可以把<code>html</code>代码执行出来,用户提供的信息不要这样用,<code>Xss</code>攻击,只对可信的东西用就好。<code>Xss</code>攻击可以利用<code>Xss</code>库进行配置</li><li>用在<code>html</code>属性上面不可以用<code>{{}}`,需要用`v-bind`的。其实如果`v-bind`的属性是`false`\ `null` \ `undefined`的话,渲染出来的该`html`元素不会含有该属性的。`{{}}</code>和<code>v-bind</code>中都可以放<code>JavaScript</code>表达式,<code>v-bind</code>的属性名会被强制转换成小写,</li><li><code>v-bind</code> 和 <code>v-on</code>的缩写<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">:</span>herf <span class="token operator">=</span> <span class="token string">"ur1"</span><span class="token comment">//动态参對的缩写</span><span class="token operator">:</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"url"</span>@click <span class="token operator">=</span> <span class="token string">"dosomething"</span>@<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"dosomething"</span></code></pre></li><li>计算属性的使用和普通属性一样绑定在<code>html</code>元素上面</li><li>插值可以调用<code>methods</code>里面的方法</li><li>计算属性有缓存,看的是它所对应的依赖是否改变,如果改变才会重新求值,如果没有变化,则不会。<code>methods</code>的话是每次调用都会执行的<pre class="language-javascript" data-language="javascript"><code class="language-javascript">computed<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function-variable function">now</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//该属性now不会再更新,因为Date.now ()不是响应式依</span>        <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>当一些数据需要随着其他数据变动而变动的时候,你特别容易滥用<code>watch</code>,其实用<code>computed</code>会更好一点,<code>computed</code>可以监听到<code>data</code>里面的响应式数据(做为计算属性的依赖之后)</li><li>计算属性默认是只有<code>getter</code>,有需要的时候需要自己提供<code>setter</code>方法来做,就是更改属性的时候调用,做一下事情</li><li><code>watch</code>:当数据变化的时候执行异步或者开销比较大的操作的时候</li><li><code>class</code>和<code>style</code>动态的切换<code>class</code>,<code>class</code>和<code>:class</code>是可以共存在个html元素上面的<pre class="language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span>class = <span class="token property">obj或者</span><span class="token punctuation">:</span>class=[]<span class="token comment">/*这个obj/[]当然可以定义computer的返回值或者data里面调用子组件时候使用:class会传入到子组件的class*/</span></code></pre></li><li><code>Vue</code>渲染的时候会复用些相同<code>html</code>标签,有些需求是不可以被复用的,此时可以给该标签或者组件添加<code>key</code>属性,确定唯一性。</li><li><code>v-show</code>渲染的元素是始终存在<code>dom</code>中的,只是控制<code>display</code>的属性切换,<code>v-lf</code>会重复创建和销毁的,<code>v-show</code>不可以用在<code>template</code>中,也不可以<code>v-else</code>搭配使用</li><li><code>v-for="(1,2)"</code>参数1是item,参数2是index.他们两个的位置不可以被改变<br>遍历的是数组的时候<pre class="language-javascript" data-language="javascript"><code class="language-javascript">v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item of itens"</span>和v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item of items"</span>效果是一样的</code></pre></li><li><code>v-for</code>被遍历的是对象的时候,<code>v-for="(value,key,index)"</code>第个参数是值,第二个键名,第三个是索引</li><li>嵌套的<code>v-for</code>中不要使用<code>computed</code>方法</li><li>访问原生的JS事件对象的时候,可以使用特殊变量<code>$event</code>作为参数传到方法中</li><li>事件修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//阻止事件继续传播</span>@click<span class="token punctuation">.</span>stop<span class="token comment">//提交事件不再加载页面</span>@submit<span class="token punctuation">.</span>prevent<span class="token comment">//捕获-&gt;目标-&gt;冒泡 内部触发的事件先在外部处理,之后才去内部元素处理</span>@click<span class="token punctuation">.</span>capture<span class="token comment">//事件自身才会触发</span>@click<span class="token punctuation">.</span>self<span class="token comment">//阻止所有的点击</span>@click<span class="token punctuation">.</span>prevent<span class="token punctuation">.</span>self<span class="token comment">//阻止自身的点击</span>@click<span class="token punctuation">.</span>self<span class="token punctuation">.</span>prevent<span class="token comment">//点击事件只会触发一次</span>@click<span class="token punctuation">.</span>once<span class="token comment">//不想阻止事件的默认行为,比如滚动事件的滚动行为</span>@<span class="token operator">:</span>scroll<span class="token punctuation">.</span>passive <span class="token comment">//---&gt;不阻止默认事件的发生</span></code></pre></li><li>按键修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//arrowUp/pageDown等</span>@keyup<span class="token punctuation">.</span>enter <span class="token comment">//keyCode</span>@keyup<span class="token punctuation">.</span><span class="token number">13</span><span class="token comment">//全局定义按键修饰符的名字</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>keyCodes<span class="token punctuation">.</span>f1 <span class="token operator">=</span> <span class="token number">112</span> <span class="token comment">//@keyup.f1</span><span class="token comment">//兼容老的浏览器,为键盘起的小名</span><span class="token punctuation">.</span>enter<span class="token operator">/</span><span class="token punctuation">.</span>tab<span class="token operator">/</span><span class="token punctuation">.</span>delete<span class="token operator">&lt;</span>删除事件<span class="token operator">/</span>退格键<span class="token operator">&gt;</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.esc</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span>space<span class="token operator">/</span><span class="token punctuation">.</span>up<span class="token operator">/</span><span class="token punctuation">.</span>down<span class="token operator">/</span><span class="token punctuation">.</span>left<span class="token operator">/</span><span class="token punctuation">.</span>right</code></pre></li><li>系统修饰符:按下响应的键才可以触发鼠标或者其他按键的事件<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>ctrl  <span class="token punctuation">.</span>alt  <span class="token punctuation">.</span>shift <span class="token punctuation">.</span>meta<span class="token operator">&lt;</span>windows图标键<span class="token operator">&gt;</span><span class="token comment">// Alt + C</span>@keyup<span class="token punctuation">.</span>alt<span class="token punctuation">.</span><span class="token number">67</span><span class="token comment">//Ctrl + click</span>@keyup<span class="token punctuation">.</span>click<span class="token punctuation">.</span>ctrl<span class="token comment">//exact精确控制系统修饰符的组合触发的事件</span><span class="token comment">//即使alt、shift被按下,也可以触发,因为按下ctrl+click就可以满足条件</span>@click<span class="token punctuation">.</span>ctrl<span class="token comment">//有且仅有ctrl被按下才会触发</span>@click<span class="token punctuation">.</span>ctrl<span class="token punctuation">.</span>exact<span class="token comment">//没有任何系统修饰符按下才会触发</span>@click<span class="token punctuation">.</span>exact</code></pre></li><li>鼠标修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">.</span>middle</code></pre></li><li><code>v-model</code>修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>lazy <span class="token comment">// 只有change事件发生的时候,才会同步数据</span><span class="token punctuation">.</span>number<span class="token comment">//自动将输入的值转number-&gt;parseFloat解析,无法解析的话,返回原始值</span><span class="token punctuation">.</span>trim<span class="token comment">//自动过滤输入的首尾空白字符</span></code></pre></li><li><code>$emit([事件名],args)</code>在父组件中可以通过<code>$event</code>来得到这个<code>args</code>的值</li><li>动态组件用<code>is</code>这个属性</li><li>组件的名字全部小写而且用<code>-</code>字符连接。在非模板字符串中,也就是不在<code>template</code>中,无法使用<code>&lt;myComponent/&gt;</code>,只能写成<code>&lt;my-component/&gt;</code></li><li><code>props['myData']</code>,<code>props</code>中命名是驼峰,<code>html</code>会把它们全部转成<code>kebab-case</code>。比如<code>my-data</code></li><li>事件名用<code>kebab-case</code>,因为<code>html</code>会全部转成小写</li><li><code>props</code>是单向数据流,父亲的数据会更新到儿子那边,所以是响应式的。儿子那边不能修改来自父亲的值,因为父亲更新会改变该值。解决办法:深拷贝一份数据,用来做其他的事情-&gt;分两种情况:</li></ol><ul><li>如果是想把<code>props</code>的值做为子组件本地的数据使用,可以在<code>data</code>里面定义一个变量,把<code>props</code>属性值给该变量</li><li>如果是希望把<code>props</code>里面的值做一个基础的原始值,在子组件中显示的话,可以防止<code>computed</code>中做处理</li></ul><ol start="30"><li><code>props</code>做自定义验证<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1.</span> props<span class="token operator">:</span><span class="token punctuation">{</span>    foo<span class="token operator">:</span><span class="token punctuation">{</span>        <span class="token function-variable function">validator</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'success'</span><span class="token punctuation">,</span><span class="token string">'warining'</span><span class="token punctuation">,</span><span class="token string">'danger'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indxOf</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">2.</span>props<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token comment">//判断是不是Perosn的实例</span>    author<span class="token operator">:</span>Person<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">firstname<span class="token punctuation">,</span>lastname</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstname <span class="token operator">=</span> firstname    <span class="token keyword">this</span><span class="token punctuation">.</span>lastname <span class="token operator">=</span> lastname<span class="token punctuation">}</span></code></pre></li><li><code>$attrs</code>与 <code>$listens</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在子组件中使用</span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token comment">//在2中用</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">:$attrs</span><span class="token template-punctuation string">`</span></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">@listens</span><span class="token template-punctuation string">`</span></span> <span class="token operator">-</span><span class="token operator">&gt;</span>接受<span class="token number">1</span>中没有进入<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">props</span><span class="token template-punctuation string">`</span></span>里面的其他属性和<span class="token number">1</span>的全部方法<span class="token comment">//在3中用</span>接受<span class="token number">1</span>和<span class="token number">2</span>中没有进入 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">props</span><span class="token template-punctuation string">`</span></span>里面的其他属性和<span class="token number">1</span>和<span class="token number">2</span>的全部方法</code></pre></li><li>组件的<code>.sync</code>修饰符就是让子组件做改变的时候同步到父组件中,和<code>props</code>传值<code>/$emit</code>中效果一样。组件中使用<code>v-model</code>也可以实现<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"something"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>input <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"something"</span> @input<span class="token operator">=</span><span class="token string">"something=$event.target.value"</span><span class="token operator">&gt;</span><span class="token comment">//在组件中使用v-model</span><span class="token punctuation">{</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token punctuation">}</span>测试用的<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//初始的title = '1111'</span><span class="token operator">&lt;</span>Child v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">/</span><span class="token operator">&gt;</span>Vue<span class="token punctuation">.</span><span class="token function">Component</span><span class="token punctuation">(</span><span class="token string">'Child'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    template<span class="token operator">:</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;    {{value}}   ------------&gt;用来测试(2),现在显示'1111'    &lt;button @click="change()"&gt;按钮&lt;/button&gt;    &lt;/div&gt;,    props:['value'],     methods:{        change(){            this.$emit('input','22222') --------------&gt; 一定要触发input事件,点击之后测试(1)/(2)变成'22222'        }    }    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><code>keep-alive</code>可以用来保存切换之后页面的存在状态</li><li><code>filters</code>中用着<code>{{}}/v-bind</code>中,用|隔开,<code>原始值|过滤方法A|过滤方法B</code>,<code>A</code>得到的结果到<code>B</code>。或者<code>value|A(arg1,arg2)</code></li><li>对象和数组,<code>Vue</code>无法检测它们的变化,解决办法:<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1.</span> 对于对象<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">set</span>向嵌套对象添加响应式的数据<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span><span class="token punctuation">[</span>属性名<span class="token punctuation">]</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment">//如果是添加多个属性,需要让原对象与要混合的进去的属性组合成一个新的对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObj<span class="token punctuation">,</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token number">2.</span> 对于数组<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>实现vm<span class="token punctuation">.</span>items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span> newVal的效果<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>这种不是响应式的<span class="token punctuation">,</span>下面的才是<span class="token comment">//set</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span>index<span class="token punctuation">,</span>newVal<span class="token punctuation">)</span><span class="token comment">//splice</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>newVal<span class="token punctuation">)</span></code></pre></li><li><code>$parent</code>可以访问父亲的<code>data</code>属性,但最好不要这样做。<code>ref</code>给我一个组件的<code>id</code>,通过<code>this.$refs.[id]</code>来访问,refs不是响应式的,所以不应该在模板中或者<code>computed</code>使用</li><li><code>nextTick()</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//tick的意思是一次事件循环-&gt;保证虚拟dom被挂在真是dom之后立刻执行,数据被更新到dom之后立刻执行</span><span class="token number">1.</span> Promisemethods<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">updataMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'已更新'</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">//未更新</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token comment">//已更新</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">2.</span>Async<span class="token operator">/</span>Awaitmethods<span class="token operator">:</span><span class="token punctuation">{</span>   <span class="token keyword">async</span> <span class="token function">updataMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'已更新'</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">//未更新</span>        <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$nextTick       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token comment">//已更新</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex文档总结</title>
      <link href="/2021/08/25/vuex-wen-dang-zong-jie/"/>
      <url>/2021/08/25/vuex-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p><code>state</code>里面的值的处理方式与<code>computed</code>属性一样,依赖<code>data</code>里面的值并且做缓存(也就是混入<code>computer</code>)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">state<span class="token operator">:</span><span class="token punctuation">{</span>    userId<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span><span class="token comment">// 混入computed里面</span>computed<span class="token operator">:</span><span class="token punctuation">{</span>   <span class="token comment">// ...mapState(['name1'],['name2']...)</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function-variable function">name1</span><span class="token operator">:</span><span class="token parameter">state</span><span class="token operator">=&gt;</span>state<span class="token punctuation">.</span>name1<span class="token punctuation">,</span>        <span class="token function-variable function">name2</span><span class="token operator">:</span><span class="token parameter">state</span><span class="token operator">=&gt;</span>state<span class="token punctuation">.</span>name2<span class="token punctuation">,</span>        <span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p><code>getter</code>里面的值的处理方式与<code>computed</code>属性一样,依赖<code>data</code>里面的值并且做缓存(也就是混入<code>computer</code>)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">getter<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">setGender</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> gender <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span><span class="token string">'保密'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">:</span><span class="token string">'女'</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> gender<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapGetters<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span>computed<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'setGender'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><ul><li><code>commit</code> === 同步</li><li>第一个参数永远是<code>state</code></li><li>混入<code>methods</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript">mutations<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">setUser</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>useId</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        state<span class="token punctuation">.</span>useId <span class="token operator">=</span> userId    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'mutations里面的方法名'</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapMutations<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span>methods<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'[setUser]'</span><span class="token punctuation">)</span>    <span class="token comment">//传递参数在调用this.setUser(args)既可</span>    <span class="token comment">//this.setUser(args)映射成this.$store.commit('setUser',args)</span><span class="token punctuation">}</span></code></pre><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4></li><li><code>dispatch</code> === 异步</li><li>通过调用<code>mutations</code>里面的方法进行更改<code>state</code></li><li>混入<code>methods</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript">actions<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">login</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commit<span class="token punctuation">}</span><span class="token punctuation">,</span>val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'setUser'</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'mutations里面的方法名'</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapActions<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span>methods<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">//传递参数在调用this.login(args)既可</span>    <span class="token comment">//this.login(args)映射成this.$store.dispatch('login',args)</span>    <span class="token comment">//对login重命名</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">LOGIN</span><span class="token operator">:</span><span class="token string">'login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">LOGIN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web存储</title>
      <link href="/2021/08/24/web-cun-chu/"/>
      <url>/2021/08/24/web-cun-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><code>Cookie</code>是S端发送C端的一个小数据,下次请求的时候C端带上该数据,S端确认是不是同一个浏览器发送过来的数据。</p><blockquote><p>用处</p></blockquote><ol><li>保持登录的状态</li><li>个性化设置(主题)</li><li>浏览器的行为跟踪<br>缺点: <code>Cookie</code>会造成额外的性能开销,每次请求的时候会携带。</li></ol><p><strong>S端收到<code>http</code>请求的时候,S端在响应报文首部添加一个<code>set-cookie</code>的选项, C端收到之后会保存下<code>Cookie</code>,之后的C端每次请求通过请求头部将<code>Cookie</code>信息携带上</strong><br><code>set-Cookie</code>:<strong>&lt;cookie名&gt;=&lt;cookie值&gt;</strong><br><strong>cookie的分类</strong></p><ul><li>会话期的<code>cookie</code>(浏览器关闭之后就没有了,不需要设置过期的时间)</li><li>持久性的<code>cookie</code>(有一个过期时间,设定的时间只跟C端有关,和S端无关的)</li><li>第三方的<code>cookie</code>(<code>cookie</code>是同源的,第三方的<code>cookie</code>就是域和页面的域不同,只用于广告追踪)</li></ul><p><strong>cookie的属性</strong></p><ol><li><code>secure</code>:表示<code>cookie</code>只可以通过<code>https</code>进行传输,不可以使用<code>http</code>进行</li><li><code>httpOnly</code>:避免<code>xss</code>攻击的,就是该<code>cookie</code>设置了<code>httpOnly</code>的话,<code> JavaScript</code>脚本是不可以对该<code>cookie</code>进行调用的,只可以发送给服务器</li><li>作用域属性:规定哪些页面可以使用该<code>cookie</code>.通过<code>domian</code>和<code>path</code>属性来设置。<code>domain</code>包含子域名也可以得到该<code>cookle</code><br><code>path</code>的话指定主机的路径哪些可以接受<code>cookie</code>(指定根路径之后,下面的子路径也可以拿到)<pre class="language-none"><code class="language-none">path = /docs则以下可以拿到cookie/docs/web//docs/web/http/</code></pre></li><li><code>SameSite cookleSameSite=Strict</code></li></ol><p>可以取下面3个值</p><ul><li><p><code>None</code>没有做设置</p></li><li><p><code>Strict</code>只发送给相同站点请求的<code>cookle</code>(就是当前页面的<code>URL</code>与请求目标的<code>URL</code>完全一致)如果请求来自的网址和当前的<code>location</code>的地址不一样,则该<code>cookie</code>不会被发送</p></li><li><p><code>Lax</code>默认的</p></li></ul><p>5.过期时间</p><ul><li><code>session</code>: 表示会话性<code>cookie</code></li></ul><p><code>set-cookie</code> 响应头是服务器返回的响应头,用来在浏范器中种下<code>cookie</code>,一旦被种下,当浏范器访问符合条件的<code>url</code>地址的时候,会自动带上这个<code>cookie</code></p><h4 id="Session待定"><a href="#Session待定" class="headerlink" title="Session待定"></a>Session待定</h4><h4 id="token待定"><a href="#token待定" class="headerlink" title="token待定"></a>token待定</h4><h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><blockquote><p>勾引用户进入第三方的网站,在第三方的网站中,向被攻击的网站发送跨站清求,利用用户在被攻击的网站的登凭证<code>cookie</code>,绕过了后台的用户验证,达到冒充用户访问被攻击的网站进行相关的操作。</p></blockquote><ol><li>CSRF通常是第二方的网站发起</li><li>CSRF攻击者不可以获取到cookle等信息,只是使用而已</li></ol><blockquote><p>防护策略</p></blockquote><ol><li>阻止不明外域的访问</li></ol><ul><li>同源策略</li><li><code>Samesite Cookle</code></li></ul><ol start="2"><li>提交时要求附加本域才能获取信息</li></ol><ul><li><code>SCRF Token</code></li><li>双重的<code>Cookie</code>认证</li></ul><blockquote><p>Token解释</p></blockquote><ol><li>将<code>Token</code>输入到页面中,不能存在<code>Cookie</code>中,否则样被冒充,只能放在服务器的<code>session</code>中</li><li>页面请求携带这个<code>Token</code></li><li>服务器会验证<code>Token</code>是否正确</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期总结</title>
      <link href="/2021/08/24/vue-sheng-ming-zhou-qi-zong-jie/"/>
      <url>/2021/08/24/vue-sheng-ming-zhou-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li><code>beforeCreate</code><br><code>data</code>和<code>methods</code>中的数据还没有被初始化</li><li><code>created</code><br><code>data</code>和<code>methods</code>中的数据已经被初始化,最早在这里进行操作他们的数据</li><li><code>beforeMounte</code><br>模板已经在内存中编辑完成了,但是还没有把模板渲染到页面中去。此时对dom元素无法进行相关的操作,页面中的元素还没有真正的替换出来,页面还是旧的</li><li><code>mounted</code><br>内存中的模板,已经真实的挂载到了页面中,用户可以看到已经渲染好的页面。实例披创建好的最后步,如果没有其他操作,他就安安静静的保存在内存之中<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4></li><li><code>beforeUpdote</code><br><code>data</code>里面的数据发生改变的时候才会触发0次或者多次。表示界面还没有被更新,但是数据已经被更新了。数据与页面不同步更新的,虚拟dom的特性</li><li><code>updated</code><br>数据和页面更新已经同步了,就是虚拟<code>dom</code>已经被变成了真实的<code>dom</code><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4></li><li><code>beforeDestroy</code><br><code>vue</code>实例的销毁阶段,实例身上所有的<code>data</code>、 <code>methods</code>以及指令和过这器等等还是可用的状态。</li><li><code>destroy</code><br>这里组件以及被完全销毁,实例身上所有的<code>data</code>、<code>methods</code>以及指令和过这器等已经是不可用的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Router文档总结</title>
      <link href="/2021/08/24/vue-router-wen-dang-zong-jie/"/>
      <url>/2021/08/24/vue-router-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="两种声明的方式"><a href="#两种声明的方式" class="headerlink" title="两种声明的方式"></a>两种声明的方式</h4><ul><li>声明式导航<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'about'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{path:'</span>about<span class="token string">'}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{name:'</span>about<span class="token string">'}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{name:'</span>about<span class="token string">',params:{userId:'</span><span class="token number">123</span><span class="token string">'}}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{name:'</span>about<span class="token string">',query:{plan:'</span><span class="token keyword">private</span><span class="token string">'}}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span></code></pre></li><li>编程式导航<br>动态路由匹配: <code>url</code>地址中有一部分是一样的,另外一部分是动态变化的,这些动态变化就是路由参数,也就是动态路由匹配。两种方式:<blockquote><ol><li>用路由对象</li><li>使用<code>props</code></li></ol><ul><li>当<code>props</code>是<code>boolean</code>时候,路由对象里面的参数会被设置成组件的属性 <code>props:['id']</code></li><li>当<code>props</code>是<code>Object</code>时候,原样设置成组件的属性,没有设置在里面就拿不到</li><li>当<code>props</code>是<code>function</code>时候,啥也可以获取,接受路由对象做为自己的形参</li></ul></blockquote></li></ul><h4 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h4><p>路由的跳转是个大的过程,分为跳转前中后等等细小的过程,在每一个过程中有一 个相应的函教, 这个函数可以让你操作一些其他事情</p><ol><li>全局的(就是当触发路由的时候就会触发)<ul><li><code>beforeEach</code><br>路由还没有跳转之前就通知,防止跳转之后再告知就晚了,经常用来做登录的验证。</li><li><code>beforeResolve</code><br>导航被确认之前,同时组件内守卫和异步路由组件被解析之后执行也就是在<code>beforeEach</code>和组件内的<code>beforeRouteEnter</code>之后,<code>afterEach</code>之前调用。</li><li><code>afterEach</code><br>路由跳转完成之后触发</li></ul></li><li>路由独享的(就是在配路由的时候可以设置的钩子,该路由才有的)<ul><li><code>beforeEnter</code><br>和beforeEach是样的作用</li></ul></li><li>组件内部的(是指在组件内部执行的钩子函数,给该组件被配置在的路由添加生命周期的钩子函数)<ul><li><code>beforeRouterEnter</code><br>在<code>beforeCreated</code>之前调用,是拿不到<code>this</code>的,用<code>this</code>是访问不了组件的实例对象的,可以通过<code>next</code>函数,参数传入一个回调函数来获取组件实例,这个回调函数在路由被确认的时候就会调用。组件实例作为回调函故的参数。可以获取服务端的数据,当成功获取并能进入路由的时候,调用<code>next</code>通过<code>vm</code>访问组件实例进行赋值等操作。<code>next</code>中的函数调用在进入<code>mounted</code>之后。</li></ul></li></ol><ul><li><code>beforeRouterUpdate</code><br>当前路由改变的时候,并且该组件可以通过<code>this</code>访问实例。<code>/foo/1</code> 和<code>/foo/2</code>之间跳转组件会被复用,当前的<code>query</code>改变的时候,组件会被复用。</li><li><code>beforeRouterLeave</code><br>导航离开该组件的路由的时候调用,可以访问该组件的实例<code>this</code></li></ul><p><strong>参数</strong></p><ol><li><code>to</code> (目标路由对象)</li><li><code>from</code> (即将离开的路由对象)</li><li><code>next</code> (佛珠的线)<ul><li>但凡涉及到<code>next</code>的钩子,必须调用<code>next()</code>才可以继续执行下一个钩子,否则路由跳转就会停止</li><li>中断导航用<code>next(false)</code>。如果浏览器的地址改变了(用户手动、浏览器后退操作) <code>url</code>会重置到<code>from</code>的地址(登录验证失败的时候处理)</li><li><code>next('/')</code>或者<code>next(path:'/')</code>当前的导航被中断,然后进行新的导航</li><li>在<code>beforeRouterEnter</code>中<code>next(vm=&gt;{})</code>内接受的回调函数的参数为当前组件的实例<code>vm</code>,这个回调函数是在<code>mounted</code>之后调用的,也就是说,他是所有的导航守卫和生命周期函数最后执行的</li><li><code>next(error)</code>,导航被中断而且错误给<code>router.onError()</code>注册过的回调函数</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中问题</title>
      <link href="/2021/08/24/vue-xiang-mu-zhong-wen-ti/"/>
      <url>/2021/08/24/vue-xiang-mu-zhong-wen-ti/</url>
      
        <content type="html"><![CDATA[<ul><li><code>computer</code>中传参数的话需要使用闭包的方式</li><li><code>filter</code>中无法访问<code>this</code>,使用<code>filter</code>的前提是有个现成的变量</li><li>数字千分位处理并保留两位小数<code>nums.toFixed(2).replace(/(\d)(?=(\d{3}+.)/g,'$1')</code></li><li><code>splice(index,1)</code>返回的数据是被删除的那个数据或者数组 —– 会改变原数组</li><li><code>try/catch</code> 只能捕获同步函数的异常,包括async/await</li><li><code>Vue</code>项目中报错<code>Already include file name 'xxxx' differs from files name...</code>,解决办法是：去掉后面<code>.vue</code>后缀名既可</li><li>页面刷新之后,会重新加载<code>Vue</code>实例,<code>store</code>里面的值会被重新赋值,这样会造成页面刷新只会<code>Vuex</code>中数据丢失的问题,解决办法是：利用<code>Web</code>存储<code>(cookie\localStorage\sessionStorage)</code></li><li>每一个页面都是一个组件,路由跳转的时候组件就会被<code>销毁和重新建立</code>,跳转会经历一个完整的生命周期</li><li><code>babel</code> 又名通天塔,它的作用是<code>ES6</code>、<code>ES7</code>转成<code>ES5</code></li><li><code>CSS</code>中的行内元素水平居中直接在父元素中<code>text-align:center</code>,垂直居中设置行高和高度相等:<code>height:10px;line-height:10px</code></li><li><code>SSR</code>服务端渲染<ul><li>前后端分离的缺点(适合后台管理项目或者大量路由的项目)<ul><li><code>SEO</code>不友好:因为页面中只有一个<code>div</code>,其他页面的操作是通过JS来进行的,<code>SEO</code>是通过爬取<code>html</code>代码的,而不是<code>JS</code>代码</li><li>首屏加载慢:更多的加载和渲染的工作是由浏览器来完成的</li><li>性能的问题:理由同上,频繁的和服务端进行数据交互</li></ul></li><li>解决上述办法-&gt;<code>SSR</code>服务端渲染(适合官网项目和推广页项目)<ul><li>简单来说就是服务端拿到数据进行解析渲染,直接生成<code>html</code>片段返回给前端</li><li>传统的服务端模板引擎渲染整个页面</li><li>服务端渲染生成的<code>html</code>代码块,前端通过<code>ajax</code>获取然后通过<code>JS</code>动态的添加</li></ul></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用跨域</title>
      <link href="/2021/08/24/chang-yong-kua-yu/"/>
      <url>/2021/08/24/chang-yong-kua-yu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端访问服务器的时候数据因为跨域无法直接得到<br>服务端和服务端之间的通信是不存在跨域的,都是同源<br>前后端不分离的时候就是同源,前端和后端代码在同一个电脑上</p></blockquote><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li>script</li><li>img</li><li>link</li><li>iframe<blockquote><p>它们不受同源策略的影响</p></blockquote></li></ul><hr><p>它们通过<code>script</code>标签的<code>src</code>,<code>src</code>指向服务器的<code>api</code>地址,因为不受同源的影响,因此可以访问带数据,之后把本地浏览器端的一个函数<code>func</code>作为回调函数传递给服务器。服务器收到请求,同时也可以拿到传过来的函数<br>之后服务器做两件事</p><ol><li>服务端准备数据<code>data</code></li><li>给客户端返回数据(利用传过来的函数进行包装<code>data</code>数据=&gt;<code>func('JSON.stringify(data)+')</code>。客户端收到响应,发现数据格式就是自己全局函数<code>func</code>,于是对函数<code>fun</code>进行调用,执行<code>JSON.parse</code>得到<code>data</code></li></ol><p><em><strong>特点</strong></em></p><ul><li><code>JSONP</code>需要服务端的支持</li><li><code>func</code>必须为全局函数</li><li>服务端需要利用<code>func</code>进行数据包装</li><li>只支持<code>get</code>请求(限制了我平时在开发中,基本用不到它！！！)</li></ul><hr><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><ul><li>C端发送<code>axios/ajax</code>请求并做一些基本的配置</li><li>S端设置响应头的相关信息,但是需要做<code>options</code>试探性的请求(如果是利用<code>node</code>开服务的话,可以利用中间件进行相关的设置) </li></ul><h4 id="http-proxy-gt-webpack-webpack-dev-server"><a href="#http-proxy-gt-webpack-webpack-dev-server" class="headerlink" title="http proxy =>webpack + webpack-dev-server"></a>http proxy =&gt;webpack + webpack-dev-server</h4><p>正常开发的<code>Vue</code>项目的时候,下载<code>webpack-dev-serve</code>直接设置<code>webpack</code>配置文件既可以。<code>Vue-cli</code>已经集成,在<code>vue.config.js</code>中进行配置</p><h4 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a>document.domain+iframe</h4><p>只能实现同一个主域,不同子域之间的同源</p><pre class="language-none"><code class="language-none">v.qq.comsports.qq.comqq.com是主域</code></pre><h4 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h4><p>不需要前端参与,后端在<code>linux</code>中进行配置</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-S数据基本过程</title>
      <link href="/2021/08/24/c-s-shu-ju-ji-ben-guo-cheng/"/>
      <url>/2021/08/24/c-s-shu-ju-ji-ben-guo-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一次http请求至少进行两次的数据转换,发送请求的时候一次,获取响应数据的时候一次</p></blockquote><table><thead><tr><th>顺序</th><th>层名</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>应用层</td><td>数据</td></tr><tr><td>2</td><td>传输层</td><td>数据+源端口+目标端口</td></tr><tr><td>3</td><td>网络层</td><td>数据+源端口+目标端口+源IP+目标IP</td></tr><tr><td>4</td><td>链路层</td><td>转换成数字信息进行传输</td></tr></tbody></table><h4 id="从客户端-1-gt-2-gt-3-gt-4"><a href="#从客户端-1-gt-2-gt-3-gt-4" class="headerlink" title="从客户端 1->2->3->4"></a>从客户端 1-&gt;2-&gt;3-&gt;4</h4><h4 id="从服务端-4-gt-3-gt-2-gt-1"><a href="#从服务端-4-gt-3-gt-2-gt-1" class="headerlink" title="从服务端 4->3->2->1"></a>从服务端 4-&gt;3-&gt;2-&gt;1</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/08/24/bi-bao/"/>
      <url>/2021/08/24/bi-bao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS的函数内部可以访问全局变量,但是在函数的外部是不可以读取内部的局部变量<br>闭包其实就是提供一个方式来读取函数内部的变量</p></blockquote><h4 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h4><ul><li><p>单纯的觉得闭包是拿到函数内部的变量是不对的,以下这种方式也可以拿到,但它不是闭包</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 外部可以拿到a,但不是闭包</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span><span class="token number">100</span>    <span class="token keyword">return</span> a<span class="token punctuation">}</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//101</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//101   此时函数f3已经被垃圾回收了,再次调用就是重新开始创建变量等一系列的过程</span></code></pre></li><li><p>闭包真正的原因是局部变量无法长久保存,全局变量又容易污染环境,希望可以找到一种既可以长久保存又不会造成全局污染的方法,这就是<code>闭包的机制</code>。所以看似代码复杂化,其实大有来头。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f2<span class="token punctuation">}</span><span class="token keyword">let</span> f <span class="token operator">=</span> f1 <span class="token comment">// f1执行的结果,其实就是return出来的f2函数 ===== 闭包</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 101</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 102</span><span class="token comment">/** * 1、f1的调用结果被赋给了全局变量f,全局变量f一直存在于内存中,f1函数执行完毕之后就会被释放,但是return出来了一个函数,也就是会造成内存泄漏的原因（变量a没有被释放） * 2、a是局部变量但是他不会被销毁。因为f2还保持着对a的引用（JS的垃圾回收机制之中的引用计数原则）*/</span></code></pre><p>用匿名函数简写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li></ul><ol><li>注意全局变量一直存在于内存中,局部变量执行完之后被垃圾回收（包括函数）,再次执行该函数的时候又得重新开始</li><li>闭包的代码复杂的真正原因<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//1</span><span class="token function">s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token function">s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//3</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode中使用git</title>
      <link href="/2021/08/20/vscode-zhong-shi-yong-git/"/>
      <url>/2021/08/20/vscode-zhong-shi-yong-git/</url>
      
        <content type="html"><![CDATA[<p><strong>在VsCode中使用Git提交的过程</strong></p><ol><li>先确定提交的分支,”+”是提交到暂缓区,相当于<code>git add .</code></li><li>“√”是将暂缓区的代码提交到本地代码仓库,相当于<code>git commit -m ""</code></li><li>提交到<code>github</code>远程仓库之前，应该先”拉取”远程仓库，用来和本地的仓库做同步，如果有冲突，VsCode会自动跳出冲突，编辑解决完冲突之后，再进行下一步</li><li>最后一步”推送”，本地仓库的代码同步到<code>github</code>远程仓库</li></ol>]]></content>
      
      
      <categories>
          
          <category> VsCode </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bom知识总结</title>
      <link href="/2021/08/20/bom-zhi-shi-zong-jie/"/>
      <url>/2021/08/20/bom-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>好记性不如烂笔头！</p><h3 id="1-BOM-Browser-Object-Model"><a href="#1-BOM-Browser-Object-Model" class="headerlink" title="1.BOM: Browser Object Model"></a>1.BOM: Browser Object Model</h3><p>什么是: 专门操作浏览器窗口的API<br>没有标准, 导致浏览器兼容性问题<br>包括:<br>window<br>history<br>location<br>navigator<br>dom<br>event<br>screen</p><h3 id="2-window"><a href="#2-window" class="headerlink" title="2.window:"></a>2.window:</h3><p>属性: .innerWidth, .innerHeight 浏览器窗口中,文档显示区的宽和高<br>方法: .open() .close() .open(“url”,”name”)</p><p>三种:</p><pre class="language-none"><code class="language-none">CODE1.在当前窗口打开,可后退: .open("url","_self")2.在新窗口打开,可打开多个: .open("url","_blank")3.在新窗口打开,只能打开一个:   .open("url","自定义窗口名")</code></pre><h3 id="3-history-保存当前窗口打开后-成功访问过的url的历史记录栈"><a href="#3-history-保存当前窗口打开后-成功访问过的url的历史记录栈" class="headerlink" title="3.history: 保存当前窗口打开后,成功访问过的url的历史记录栈"></a>3.history: 保存当前窗口打开后,成功访问过的url的历史记录栈</h3><p>在当前窗口中,每访问一个新url,都会将新url压入history<br>API: history.go(n)</p><p>3种:</p><pre class="language-none"><code class="language-none">CODE前进: history.go(1)  后退: history.go(-1)  刷新: history.go(0)</code></pre><h3 id="4-location-保存当前窗口正在打开的url的对象"><a href="#4-location-保存当前窗口正在打开的url的对象" class="headerlink" title="4.location: 保存当前窗口正在打开的url的对象"></a>4.location: 保存当前窗口正在打开的url的对象</h3><p>属性:<br>.href 完整url地址<br>.protocol 协议<br>.host 主机名+端口号<br>.hostname 主机名<br>.port 端口号<br>.pathname 相对路径<br>.hash #锚点地址<br>.search ?查询字符串</p><p>方法:</p><ol><li>在当前窗口打开,可后退:<br>location.assign(url) =&gt; location.href=url =&gt; location=url</li><li>在当前窗口打开,禁止后退:<br>location.replace(url)</li><li>重新加载页面: 刷新: 2种:<ol><li>普通刷新:<br>优先从浏览器本地缓冲获取资源:<br>F5<br>history.go(0)<br>location.reload(/<em>false</em>/)</li><li>强制刷新:<br>无论本地是否有缓存,总是强制从服务器获取资源<br>location.reload(true)</li></ol></li></ol><h3 id="5-定时器-2种"><a href="#5-定时器-2种" class="headerlink" title="5.定时器: 2种:"></a>5.定时器: 2种:</h3><ol><li><p>周期性定时器:<br>什么是: 让程序每隔指定的时间间隔,反复执行一项任务<br>何时: 只要让程序按照指定的时间间隔,自动执行一项任务<br>如何: 3件事:<br>1.任务函数: 让定时器反复执行的任务<br>2.启动定时器: timer=setInterval(task, interval)</p><pre class="language-none"><code class="language-none">CODE让程序,每隔interval 毫秒自动执行一次task任务</code></pre><p>3.停止定时器: clearInterval(timer)</p><pre class="language-none"><code class="language-none">CODEtimer: 定时器的序号, 在内存中唯一标识定时器的整数 专门用于停止定时器 如何获得: 只能在启动定时器时获得。 何时: 只要一个定时器可能被停止,就要在启动时,先保存定时器序号 好的习惯: 在clearInterval之后,手动清除timer中残留的序号: timer=null;</code></pre><p>停止定时器: 2种情况:</p><ol><li>用户手动停止:</li><li>定时器可自动停止:<br>在任务函数中,设定临界值,如果没有达到临界值,则继续执行任务,否则,如果达到临界值,就自动调用clearInterval</li></ol></li></ol><p>2.一次性定时器:<br>什么是: 让程序先等待一段时间,再执行一次任务。执行后,自动停止。<br>何时: 只要让程序延迟执行一件事时<br>如何: 3件事:<br>1.task<br>2.启动定时器: timer=setTimeout(task,wait)</p><pre class="language-none"><code class="language-none">CODE让程序等待wait毫秒后,自动执行一次task,执行后自动停止</code></pre><p>3.停止定时器: clearTimeout(timer)</p><h3 id="6-定时器原理"><a href="#6-定时器原理" class="headerlink" title="6.定时器原理:"></a>6.定时器原理:</h3><p>定时器中的任务函数,必须等待主程序所有语句执行后,才能执行。</p><h3 id="7-navigator"><a href="#7-navigator" class="headerlink" title="7.navigator:"></a>7.navigator:</h3><p>1.什么是: 保存浏览器配置信息的对象<br>包括:<br>.cookieEnabled: 判断当前浏览器是否启用cookie</p><p>2.什么是cookie: 在客户端持久存储用户私密数据的小文件<br>为什么: 内存中所有数据都是临时的! 程序关闭,内存中一切变量都释放!<br>何时: 只要希望在客户端持久保存数据,都用cookie<br>.plugins: 包含浏览器所有插件信息的集合</p><p>3.什么是插件: 为浏览器添加新功能的小软件</p><pre class="language-none"><code class="language-none">CODE如何判断是否安装指定插件: </code></pre><p>.userAgent: 保存浏览器名称和版本号的字符串<br>何时: 只要判断浏览器名称和版本号</p><h3 id="8-event"><a href="#8-event" class="headerlink" title="8.event:"></a>8.event:</h3><p>什么是事件: 人为触发的,或浏览器自动触发的页面内容状态的改变。<br>什么是事件处理函数: 当事件发生时,自动执行的函数。<br>如何绑定: 3种:</p><ol><li>在HTML中绑定:<br>绑定:<br>当事件发生时: 自动执行js语句<br>问题: 不符合内容与行为分离的原则,不便于维护和重用<br>但是: 在组件开发中,反而要求内容,行为和样式集中定义在一个小组件内,自成体系。</li><li>在js中绑定, 每个事件只能绑定一个处理函数:<br>ANY.on事件名=function(){ … }<br>当事件发生时: ANY.on事件名() //this-&gt;ANY<br>问题: 用赋值方式绑定事件处理函数</li><li>在js中绑定,每个事件可绑定多个处理函数:<br>ANY.addEventListener(‘事件名’,handler)<br>在浏览器中为ANY元素的指定事件,添加一个事件监听对象。将事件监听对象加入到浏览器的监听队列中。<br>触发事件时: 浏览器会遍历监听队列中的每个监听对象,找到触发事件元素上对应事件的监听对象,调用其处理函数<br>移除事件监听:<br>ANY.removeEventListener(‘事件名’,handler)<br>说明: handler必须是绑定时使用的原函数对象<br>强调: 如果一个处理函数,有可能被移除,则不能使用匿名函数绑定。应使用有名的函数绑定</li></ol><h3 id="9-DOM事件模型"><a href="#9-DOM事件模型" class="headerlink" title="9.DOM事件模型:"></a>9.DOM事件模型:</h3><p>什么是: 从事件触发到处理函数执行,所经过的过程<br>3个阶段:</p><ol><li>捕获capture: 由外向内,记录各级父元素上绑定的事件处理函数。——仅记录,不触发!</li><li>目标触发: 优先触发实际点击的元素上绑定的处理函数</li><li>冒泡执行: 由内向外,按捕获阶段记录的处理函数的倒序,依次执行父元素上的处理函数。</li></ol><h3 id="10-事件对象"><a href="#10-事件对象" class="headerlink" title="10.事件对象:"></a>10.事件对象:</h3><p>什么是: 当事件发生时,自动创建的,封装事件信息的对象<br>何时: 只要希望获得事件信息,或修改事件的默认行为时<br>如何获取: 事件对象默认总是以处理函数第一个参数,自动传入<br>如何使用:</p><ol><li><p>取消冒泡: e.stopPropagation()</p></li><li><p>利用冒泡:<br>优化: 尽量减少事件监听的个数<br>为什么: 浏览器查找事件监听,采用的是遍历的方式</p><pre class="language-none"><code class="language-none">CODE事件监听多,浏览器查找就慢</code></pre><p>何时: 如果对多个子元素绑定相同事件时,都要利用冒泡<br>如何: 只要在父元素绑定一次,所有子元素共用即可!<br>2个难题:</p><pre class="language-none"><code class="language-none">CODE1. 获得目标元素:  目标元素: 最初实际触发事件的当前元素  如何获得:    错误: this-&gt;父元素   正确: e.target2. 筛选目标元素:  比如: 通过nodeName, class, 内容。。。</code></pre></li><li><p>阻止默认行为:<br>何时: 只要事件的默认行为不是想要的<br>如何: e.preventDefault();<br>何时:</p><ol><li>用a当按钮时,a会自动向地址栏中添加#锚点地址。</li><li>提交表单时,如果验证没通过,可阻止提交<br>自定义表单提交:<br>input button + onclick + form.submit<br>input submit + form.onsubmit事件 + e.preventDefault()</li><li>HTML5中拖拽API: 首先要阻止浏览器默认的拖拽行为</li></ol></li></ol><h3 id="11-鼠标坐标-3组"><a href="#11-鼠标坐标-3组" class="headerlink" title="11.鼠标坐标:(3组)"></a>11.鼠标坐标:(3组)</h3><pre class="language-none"><code class="language-none">CODE1. 相对于屏幕左上角: e.screenX,  e.screenY2. 相对于文档显示区左上角: e.clientX,  e.clientY3. 相对于当前元素左上角:  e.offsetX,   e.offsetY</code></pre><h3 id="12-页面滚动"><a href="#12-页面滚动" class="headerlink" title="12.页面滚动:"></a>12.页面滚动:</h3><p>事件: window.onscroll<br>获得页面滚动过的高度: body顶部超出文档显示区顶部的距离</p><pre class="language-none"><code class="language-none">CODEscrollTop=document.documentElement.scrollTop        ||document.body.scrollTop;</code></pre><p>滚动API:<br>window.scrollTo(left, top)<br>window.scrollBy(left的增量,top的增量)</p>]]></content>
      
      
      <categories>
          
          <category> BOM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css知识总结</title>
      <link href="/2021/08/20/css-zhi-shi-zong-jie/"/>
      <url>/2021/08/20/css-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前端知识点总结——CSS"><a href="#前端知识点总结——CSS" class="headerlink" title="前端知识点总结——CSS"></a><strong>前端知识点总结——CSS</strong></h2><p>好记性不如烂笔头！</p><h3 id="1-CSS的概述"><a href="#1-CSS的概述" class="headerlink" title="1.CSS的概述"></a>1.CSS的概述</h3><p>1.什么是CSS?</p><pre class="language-none"><code class="language-none">CODECSS：Cascading Style Sheets层叠样式表,级联样式表（简称：样式表）</code></pre><p>2.作用</p><pre class="language-none"><code class="language-none">CODE设置HTML网页元素的样式</code></pre><p>3.HTML与CSS的关系</p><pre class="language-none"><code class="language-none">CODEHTML：负责内容的展示CSS：负责内容（元素）的修饰</code></pre><p>4.HTML与CSS之间的使用原则</p><pre class="language-none"><code class="language-none">CODEW3C建议尽量使用CSS属性去取代HTML属性来修饰元素</code></pre><h3 id="2-CSS语法规范"><a href="#2-CSS语法规范" class="headerlink" title="2.CSS语法规范"></a>2.CSS语法规范</h3><p>1.使用CSS样式的方式(重点)</p><pre class="language-none"><code class="language-none">CODE 1.内联样式   又称为行内样式   特点：将CSS样式定义在HTML开始标记中   语法：     &lt;ANY style="样式声明1；样式声明2"&gt;&lt;/ANY&gt; 样式声明：      1.由样式属性和值来组成      2.属性名与值之间用 冒号 连接      3.多个样式声明之间用 分号 分割        常用的CSS样式属性 和 值：      1.设置文本颜色的属性和值        属性：color    值：合法的颜色值（英文）      2.设置背景颜色的属性和值        属性：background    值：合法的颜色值（英文）      3.设置文字大小的属性和值        属性：font-size    值：以px或pt为单位的数字    ex：font-size:30px;      2.内部样式   在网页的头元素中增加一对&lt;style&gt;标记,在&lt;style&gt;标记声明该网页用到的样式规则   语法： &lt;head&gt;             &lt;style&gt;        /*注释*/        样式规则1        样式规则2        ...     &lt;/style&gt;      &lt;/head&gt;    样式规则：由选择器和样式声明组成选择器：规范了页面中哪些元素能够使用定义好的样式（就是把声明好的样式匹配给页面中的元素）元素选择器：由元素的名称作为选择器div,p,h1,span,a,img选择器{}ex：div{}    p{}样式规则：   选择器{      样式声明；   }ex:div{   color:red;   font-size:20px;}p{  color:blue;}h1{...} 3.外部样式   独立于任何网页的位置处,声明一个样式表文件（***.css为后缀）,   在.css文件中保存样式规则,然后在网页中引入.css文件。   使用步骤：       1.创建样式表文件,并编写样式规则   2.在网页中引入样式表文件     &lt;head&gt;        &lt;link rel="stylesheet" href="**.css"&gt;     &lt;/head&gt;</code></pre><h3 id="3-CSS样式特征"><a href="#3-CSS样式特征" class="headerlink" title="3.CSS样式特征"></a>3.CSS样式特征</h3><pre class="language-none"><code class="language-none">CODE1.继承性  大部分样式可以被继承（子元素继承父元素的样式特征）  必须是有层级关系的嵌套  &lt;div style="color:red;"&gt;     &lt;p&gt;p&lt;/p&gt;  &lt;/div&gt;2.层叠性   可以为一个元素定义多个样式,当样式属性不冲突时,可以同时将这些样式应用到元素上  div{     color:red;  }  div{     font-size:20px;  }  div{     background:gray;  }3.优先级  如果样式声明冲突时,会按照样式的优先级来应用定义的样式规则      由低到高：     浏览器默认设置       最低     内部样式和外部样式   中(就近原则)     内联样式             最高4.调整显示的优先级  !important规则：  调整显示的优先级  将!important添加在属性值之后,与值之间用空格隔开,就能优先使用当前样式  ex:    color:red !important;</code></pre><h3 id="4-CSS基础选择器（重点）"><a href="#4-CSS基础选择器（重点）" class="headerlink" title="4.CSS基础选择器（重点）"></a>4.CSS基础选择器（重点）</h3><pre class="language-none"><code class="language-none">CODE1.选择器的作用  规范页面中哪些元素能够使用定义好的样式2.选择器详解  1.通用选择器    作用：可以修饰页面上的任何元素语法：*{样式声明}效率较低,尽量少用ex:  *{    color:red;    font-size:40px;  }</code></pre><p>2.元素选择器</p><pre class="language-none"><code class="language-none">CODE    作用：设置页面上某种（类）元素的样式语法：标记名称{声明样式}ex：  div{}  p{}  span{}  </code></pre><p>3.类选择器</p><pre class="language-none"><code class="language-none">CODE    作用：定义页面上某个或某些元素的样式(谁想用谁就可以引用)特点：通过元素的class属性进行引用语法：   1.声明     .类名{样式声明}     注意：       1.类名是自定义的,但是注意类名不能以数字开头       2.类名不能包含特殊符号（&amp;,^,%,$,#,@）       3.可以包含（_,-）   2.引用     &lt;ANY class="类名"&gt;    特殊用法：       1.多类选择器     让一个元素同时引用多个类选择器     语法：     &lt;ANY class="类名1 类名2 类名3 ..."&gt;       2.分类选择器     将元素选择器和类选择器联合使用     对同一类元素中某些特殊的内容进行修饰     语法：元素名称.类选择器{样式声明}        ex:div.text{color:red;}      &lt;div class="text"&gt;dddd&lt;/div&gt;      &lt;div&gt;d1d1d1&lt;/div&gt;</code></pre><p>4.id选择器</p><pre class="language-none"><code class="language-none">CODE作用：设置指定ID元素的样式（专属定制）语法：#id值{样式声明}ex:  &lt;div id="one"&gt;&lt;/div&gt;  #one{    color:red;  }</code></pre><p>5.群组选择器</p><pre class="language-none"><code class="language-none">CODE作用：将多个选择器放在一起进行样式的声明定义语法：选择器1,选择器2,选择器3,...{样式声明} ex:   div,#main,.mycolor,p.text{color:red;}   等同于： div{color:red}; #main{color:red}; .mycolor{color:red}; p.text{color:red};</code></pre><p>6.后代选择器</p><pre class="language-none"><code class="language-none">CODE作用：通过元素的后代关系匹配元素（多级嵌套）语法：选择器1 选择器2 选择器3{样式声明}</code></pre><p>7.子代选择器</p><pre class="language-none"><code class="language-none">CODE作用：通过元素的子代（一层层级关系）关系匹配元素语法：选择器1&gt;选择器2{样式声明}</code></pre><p>8.伪类选择器</p><pre class="language-none"><code class="language-none">CODE作用：匹配元素不同的状态的选择器语法：   所有的伪类都是以：作为开始   选择器：伪类选择器{样式声明}1.连接伪类     :link 匹配元素尚未访问的状态 :visited 匹配元素访问过的状态2.动态伪类     :hover 匹配鼠标悬停在元素上时的状态 :active 匹配元素被激活时的状态（超链接,文本框,密码框点击的时候） :focus 匹配元素获取焦点时的状态（文本框和密码框）3.选择器的优先级  权值：标识当前选择器的重要程度,权值越大优先级越高。    元素选择器：1类选择器：  10伪类选择器：10ID选择择器：100内联样式：  1000选择器的权值加到一起,大的优先权值相同,以后定义的为主</code></pre><h3 id="5-尺寸与边框"><a href="#5-尺寸与边框" class="headerlink" title="5.尺寸与边框"></a>5.尺寸与边框</h3><p>1.单位</p><pre class="language-none"><code class="language-none">CODE1.尺寸单位  1.px：像素    1024*768  2.in:英寸    1in=2.54cm  3.pt：磅(1pt=1/72in)    多数用于表示文字的大小  4.cm:厘米  5.mm:毫米  6.em:相对于父元素乘以倍数(多个父元素2em)  7.rem:根相对（元素字体大小乘以倍数,html\body）2.颜色单位（颜色取值）  1.英文单词    red,blue,gray,green,yellow,black....  2.rgb(r,g,b)    r:0-255g:0-255b:0-255  3.rgba(r,g,b,alpha)    alpha:透明度,取值为0-1之间的小数,值越大,不透明度越高  4.#rrggbb    由6位16进制的数字\字母表示一个颜色0-9或A-f#000000:黑色#ffffff:白色#eeeeee:灰色#ff11aa  5.#rgb是上面的缩写形式    #000:黑色#fff:白色#f1a</code></pre><p>2.尺寸属性</p><pre class="language-none"><code class="language-none">CODE1.作用  设置元素的宽度和高度2.语法  1.宽度    width:宽度min-width:最小宽度max-width:最大宽度  2.高度    height：高度min-height:最小高度max-height:最大高度3.页面中哪些元素允许设置尺寸属性  1.所有的块级元素都允许设置尺寸    div,p,h1,h2..h6,ul,ol,dl,结构标记  2.本身具备width和height属性的行内元素是可以设置的    img,table  3.行内块允许设置尺寸    大部分的表单控件（单选按钮,复选框）  4.大部分的行内元素是无法设置尺寸    a,span,b,i,u,s等</code></pre><p>3.溢出处理</p><pre class="language-none"><code class="language-none">CODE当内容多,元素区域小的时候,就会产生溢出的效果,默认都是纵向溢出。属性：overflow,overflow-x,overflow-y取值：   1.visible     可见的,默认值,溢出可见   2.hidden     隐藏的,溢出的内容全部隐藏,溢出内容不可见   3.scroll     显示滚动条,溢出时,可用   4.auto     自动,溢出时才显示滚动条并可用</code></pre><p>4.边框</p><pre class="language-none"><code class="language-none">CODE1.边框属性  1.简写方式    border:width style color;     width:边框的宽度,以px为单位的数值     style:边框的样式       取值：         solid:实线     dotted:虚线边框(点)     dashed:虚线边框(线)     color:边框的颜色         取值：合法的颜色值     transparent:透明色     注意：       取消边框：border:0;或border:none;  2.单边定义    只设置某一条边的边框属性：border-方向:width style color;    方向：top/bottom/left/right       上   下     左   右  3.单属性定义    只设置四条边框的一个属性属性：border-width/style/color:值；  ex:border-width:3px;     border-style:dotted;     border-color:red;  4.单边单属性的定义    只设置某一个方向的某一个属性属性：  border-方向-属性：值；  方向：top/bottom/left/right  属性：width/style/color  ex：    border-left-color:blue;    border-right-style:solid;    border-bottom-width:6px;2.边框倒角  将元素的直角倒换成圆角  属性：border-radius  取值：        1.以px为单位的数值        2.百分比 %  设置圆形（50%）  单角设置：     border-top-left-radius:左上角 border-top-right-radius:右上角 border-bottom-left-radius:左下角 border-bottom-right-radius:右下角3.边框阴影 属性：box-shadow 取值：h-shadow v-shadow blur spread color inset    h-shadow:阴影在水平方向的偏移距离,必须值        取值为正：阴影向右偏移     取值为负：阴影向左偏移v-shadow:阴影在垂直方向的偏移距离,必须值        取值为正：阴影向下偏移     取值为负：阴影向上偏移blur:阴影模糊距离,取值越大,模糊效果越明显,以px为单位的数值（可选值）spread:阴影的大小,指定要在基础阴影上扩充出来的大小,取值以px为单位的数值（可选值）color:阴影颜色（可选值）inset:将默认的外阴影改为内阴影（可选值）4.轮廓  轮廓指的是边框的边框,绘制于边框外围的一条线  属性：     outline:width style color; widht:轮廓的宽度 style:轮廓的样式      取值：solid/dotted/dashed color:轮廓的颜色  取消轮廓：       outline:none/0;</code></pre><h3 id="6-框模型"><a href="#6-框模型" class="headerlink" title="6.框模型"></a>6.框模型</h3><p>1.什么是框模型</p><pre class="language-none"><code class="language-none">CODE框模型：box model,定义了元素框处理元素的内容,内边距,外边距以及边框的一种计算方式。外边距：元素与元素之间的空白间距内边距：元素边框与元素内容之间的间距框模型的计算模式：    元素的实际占地宽度=左右外边距+左右边框+左右内边距+width;元素的实际占地高度=上下外边距+上下边框+上下的内边距+height</code></pre><h3 id="7-外边距"><a href="#7-外边距" class="headerlink" title="7.外边距"></a>7.外边距</h3><p>1.什么是外边距</p><pre class="language-none"><code class="language-none">CODE围绕在元素边框外的空白距离,就是外边距也能表示当前元素与其他元素之间的空白距离</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：   margin 定义某个元素四个方向的外边距   margin-top/bottom/left/right 定义单边的外边距取值：   1.具体数值,以px为单位   2.取值为负     让元素向相反的方向移动 margin-left:  取值为正,让元素向右移动  取值为负,让元素向左移动 margin-top:  取值为正,让元素向下移动  取值为负,让元素向上移动   3.取值为%     外边距的值,是父元素的宽或高的占比（50%）   4.取值为auto     自动计算外边距的值（控制块级元素水平居中对齐）简写方式：    1.margin:value  四个方向的外边距2.margin:v1 v2;  v1:上下外边距  v2:左右外边距3.margin:v1 v2 v3;  v1:上外边距  v2:左右外边距  v3:下外边距3.margin:v1 v2 v3 v4;         上 右 下 左  （顺时针方向）</code></pre><p>3.自带外边距的元素</p><pre class="language-none"><code class="language-none">CODEbody,h1~h6,p,ul,ol,dl,dd,pre通过CSS Reset(css重写)的手段,来重置具备外边距的元素 body,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd,pre{    margin:0; }</code></pre><p>4.外边距的特殊效果</p><pre class="language-none"><code class="language-none">CODE1.外边距合并  当两个垂直外边距相遇时,他们将合并为一个,最终取决于两个外边距中距离较大的那个。  如果两个外边距相遇时值相等,那么取其中一个值。2.外边距的溢出  在某些条件下,为子元素设置上外边距时,有可能会作用到父元素上。      1.父元素没有上边框  2.为子元素设置上外边距时2.在d2中嵌套一个子元素div,id="d3",设置其尺寸为100*100,并设置其背景颜色3.设置d3的上外边距为50px,观察其结果。 解决溢出方案：    1.为父元素增加上边框  弊端：对父元素的高度有影响2.使用父元素的上内边距来取代子元素的上外边距  弊端：对父元素的高度有影响3.在父元素的第一个子元素位置处,增加一个空(table) 行内元素以及行内块元素的垂直外边距     1.行内元素垂直外边距无效（img除外） 2.行内块元素,设置垂直外边距时,整行元素都跟着发生改变</code></pre><h3 id="8-内边距"><a href="#8-内边距" class="headerlink" title="8.内边距"></a>8.内边距</h3><p>1.什么是内边距</p><pre class="language-none"><code class="language-none">CODE元素边框与内容之间的空白距离内边距会扩大元素边框占地区域</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：   padding 四个方向的内边距   padding-top/bottom/left/right 设置单边内边距取值：      以px为单位的数值      以%形式设置简写方式：      1.padding:value;  四个方向的内边距  2.padding:v1 v2;     v1:上下内边距    v2:左右内边距  3.padding:v1 v2 v3;    v1:上    v2:左右    v3:下  4.padding:v1 v2 v3 v4;            上 右 下 左 （顺时针）</code></pre><h3 id="9-属性：box-sizing"><a href="#9-属性：box-sizing" class="headerlink" title="9.属性：box-sizing"></a>9.属性：box-sizing</h3><p>作用：指定框模型的计算方式</p><pre class="language-none"><code class="language-none">CODE取值：   1.content-box     默认值,采用默认的计算元素的占地区域 实际占地宽度=左右边框+左右外边距+左右内边距+width; 实际占地高度=上下边框+上下外边距+上下内边距+height;   2.border-box     元素的尺寸,会包含border以及padding的值 实际占地宽度=width(包含了border和padding) 实际占地高度=height(包含了border和padding)</code></pre><p>3.背景属性<br>背景：可以是单一颜色或图片填充元素<br>1.背景色</p><pre class="language-none"><code class="language-none">CODE属性：background-color取值：合法的颜色值注意：背景颜色默认是从边框的位置处开始填充的</code></pre><p>2.背景图片</p><pre class="language-none"><code class="language-none">CODE属性：background-image取值：url(图片的路径);ex:background-image:url(a.jpg);</code></pre><p>3.背景图片平铺</p><pre class="language-none"><code class="language-none">CODE属性：background-repeat取值：   repeat 默认值,横向纵向都平铺   no-repeat 不平铺（图片只显示一次）   repeat-x 只在水平方向平铺   repeat-y 只在垂直方向平铺</code></pre><p>4.背景图片尺寸</p><pre class="language-none"><code class="language-none">CODE属性：background-size取值：   1.width/height  (ex:200px 300px)   2.width%/height%  (ex:50% 50% 是元素自己的高宽占比)   3.cover     将背景图等比放大,直到背景图完全覆盖到元素的所有区域为止。   4.contain     将背景图等比放大,直到背景图碰到元素的某一个边缘为止</code></pre><p>5.背景图片固定</p><pre class="language-none"><code class="language-none">CODE作用：将背景图固定在网页的某个位置处,一直在可视区域中,不会随着滚动条而发生位置的变化。属性：background-attachment取值：   1.scroll 默认值,滚动   2.fixed 固定</code></pre><p>6.背景图片定位</p><pre class="language-none"><code class="language-none">CODE作用：改变背景图在元素中的位置属性：background-position取值：   1.x y  具体的数值（px）     x:   背景图水平偏移距离   取值为正,向右移动   取值为负,向左移动 y:   背景图垂直偏移距离   取值为正,向下移动   取值为负,向上移动   2.x% y%     0% 0% 背景图在左上角 100% 100% 背景图在右下角 50% 50% 背景图在中间位置   3.关键字 x:left/center/right y:top/center/bottom ex:background-position:right top;</code></pre><p>7.背景简写属性</p><pre class="language-none"><code class="language-none">CODE在一个属性中指定背景的多个属性值属性：background取值：color url() repeat attachment positionex：  background:gray url(a.jpg);注意：  如果不设置其中某个属性值的话,该位置采用默认值。</code></pre><h3 id="8-渐变"><a href="#8-渐变" class="headerlink" title="8.渐变"></a>8.渐变</h3><p>1.什么是渐变</p><pre class="language-none"><code class="language-none">CODE渐变指定是多种颜色平缓变换的一种显示效果。</code></pre><p>2.渐变的主要因素</p><pre class="language-none"><code class="language-none">CODE1.色标：一种颜色及其出现的位置2.一个渐变是由多个色标组成（至少两个）</code></pre><p>3.渐变分类</p><pre class="language-none"><code class="language-none">CODE1.线性渐变  以直线的方向来填充效果2.径向渐变  以圆形的方式来实现填充3.重复渐变  将线性渐变或径向渐变 重复几次实现填充</code></pre><p>4.渐变详解</p><pre class="language-none"><code class="language-none">CODE1.线性渐变  属性：background-image  取值：linear-gradient(angle,color-point1,color-point2,....);    1.angle  表示渐变填充的方向或角度  取值：    1.关键字      to top 从下向上填充渐变色      to bottom 从上向下填充渐变色      to left 从右向左填充渐变色      to right 从左向右填充渐变色    2.角度值     0deg 从下向上填充,等同于to top     90deg 从左向右填充,等同于to right     180deg 从上到下填充,等同于to bottom     270deg 从右向左填充,等同于to left    2.color-point  色标：颜色 及其 位置  取值：颜色 以及 位置的组合,中间用空格分开  ex:    1.red 0%      在填充方向的开始位置处颜色为红色    2.green 50%      到填充方向一半的位置处,颜色变为绿色    3.blue 200px      到填充方向的200px的位置处,颜色变为蓝色2.径向渐变  属性：  background-image:radial-gradient([size at position],  color-point1,color-point2,...);  size at position:       size:半径,以px为单位的数值  position:圆心所在位置       1.x y 具体数值       2.x% y% 元素宽和高的占比       3.关键字         x:left,center,right     y:top,center,bottom  ex：    100px at right top 半径     右上角位置3.重复渐变  1.重复线性渐变    background-image:repeating-linear-gradient    (angle,color-point1,color-point2,...);color-point:位置一定要给绝对数值（px）,不要用相对单位%  2.重复径向渐变    background-image:repeating-radial-gradient    ([size at position],color-point1,color-point2,...);</code></pre><h3 id="9-浏览器兼容性"><a href="#9-浏览器兼容性" class="headerlink" title="9.浏览器兼容性"></a>9.浏览器兼容性</h3><pre class="language-none"><code class="language-none">CODE 各个浏览器的新版本都支持渐变属性对于不支持的浏览器版本,可以通过增加浏览器前缀的方式,让浏览器支持渐变属性Firefox:-moz-Chrome &amp; Sagari:-webkit-Opera:-o-IE:-ms-</code></pre><p>2.文本格式化属性<br>1.字体属性</p><pre class="language-none"><code class="language-none">CODE1.指定字体  属性：font-family  取值：字体名称,名称之间用逗号隔开  ex：  font-family:"微软雅黑",Arial,"黑体";2.字体大小  属性：font-size  取值：以px或pt为单位的数字3.字体加粗  属性：font-weight  取值：     1.bold 加粗（b,hn） 2.normal 正常 3.value 无单位的数字（整百倍）   400-900   400：等同于normal   900：等同于bold4.字体样式  属性：font-style  取值：     1.normal 正常显示  2.italic 斜体显示5.小型大写字母   将小写字符变成大写,但文本的大小与小写字符一致   属性：font-variant   取值：      1.normal 正常  2.small-caps 小型的大写字符6.字体属性简写  属性：font  取值：style variant weight size family;  注意：    如果用简写方式,必须设置family的值,否则无效。font:12px; 错误font:12px "黑体"; 正确</code></pre><p>2.文本格式</p><pre class="language-none"><code class="language-none">CODE1.文本颜色  属性：color  取值：合法的颜色值2.文本排列  作用：指定文本,行内,行内块元素的水平对齐方式。  属性：text-align  取值：left/center/right/justify(两端对齐)3.文字修饰（线条）  属性：text-decoration  取值：    none:无任何线条修饰underline:下划线修饰overline:上划线修饰    line-through:删除线修饰4.行高  作用:定义一行文本的高度  特点：如果行高的高度大于字体本身的大小,那么该行文本将在指定的行高内呈现垂直居中的效果。  属性:line-height  取值：以px为单位数值5.首行文本缩进  属性：text-indent  取值：以px为单位的数值6.文本阴影  属性：text-shadow  取值：h-shadow v-shadow blur color;</code></pre><h3 id="10-表格"><a href="#10-表格" class="headerlink" title="10.表格"></a>10.表格</h3><p>1.表格的常用属性</p><pre class="language-none"><code class="language-none">CODE1.边距属性：padding2.边框属性：border3.尺寸属性：width,height4.文本格式化属性：font-*,text-*,line-height5.背景属性：颜色,图片,渐变6.vertical-align  作用：指定单元格数据垂直对齐方式  取值：     top:上对齐 middle:居中对齐 bottom:下对齐 练习：创建网页,并在网页中添加表格     1.表格尺寸为400*400,4行4列; 2.每个单元格的尺寸为100*100,内容随意; 3.设置表格和单位元格的边框为1px solid #000; 4.设置每个单元格的左内边距为20px; 5.尝试为每个单元格增加上外边距15px。</code></pre><p>2.表格的特殊属性</p><pre class="language-none"><code class="language-none">CODE1.边框合并  取值：border-collapse  取值：     1.separate   默认值,即分离边框模式 2.collapse   边框合并2.边框边距  作用：设置单元格之间或单元格与表格之间的距离  属性：border-spacing  取值：    1.给定一个值：水平和垂直的间距相同2.给两个值：  第一个值 表示水平间距  第二个值 表示垂直间距注意：只有在边框分离模式下,边框边距才有效果,即border-collapse:separate时,border-spacing才有效。</code></pre><p>3.表格标题位置</p><pre class="language-none"><code class="language-none">CODE属性：caption-side取值：    1.top:默认值,标题在表格内容之上2.bottom:标题在表格内容之下</code></pre><p>4.显示规则</p><pre class="language-none"><code class="language-none">CODE作用：用来帮助浏览器指定如何布局一张表,也就是指定td尺寸的计算方式。属性：table-layout取值：   1.auto     默认值,即自动布局表格,列的尺寸实际上由内容来决定的。   2.fixed     固定表格布局,列的尺寸由设置的值为准自动表格布局VS固定表格布局：    1.自动表格布局  1.单元格的大小会适应内容  2.表格复杂时,加载速度较慢（缺点）  3.自动表格布局会比较灵活（优点）  4.适用于不确定每列大小时使用    2.固定表格布局  1.单元格的尺寸取决于设定的值  2.任何情况下都会加载显示表格（优点）  3.适用于确定每列大小时使用  4.固定表格布局不够灵活（缺点）</code></pre><h3 id="11-定位-浮动定位"><a href="#11-定位-浮动定位" class="headerlink" title="11.定位-浮动定位"></a>11.定位-浮动定位</h3><p>1.定位</p><pre class="language-none"><code class="language-none">CODE定位：指的是改变元素在页面中的默认位置</code></pre><p>2.定位的分类</p><pre class="language-none"><code class="language-none">CODE按照定位的效果,可以分成以下几类：   1.普通流定位（默认的定位方式）   2.浮动定位   3.相对定位   4.绝对定位   5.固定定位</code></pre><p>3.定位详解</p><pre class="language-none"><code class="language-none">CODE1.普通流定位  又称为文档流定位,页面中元素的默认定位方式  1.每个元素在页面中都有自己的空间  2.每个元素默认都是在其父元素的左上角开始显示  3.页面中的块级元素都是从上往下排列,每个元素独占一行  4.页面中的行内元素以及行内块都是按照从左到右的顺序来排列的  要解决的问题：让多个块级元素在一行中显示2.浮动定位  1.什么是浮动&amp;特点    1.元素一旦浮动起来,将不占据页面空间（脱离了文档流）,其它未浮动元素将上前补位。2.浮动元素会停靠在父元素的左边或右边,或其它已经浮动的元素的边缘上。3.浮动定位解决的问题：能够让多个块级元素在一行中显示。  2.语法    属性：float取值：   1.left     左浮动,让元素停靠在父元素的左边或挨着左侧已经浮动的元素   2.right     右浮动,让元素停靠在父元素的右边或挨着右侧已经浮动的元素   3.none     默认值,即无任何浮动效果</code></pre><h3 id="12-浮动引发的特殊效果"><a href="#12-浮动引发的特殊效果" class="headerlink" title="12.浮动引发的特殊效果"></a>12.浮动引发的特殊效果</h3><p>1.元素一旦浮动起来以后就会变成块级元素</p><pre class="language-none"><code class="language-none">CODE允许修改尺寸能正常处理垂直方向外边距</code></pre><p>2.当父元素显示不下所有已浮动元素时,最后一个将换行,但是,有可能被卡住；<br>3.元素一旦浮动起来后,宽度将以内容为主（未指定宽度情况下）；<br>4.文本,行内元素,行内块元素是采用环绕的方式来排列的,是不会别浮动元素压在底下的,而会巧妙的避开浮动元素。</p><h3 id="13-清除浮动带来的影响"><a href="#13-清除浮动带来的影响" class="headerlink" title="13.清除浮动带来的影响"></a>13.清除浮动带来的影响</h3><p>元素一旦浮动起来之后,就会对后续元素带来一定的位置影响（后续元素要上前补位）,如果后续元素不想被影响（不想补位）,那么就可以通过清除浮动的方式来解决<br>属性：clear<br>取值：</p><pre class="language-none"><code class="language-none">CODE1.left  清除当前元素前面的元素左浮动所带来的影响2.right  清除当前元素前面的元素右浮动所带来的影响3.both  清除当前元素前面元素任何一种浮动所带来的影响4.none  默认值,不做任何的清除浮动操作</code></pre><h3 id="14-浮动元素对父元素高度的影响"><a href="#14-浮动元素对父元素高度的影响" class="headerlink" title="14.浮动元素对父元素高度的影响"></a>14.浮动元素对父元素高度的影响</h3><p>1.元素的高度都是以未浮动元素的高度为准的,浮动元素是不占页面的高度的</p><pre class="language-none"><code class="language-none">CODE 解决父元素的高度方案如下：    1.直接设置父元素的高度  弊端：不是每次都知道父元素的高度2.设置父元素也浮动  弊端：不是任何时候父元素都需要浮动,而且浮动会影响后续元素3.为父元素设置overflow  取值：hidden或auto  弊端：如果有内容需要溢出显示的话,也会一同被隐藏4.在父元素中,追加空子元素(块级),并设置其clear:both;</code></pre><h3 id="15-显示"><a href="#15-显示" class="headerlink" title="15.显示"></a>15.显示</h3><p>1.显示方式</p><pre class="language-none"><code class="language-none">CODE1.什么是显示方式  决定了元素在网页中的表现形式（块级,行内,行内块）2.语法  属性：display  取值：     1.none 不显示元素-隐藏   特点：脱离文档流,不占据页面空间 2.block   让元素表现的和块级元素一致   特点：      独占一行,可是修改高宽 3.inline   让元素表现的和行内元素一致   特点：      不允许修改尺寸      多个元素在一行中显示      无法设置垂直外边距 4.inline-block   让元素表现的和行内块元素一致   特点：     多个元素在一行中显示,但是可以修改尺寸 5.table   让元素表现的与表格一致   特点：      尺寸以内容为准      每个元素独占一行      允许修改尺寸</code></pre><p>2.显示效果</p><pre class="language-none"><code class="language-none">CODE1.显示/隐藏  属性：visibility  取值：      1.visible:默认值,元素可见  2.hidden:元素不可见-隐藏  面试：display:none和visibility:hidden的区别        display:none 不占页面空间    visibility:hidden 占页面空间2.透明度  属性：opacity  取值：0.0（完全透明）~1.0（完全不透明）之间的小数3.垂直方向对齐方式  属性：vertical-align  场合：     1.表格中使用   取值：top/bottom/middle 2.图片（img）中使用   取值：      top：上      bottom：下      middle：中间      baseline:基线对齐,默认值</code></pre><h3 id="16-光标"><a href="#16-光标" class="headerlink" title="16.光标"></a>16.光标</h3><p>1.作用</p><pre class="language-none"><code class="language-none">CODE改变鼠标悬停在元素上时,鼠标的状态</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：cursor取值：    1.default: 默认2.pointer: 小手3.crosshair: +4.text: I5.wait: 等待6.help: 帮助 练习：   新建一个div元素,当鼠标移入到div上时,让光标变成小手状态。</code></pre><h3 id="17-列表"><a href="#17-列表" class="headerlink" title="17.列表"></a>17.列表</h3><p>1.列表项标记</p><pre class="language-none"><code class="language-none">CODE属性：list-style-type取值：   1.none   2.disc   3.circle   4.square</code></pre><p>2.列表项图像</p><pre class="language-none"><code class="language-none">CODE作用：使用自定义图像作为列表项标识属性：list-style-image取值：url(图像路径);</code></pre><p>3.列表项位置</p><pre class="language-none"><code class="language-none">CODE作用：将默认的列表项标识的位置,放到li里面属性：list-style-position取值：   1.outside 默认值,将标识显示在li外面的   2.inside 将标识放于li里面</code></pre><p>4.列表属性简写</p><pre class="language-none"><code class="language-none">CODE属性：list-style取值：type url() position;常用方式：list-style:none;列表的使用场合：   横向排列或纵向排列的内容,都可以使用列表来实现。</code></pre><h3 id="18-定位"><a href="#18-定位" class="headerlink" title="18.定位"></a>18.定位</h3><p>相对定位,绝对定位,固定定位<br>1.定位相关属性</p><pre class="language-none"><code class="language-none">CODE属性：position取值：   1.static:静态,默认值   2.relative:相对定位   3.absolute:绝对定位   4.fixed:固定定位</code></pre><p>2.偏移属性</p><pre class="language-none"><code class="language-none">CODEtop/bottom/left/right以上四个属性的取值均为数字ex:  top:150px 元素向下移动150px  left:20px 元素向右移动20px  right:-150px 元素向右移动150px注意：  只有已定位元素才能使用偏移属性</code></pre><p>3.定位详解</p><pre class="language-none"><code class="language-none">CODE1.相对定位  1.什么是相对定位    元素相对于它原来的位置偏移某个距离  2.使用场合    做元素位置微调时使用  3.语法      position:relative;      配合偏移属性来实现位置的移动      left:10px;      top:10px;2.绝对定位  1.什么是绝对定位&amp;特点    1.绝对定位的元素会脱离文档流-不占页面空间2.绝对定位的元素会相对于离他最近的,已定位的,祖先元素 去实现位置的初始化。3.如果没有已定位的祖先元素,那么该元素就相对于body去实现位置的初始化4.配合偏移属性 实现元素位置的修改  2.语法    position:absolute;配合偏移属性实现位置的修改  3.使用场合    1.有堆叠效果的元素2.弹出菜单  4.注意：    1.脱离文档流-不占据页面空间2.绝对定位元素会变成块级元素  5.堆叠顺序    一旦元素变为已定位元素的话,元素们则有可能出现堆叠的效果属性：z-index取值：无单位的数字,数字越大越靠上    注意：  1.只有已定位元素才能实现堆叠顺序的改变（z-index）  2.父子元素间,z-index无效,永远都是子元素压在父元素上方3.固定定位  1.什么是固定定位    将元素固定在网页的某个位置处,位置不会随着滚动条而发生改变,固定在可视区域中。  2.语法    position:fixed;配合偏移属性使用  注意：    1.固定定位的元素永远都是相对于body去实现位置的初始化和偏移。2.固定定位的元素会变成块级元素3.固定定位元素会脱离文档流-不占页面空间</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
