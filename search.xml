<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo 使用教程</title>
      <link href="/2021/10/27/hexo/"/>
      <url>/2021/10/27/hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="新建一篇博客"><a href="#新建一篇博客" class="headerlink" title="新建一篇博客"></a>新建一篇博客</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><h3 id="提交修改到my-blog上"><a href="#提交修改到my-blog上" class="headerlink" title="提交修改到my-blog上"></a>提交修改到my-blog上</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span class="token function">git</span> commit -m <span class="token string">"msg"</span><span class="token function">git</span> push origin master:my-blog</code></pre><h3 id="自动开启自动化部署"><a href="#自动开启自动化部署" class="headerlink" title="自动开启自动化部署"></a>自动开启自动化部署</h3><pre class="language-bash" data-language="bash"><code class="language-bash">打开https://jingwzeng.github.io就可以自动部署</code></pre><h3 id="表情包"><a href="#表情包" class="headerlink" title="表情包"></a>表情包</h3><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f616.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f623.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>表情包代码地址:<a href="https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-3">https://www.webfx.com/tools/emoji-cheat-sheet/#tabs-3</a></p><p><span class="github-emoji"><span>🆖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f196.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  <span class="github-emoji"><span>8⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0038-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🅰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f170.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-scrollbar滚动条用法</title>
      <link href="/2021/10/26/el-scrollbar-gun-dong-tiao-yong-fa/"/>
      <url>/2021/10/26/el-scrollbar-gun-dong-tiao-yong-fa/</url>
      
        <content type="html"><![CDATA[<h4 id="el-scrollbar-用法"><a href="#el-scrollbar-用法" class="headerlink" title="el-scrollbar 用法"></a>el-scrollbar 用法</h4><p>官方文档没有写出来。记录下！！！</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>list:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    &lt;el-scrollbar      wrap-style="font-weight:bold" // 这个貌似不起作用？一般不用      wrap-class="list" // 增加class      view-style="font-weight:bold;color:blue"// 增加行内样式，一般不用      view-class="view-box" // 增加class      :native="false"    &gt;      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value in num<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        {{ value }}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-scrollbar</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"Home"</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      num<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scss<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"><span class="token comment">/*展示列表的区域，超过200px出现滚动条*/</span><span class="token selector">.list</span> <span class="token punctuation">{</span>  <span class="token property">max-height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span><span class="token punctuation">}</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110261939203.png" alt="image-20211026193925087"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110261943517.png" alt="image-20211026194313480"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110261944105.png" alt="image-20211026194459067"></p>]]></content>
      
      
      <categories>
          
          <category> 滚动条 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滚动条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS基础</title>
      <link href="/2021/10/25/nodejs-ji-chu/"/>
      <url>/2021/10/25/nodejs-ji-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是-NodeJS"><a href="#什么是-NodeJS" class="headerlink" title="什么是 NodeJS"></a>什么是 NodeJS</h4><p>JS 是脚本语言，脚本语言都需要一个解析器才能运行。对于写在 HTML 页面里的 JS，浏览器充当了解析器的角色。而对于需要独立运行的 JS，NodeJS 就是一个解析器。</p><p>每一种解析器都是一个运行环境，不但允许 JS 定义各种数据结构，进行各种计算，还允许 JS 使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的 JS 的用途是操作 DOM，浏览器就提供了<code>document</code>之类的内置对象。而运行在 NodeJS 中的 JS 的用途是操作磁盘文件或搭建 HTTP 服务器，NodeJS 就相应提供了<code>fs</code>、<code>http</code>等内置对象。</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>NodeJS 遵循的模块化规范是<code>commonJS</code>。其原理及使用规则见 xxx。<code>NodeJS</code>主模块就是通过命令行参数传递给<code>NodeJS</code>启动程序的模块。一个模块中的<code>JS</code>代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。一个<code>JS</code>模块里面的变量因为会被缓存，所以在多处调用的地方值是会互相影响的。</p><h4 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h4><p>按照以下规则解析路径，直到找到模块位置</p><ol><li><p>内置模块</p><p>如果传递给<code>require</code>函数的是 NodeJS 内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如<code>require('fs')</code>。</p></li><li><p>node_modules 目录</p><p>NodeJS 定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require('foo/bar')</code>方式加载模块时，则 NodeJS 依次尝试使用以下路径。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">/</span>home<span class="token operator">/</span>user<span class="token operator">/</span>node_modules<span class="token operator">/</span>foo<span class="token operator">/</span>bar<span class="token operator">/</span>home<span class="token operator">/</span>node_modules<span class="token operator">/</span>foo<span class="token operator">/</span>bar<span class="token operator">/</span>node_modules<span class="token operator">/</span>foo<span class="token operator">/</span>bar</code></pre></li><li><p>NODE_PATH 环境变量</p><p>与 PATH 环境变量类似，NodeJS 允许通过 NODE_PATH 环境变量来指定额外的模块搜索路径。NODE_PATH 环境变量中包含一到多个目录路径，路径之间在 Linux 下使用<code>:</code>分隔，在 Windows 下使用<code>;</code>分隔。例如定义了以下 NODE_PATH 环境变量：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token constant">NODE_PATH</span><span class="token operator">=</span><span class="token operator">/</span>home<span class="token operator">/</span>user<span class="token operator">/</span>lib<span class="token punctuation">;</span><span class="token operator">/</span>home<span class="token operator">/</span>lib</code></pre><p>当使用<code>require('foo/bar')</code>的方式加载模块时，则 NodeJS 依次尝试以下路径。</p><pre class="language-none"><code class="language-none">/home/user/lib/foo/bar/home/lib/foo/bar</code></pre></li></ol><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>我们利用<code>npm install [xxx]</code>安装的就是包，其实就是多个模块的集合。当我们引入包的使用，利用<code>require</code>进行引入。每一包都是有一个入口文件的，如果模块的文件名字是<code>index.js</code>的话，引入的时候就可以省略掉<code>index.js</code>（这个和 ES6 的模块规则是一样的）。<code>npm</code>就是一种包管理工具。其次比较常用的还有<code>yarn</code>。需要注意的是<code>npm install xxx --S</code>安装的包是用作生产依赖，<code>npm install xxx --D</code>安装的包是用作开发依赖。(记忆：–S（保存）–D(dev 开发))。</p><h4 id="😎-debug-的使用"><a href="#😎-debug-的使用" class="headerlink" title="😎 debug 的使用"></a>😎 debug 的使用</h4><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110271639084.png" alt="image-20211027163957024"></p><p>在调试的时候呢。特别容易进入第三方库中。比如<code>JQuery</code>。这个时候如果你已经进入了，那就利用【单步跳出】的方法，跳出来。如果你还没有进入，那就利用【单步跳过】的方法直接执行该函数，跳到该函数的下一条语句。</p>]]></content>
      
      
      <categories>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父子组件双向绑定</title>
      <link href="/2021/10/25/fu-zi-zu-jian-shuang-xiang-bang-ding/"/>
      <url>/2021/10/25/fu-zi-zu-jian-shuang-xiang-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="组件之间的双向绑定"><a href="#组件之间的双向绑定" class="headerlink" title="组件之间的双向绑定"></a>组件之间的双向绑定</h2><p>最近在学习<code>electron+vue</code>仿有道云笔记<code>markdown</code>区域的代码中，遇到父组件与子组件数据需要同步变化的问题。</p><p>（可以利用组件间的<code>v-model</code>或者<code>.sync</code>修饰符）故做此总结。</p><h3 id="利用-v-model"><a href="#利用-v-model" class="headerlink" title="利用 v-model"></a>利用 v-model</h3><p>通常子组件更新某个变量并需要告知父组件时，需要子组件<code>$emit</code>触发事件，然后父组件<code>$on</code>监听该事件再去改变值。可以利用<code>v-model</code>的使用原理来使组件之间利用<code>v-model</code>进行双向绑定。</p><blockquote><ol><li><p> 父组件通过<code>v-model</code>绑定一个变量传给子组件</p></li><li><p> 子组件通过<code>props['value']</code>接收。注意是<code>value</code></p></li><li><p> 子组件通过<code>$emit('input',XX)</code>去改变父组件中<code>v-model</code>绑定的变量。注意是<code>input</code>事件</p></li></ol></blockquote><h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><p><code>Vue</code>根据元素决定如何监听和处理数据。对于<code>input</code>元素，您可以这样使用<code>v-model</code>：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"email"</span> <span class="token operator">/</span><span class="token operator">&gt;</span></code></pre><p><code>v-model</code> 翻译成这样：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>input <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"email"</span> @input<span class="token operator">=</span><span class="token string">"(e) =&gt; (email = e.target.value)"</span> <span class="token operator">/</span><span class="token operator">&gt;</span></code></pre><h4 id="v-model-实现方案"><a href="#v-model-实现方案" class="headerlink" title="v-model 实现方案"></a>v-model 实现方案</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 子组件</span><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>input @input<span class="token operator">=</span><span class="token string">"handleInput"</span> <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">//</span>  这个事件不一定是input事件，只要可以改变content值的事件就可以<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name：<span class="token string">'BasicInput'</span><span class="token punctuation">,</span>  prop<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'value'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      content<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">handleInput</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span> <span class="token comment">// 这个事件名字一定得失input事件</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 父组件</span><span class="token operator">&lt;</span>basic<span class="token operator">-</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"email"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>basic<span class="token operator">-</span>input<span class="token operator">&gt;</span></code></pre><p>实现方案如上。</p><h4 id="定制-v-model-的-prop-和-event"><a href="#定制-v-model-的-prop-和-event" class="headerlink" title="定制 v-model 的 prop 和 event"></a>定制 v-model 的 prop 和 event</h4><p>因为有时候<code>value</code>或者<code>input</code>需要作其他的用处，这个时候就可以定制其他变量来做啦。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 子组件</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  model<span class="token operator">:</span> <span class="token punctuation">{</span>    prop<span class="token operator">:</span> <span class="token string">"hidden"</span><span class="token punctuation">,</span>    event<span class="token operator">:</span> <span class="token string">"blur"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"hidden"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//此处不能漏掉</span>  methods<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">handleInput</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"blur"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 父组件</span><span class="token operator">&lt;</span>basic<span class="token operator">-</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"email"</span> <span class="token operator">/</span><span class="token operator">&gt;</span></code></pre><p>vue 自动将其转换为：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>basic<span class="token operator">-</span>input <span class="token operator">:</span>hidden<span class="token operator">=</span><span class="token string">"email"</span> @bulr<span class="token operator">=</span><span class="token string">"(e) =&gt; (email = e.target.value)"</span> <span class="token operator">/</span><span class="token operator">&gt;</span></code></pre><h3 id="v-model-与-sync-区别"><a href="#v-model-与-sync-区别" class="headerlink" title="v-model 与.sync 区别"></a>v-model 与.sync 区别</h3><h4 id="v-model-本质"><a href="#v-model-本质" class="headerlink" title="v-model 本质"></a>v-model 本质</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>v<span class="token operator">-</span>model写法<span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>component type<span class="token operator">=</span><span class="token string">"text"</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"value"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>展开语法糖后的写法<span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>component type<span class="token operator">=</span><span class="token string">"text"</span>  <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"value"</span>  @input<span class="token operator">=</span><span class="token string">"value = $event.target.value"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>默认针对原生组件input事件，但是如果子组件定义了针对事件model<span class="token operator">:</span> <span class="token punctuation">{</span>        prop<span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span>        event<span class="token operator">:</span> <span class="token string">"update"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>则编译为<span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>component type<span class="token operator">=</span><span class="token string">"text"</span>  <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"value"</span>  @update<span class="token operator">=</span><span class="token string">"(val) =&gt; value = val"</span><span class="token operator">&gt;</span></code></pre><h4 id="sync-本质"><a href="#sync-本质" class="headerlink" title=".sync 本质"></a>.sync 本质</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>语法糖<span class="token punctuation">.</span>sync<span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>component <span class="token operator">:</span>value<span class="token punctuation">.</span>sync<span class="token operator">=</span><span class="token string">"value"</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>编译后的写法<span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>my<span class="token operator">-</span>component  <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"msg"</span>  @update<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"(val) =&gt; value = val"</span><span class="token operator">&gt;</span></code></pre><blockquote><p>总结：两者本质是一样的，并没有任何区别：<code>"监听一个触发事件"="(val) =&gt; value = val"</code></p></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>只不过<code>v-model</code>默认对应的是<code>input</code>或者<code>textarea</code>等组件的<code>input</code>事件，如果在子组件利用<code>update</code>替换这个<code>input</code>事件，其本质和<code>.sync</code>修饰符一模一样。比较单一，不能有多个。</li></ul><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 子组件可以用自定义事件，来替换v-model默认对应的原生input事件，只不过我们需要在子组件手动 $emit</span>model<span class="token operator">:</span> <span class="token punctuation">{</span>        prop<span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span>        event<span class="token operator">:</span> <span class="token string">"update"</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><ul><li>一个组件可以多个属性用<code>.sync</code>修饰符，可以同时”双向绑定多个<code>prop</code>，而并不像<code>v-model</code>那样，一个组件只能有一个。</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
          <category> 组件双向绑定 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue2 </tag>
            
            <tag> 组件双向绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy和Reflect</title>
      <link href="/2021/10/21/proxy-he-reflect/"/>
      <url>/2021/10/21/proxy-he-reflect/</url>
      
        <content type="html"><![CDATA[<h1 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h1><blockquote><p>转载于<a href="https://juejin.cn/post/6844904090116292616#heading-0">Proxy 和 Reflect</a></p></blockquote><p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p><p>Proxy 用于许多库和某些浏览器框架。在本章中，我们将看到许多实际应用。</p><p>语法：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数。</li><li><code>handler</code> —— 代理配置：带有“钩子”（“traps”，即拦截操作的方法）的对象。比如 <code>get</code> 钩子用于读取 <code>target</code> 属性，<code>set</code> 钩子写入 <code>target</code> 属性等等。</li></ul><p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的钩子，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。</p><p>首先，让我们创建一个没有任何钩子的代理：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空的handler对象</span>proxy<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 写入 Proxy 对象 (1)</span><span class="token function">alert</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 5，test属性出现在了 target 上！</span><span class="token function">alert</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 还是 5，我们也可以从 proxy 对象读取它 (2)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> proxy<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回 test，迭代也正常工作！ (3)</span></code></pre><p>由于没有钩子，所有对 <code>proxy</code> 的操作都直接转发给 <code>target</code>。</p><ol><li> 写入操作 <code>proxy.test=</code> 会将值写入 <code>target</code>。</li><li> 读取操作 <code>proxy.test</code> 会从 <code>target</code> 返回对应的值。</li><li> 迭代 <code>proxy</code> 会从 <code>target</code> 返回对应的值。</li></ol><p>我们可以看到，没有任何钩子，<code>proxy</code> 是一个 <code>target</code> 的透明包装.</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/14/170d948bfea2c89e~tplv-t2oaga2asx-watermark.awebp"></p><p><code>Proxy</code> 是一种特殊的“奇异对象”。它没有自己的属性。如果 <code>handler</code> 为空，则透明地将操作转发给 <code>target</code>。</p><p>要激活更多功能，让我们添加钩子。</p><p>我们可以用它们拦截什么？</p><p>对于对象的大多数操作，JavaScript 规范中都有一个所谓的“内部方法”，它描述了最底层的工作方式。 例如 <code>[[Get]]</code>，用于读取属性的内部方法， <code>[[Set]]</code>，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。</p><p>Proxy 钩子会拦截这些方法的调用。它们在下表中列出。</p><p>对于每个内部方法，此表中都有一个钩子：可用于添加到 <code>new Proxy</code> 时的 <code>handler</code> 参数中以拦截操作的方法名称：</p><table><thead><tr><th>内部方法</th><th>Handler 方法</th><th>何时触发</th></tr></thead><tbody><tr><td><code>[[Get]]</code></td><td><code>get</code></td><td>读取属性</td></tr><tr><td><code>[[Set]]</code></td><td><code>set</code></td><td>写入属性</td></tr><tr><td><code>[[HasProperty]]</code></td><td><code>has</code></td><td><code>in</code> 运算符</td></tr><tr><td><code>[[Delete]]</code></td><td><code>deleteProperty</code></td><td><code>delete</code> 操作</td></tr><tr><td><code>[[Call]]</code></td><td><code>apply</code></td><td>proxy 对象作为函数被调用</td></tr><tr><td><code>[[Construct]]</code></td><td><code>construct</code></td><td><code>new</code> 操作</td></tr><tr><td><code>[[GetPrototypeOf]]</code></td><td><code>getPrototypeOf</code></td><td><code>Object.getPrototypeOf</code></td></tr><tr><td><code>[[SetPrototypeOf]]</code></td><td><code>setPrototypeOf</code></td><td><code>Object.setPrototypeOf</code></td></tr><tr><td><code>[[IsExtensible]]</code></td><td><code>isExtensible</code></td><td><code>Object.isExtensible</code></td></tr><tr><td><code>[[PreventExtensions]]</code></td><td><code>preventExtensions</code></td><td><code>Object.preventExtensions</code></td></tr><tr><td><code>[[DefineOwnProperty]]</code></td><td><code>defineProperty</code></td><td><code>Object.defineProperty</code>, <code>Object.defineProperties</code></td></tr><tr><td><code>[[GetOwnProperty]]</code></td><td><code>getOwnPropertyDescriptor</code></td><td><code>Object.getOwnPropertyDescriptor</code>, <code>for..in</code>, <code>Object.keys/values/entries</code></td></tr><tr><td><code>[[OwnPropertyKeys]]</code></td><td><code>ownKeys</code></td><td><code>Object.getOwnPropertyNames</code>, <code>Object.getOwnPropertySymbols</code>, <code>for..in</code>, <code>Object/keys/values/entries</code></td></tr></tbody></table><p>Invariants</p><p>JavaScript 强制执行某些不变式————当必须由内部方法和钩子来完成操作时。</p><p>其中大多数用于返回值：</p><ul><li><code>[[Set]]</code> 如果值已成功写入，则必须返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>[[Delete]]</code> 如果已成功删除该值，则必须返回 <code>true</code>，否则返回 <code>false</code>。</li><li>……依此类推，我们将在下面的示例中看到更多内容。</li></ul><p>还有其他一些不变量，例如：</p><ul><li><code>[[GetPrototypeOf]]</code>, 应用于代理对象的，必须返回与 <code>[[GetPrototypeOf]]</code> 应用于被代理对象相同的值。换句话说，读取代理对象的原型必须始终返回被代理对象的原型。</li></ul><p>钩子可以拦截这些操作，但是必须遵循这些规则。</p><p>不变量确保语言功能的正确和一致的行为。完整的不变量列表在<a href="https://link.juejin.cn/?target=https://tc39.es/ecma262/%23sec-proxy-object-internal-methods-and-internal-slots" title="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">规范</a>。如果您不做奇怪的事情，就不会违反它们。</p><p>让我们看看实际示例中的工作原理。</p><h2 id="带-“get”-钩子的默认值"><a href="#带-“get”-钩子的默认值" class="headerlink" title="带 “get” 钩子的默认值"></a>带 “get” 钩子的默认值</h2><p>最常见的钩子是用于读取/写入属性。</p><p>要拦截读取操作，<code>handler</code> 应该有 <code>get(target, property, receiver)</code> 方法。</p><p>读取属性时触发该方法，参数如下：</p><ul><li><code>target</code> —— 是目标对象，该对象作为第一个参数传递给 <code>new Proxy</code>，</li><li><code>property</code> —— 目标属性名,</li><li><code>receiver</code> —— 如果目标属性是一个 getter 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从代理继承，则是从该代理继承的对象）。现在我们不需要此参数，因此稍后将对其进行详细说明。</li></ul><p>让我们用 <code>get</code> 实现对象的默认值。</p><p>我们将创建一个对不存在的数组项返回 0 的数组。</p><p>通常，当人们尝试获取不存在的数组项时，他们会得到 <code>undefined</code>, 但是我们会将常规数组包装到代理中，以捕获读取操作并在没有此类属性的情况下返回 <code>0</code>：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 默认值</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span class="token function">alert</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 (没有这样的元素)</span></code></pre><p>如我们所见，使用 <code>get</code> 钩子非常容易。</p><p>我们可以用 <code>Proxy</code> 来实现任何读取默认值的逻辑。</p><p>想象一下，我们有一本词典，上面有短语及其翻译：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> dictionary <span class="token operator">=</span> <span class="token punctuation">{</span>  Hello<span class="token operator">:</span> <span class="token string">"Hola"</span><span class="token punctuation">,</span>  Bye<span class="token operator">:</span> <span class="token string">"Adiós"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">"Hello"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hola</span><span class="token function">alert</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">"Welcome"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><p>现在，如果没有短语，从 <code>dictionary</code> 读取将返回 <code>undefined</code>。但实际上，返回一个未翻译短语通常比 <code>undefined</code> 要好。因此，让我们在这种情况下返回一个未翻译的短语，而不是 <code>undefined</code>。</p><p>为此，我们将包装 <code>dictionary</code> 进一个拦截读取操作的代理：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> dictionary <span class="token operator">=</span> <span class="token punctuation">{</span>  Hello<span class="token operator">:</span> <span class="token string">"Hola"</span><span class="token punctuation">,</span>  Bye<span class="token operator">:</span> <span class="token string">"Adiós"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> phrase<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 拦截读取属性操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>phrase <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//如果字典包含该短语</span>      <span class="token keyword">return</span> target<span class="token punctuation">[</span>phrase<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 返回译文</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment">// 否则返回未翻译的短语</span>      <span class="token keyword">return</span> phrase<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在字典中查找任意短语！</span><span class="token comment">// 最坏的情况也只是它们没有被翻译。</span><span class="token function">alert</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">"Hello"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hola</span><span class="token function">alert</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token string">"Welcome to Proxy"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Welcome to Proxy</span></code></pre><p>请注意代理如何覆盖变量：</p><pre class="language-js" data-language="js"><code class="language-js">dictionary <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>代理应该在所有地方都完全替代了目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</p><h2 id="使用-“set”-钩子进行验证"><a href="#使用-“set”-钩子进行验证" class="headerlink" title="使用 “set” 钩子进行验证"></a>使用 “set” 钩子进行验证</h2><p>假设我们想要一个专门用于数字的数组。如果添加了其他类型的值，则应该抛出一个错误。</p><p>当写入属性时 <code>set</code> 钩子触发。</p><p><code>set(target, property, value, receiver)</code>:</p><ul><li><code>target</code> —— 是目标对象，该对象作为第一个参数传递给 <code>new Proxy</code>，</li><li><code>property</code> —— 目标属性名称，</li><li><code>value</code> —— 目标属性要设置的值，</li><li><code>receiver</code> —— 与 <code>get</code> 钩子类似，仅与 setter 访问器相关。</li></ul><p>如果写入操作成功，<code>set</code> 钩子应该返回 <code>true</code>，否则返回 <code>false</code>（触发 <code>TypeError</code>）。</p><p>让我们用它来验证新值：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>numbers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment">// (*)</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 拦截写入操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">==</span> <span class="token string">"number"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加成功</span>numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加成功</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Length is: "</span> <span class="token operator">+</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>numbers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError （proxy 的 `set` 操作返回 false）</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"This line is never reached (error in the line above)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>请注意：Array 的内建方法依然生效！ 值使用 <code>push</code> 方法添加入数组。添加值时，<code>length</code> 属性会自动增加。我们的代理对象 Proxy 不会破坏任何东西。</p><p>我们不必重写诸如 <code>push</code> 和 <code>unshift</code> 等添加元素的数组方法，就可以在其中添加检查，因为在内部它们使用代理所拦截的 <code>[[Set]]</code> 操作。</p><p>因此，代码简洁明了。</p><p>别忘了返回 <code>true</code></p><p>如上所述，要保持不变式。</p><p>对于 <code>set</code>操作, 它必须在成功写入时返回 <code>true</code>。</p><p>如果我们忘记这样做或返回任何 falsy 值，则该操作将触发 <code>TypeError</code>。</p><h2 id="使用-“ownKeys”-和-“getOwnPropertyDescriptor”-进行迭代"><a href="#使用-“ownKeys”-和-“getOwnPropertyDescriptor”-进行迭代" class="headerlink" title="使用 “ownKeys” 和 “getOwnPropertyDescriptor” 进行迭代"></a>使用 “ownKeys” 和 “getOwnPropertyDescriptor” 进行迭代</h2><p><code>Object.keys</code>，<code>for..in</code> 循环和大多数其他遍历对象属性的方法都使用 <code>[[OwnPropertyKeys]]</code>内部方法（由 <code>ownKeys</code> 钩子拦截) 来获取属性列表。</p><p>这些方法在细节上有所不同：</p><ul><li><code>Object.getOwnPropertyNames(obj)</code> 返回非 Symbol 键。</li><li><code>Object.getOwnPropertySymbols(obj)</code> 返回 symbol 键。</li><li><code>Object.keys/values()</code> 返回带有 <code>enumerable</code> 标记的非 Symbol 键值对（属性标记在章节 属性标志和属性描述符 有详细描述).</li><li><code>for..in</code> 循环遍历所有带有 <code>enumerable</code> 标记的非 Symbol 键，以及原型对象的键。</li></ul><p>……但是所有这些都从该列表开始。</p><p>在下面的示例中，我们使用 <code>ownKeys</code> 钩子拦截 <code>for..in</code> 对 <code>user</code> 的遍历，还使用 <code>Object.keys</code> 和 <code>Object.values</code> 来跳过以下划线 <code>_</code> 开头的属性：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>  _password<span class="token operator">:</span> <span class="token string">"***"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// "ownKeys" 过滤掉 _password</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name，然后是 age</span><span class="token comment">// 对这些方法同样有效：</span><span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name,age</span><span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John,30</span></code></pre><p>到目前为止，它仍然有效。</p><p>虽然，如果我们返回对象中不存在的键，<code>Object.keys</code> 并不会列出该键：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;empty&gt;</span></code></pre><p>为什么？原因很简单：<code>Object.keys</code> 仅返回带有 <code>enumerable</code> 标记的属性。为了检查它， 该方法会对每个属性调用 <code>[[GetOwnProperty]]</code> 来获得属性描述符。在这里，由于没有属性，其描述符为空，没有 <code>enumerable</code> 标记，因此它将略过。</p><p>为了让 <code>Object.keys</code> 返回一个属性，我们要么需要将该属性及 <code>enumerable</code> 标记存入对象，或者我们可以拦截对它的调用 <code>[[GetOwnProperty]]</code> (钩子<code>getOwnPropertyDescriptor</code> 会执行此操作)，并返回描述符 enumerable: true。</p><p>这是一个例子：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 一旦被调用，就返回一个属性列表</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 被每个属性调用</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      <span class="token comment">/* 其他属性，类似于 "value:..." */</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a, b, c</span></code></pre><p>让我们再次注意：如果该属性在对象中不存在，则我们只需要拦截 <code>[[GetOwnProperty]]</code>。</p><h2 id="具有-“deleteProperty”-和其他钩子的受保护属性"><a href="#具有-“deleteProperty”-和其他钩子的受保护属性" class="headerlink" title="具有 “deleteProperty” 和其他钩子的受保护属性"></a>具有 “deleteProperty” 和其他钩子的受保护属性</h2><p>有一个普遍的约定，即下划线 <code>_</code> 前缀的属性和方法是内部的。不应从对象外部访问它们。</p><p>从技术上讲，这是可能的：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>  _password<span class="token operator">:</span> <span class="token string">"secret"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>_password<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// secret</span></code></pre><p>让我们使用代理来防止对以 <code>_</code> 开头的属性的任何访问。</p><p>我们需要以下钩子：</p><ul><li><code>get</code> 读取此类属性时抛出错误，</li><li><code>set</code> 写入属性时抛出错误，</li><li><code>deleteProperty</code> 删除属性时抛出错误，</li><li><code>ownKeys</code> 在使用 <code>for..in</code> 和类似 <code>Object.keys</code> 的方法时排除以 <code>_</code> 开头的属性。</li></ul><p>代码如下：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>  _password<span class="token operator">:</span> <span class="token string">"***"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Access denied"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span> <span class="token comment">// (*)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 拦截写入操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Access denied"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 拦截属性删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Access denied"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">delete</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">ownKeys</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 拦截读取属性列表</span>    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span>key<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// “get” 不允许读取 _password</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>_password<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Access denied</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//  “set” 不允许写入 _password</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  user<span class="token punctuation">.</span>_password <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span> <span class="token comment">// Error: Access denied</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// “deleteProperty” 不允许删除 _password 属性</span><span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token keyword">delete</span> user<span class="token punctuation">.</span>_password<span class="token punctuation">;</span> <span class="token comment">// Error: Access denied</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// “ownKeys” 过滤排除 _password</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name</span></code></pre><p>请注意在行 <code>(*)</code> 中 <code>get</code> 钩子的重要细节：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span>  <span class="token keyword">let</span> value <span class="token operator">=</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span> <span class="token comment">// (*)</span><span class="token punctuation">}</span></code></pre><p>为什么我们需要一个函数调用 <code>value.bind(target)</code>？</p><p>原因是对象方法（例如 <code>user.checkPassword()</code>）必须能够访问 <code>_password</code>：</p><pre class="language-js" data-language="js"><code class="language-js">user <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// ...</span>  <span class="token function">checkPassword</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//对象方法必须能读取 _password</span>    <span class="token keyword">return</span> value <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_password<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对 <code>user.checkPassword()</code> 的一个调用会调用代理对象 <code>user</code> 作为 <code>this</code>（点运算符之前的对象会成为 <code>this</code>），因此，当它尝试访问 <code>this._password</code> 时 <code>get</code> 钩子将激活（它在读取任何属性时触发）并抛出错误。</p><p>因此，我们在行 <code>(*)</code> 中将对象方法的上下文绑定到原始对象，<code>target</code>。然后，它们将来的调用将使用 <code>target</code> 作为 <code>this</code>，不触发任何钩子。</p><p>该解决方案通常可行，但并不理想，因为一种方法可能会将未代理的对象传递到其他地方，然后我们会陷入困境：原始对象在哪里，代理的对象在哪里？</p><p>此外，一个对象可能会被代理多次（多个代理可能会对该对象添加不同的“调整”），并且如果我们将未包装的对象传递给方法，则可能会产生意想不到的后果。</p><p>因此，在任何地方都不应使用这种代理。</p><p>类的私有属性</p><p>现代 Javascript 引擎原生支持私有属性，其以 <code>#</code> 作为前缀。这在章节 私有的和受保护的属性和方法 中有详细描述。Proxy 并不是必需的。</p><p>但是，此类属性有其自身的问题。特别是，它们是不可继承的。</p><h2 id="“In-range”-及-“has”-钩子"><a href="#“In-range”-及-“has”-钩子" class="headerlink" title="“In range” 及 “has” 钩子"></a>“In range” 及 “has” 钩子</h2><p>让我们来看更多示例。</p><p>我们有一个 range 对象：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token punctuation">{</span>  start<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  end<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>我们想使用 <code>in</code> 运算符来检查数字是否在 <code>range</code> 范围内。</p><p>该 <code>has</code> 钩子拦截 <code>in</code> 调用。</p><p><code>has(target, property)</code></p><ul><li><code>target</code> —— 是目标对象，作为第一个参数传递给 <code>new Proxy</code></li><li><code>property</code> —— 属性名称</li></ul><p>示例如下</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token punctuation">{</span>  start<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  end<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>range <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>range<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> prop <span class="token operator">&gt;=</span> target<span class="token punctuation">.</span>start <span class="token operator">&amp;&amp;</span> prop <span class="token operator">&lt;=</span> target<span class="token punctuation">.</span>end<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token keyword">in</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">50</span> <span class="token keyword">in</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre><p>漂亮的语法糖，不是吗？而且实现起来非常简单。</p><h2 id="包装函数：”apply”"><a href="#包装函数：”apply”" class="headerlink" title="包装函数：”apply”"></a>包装函数：”apply”</h2><p>我们也可以将代理包装在函数周围。</p><p><code>apply(target, thisArg, args)</code> 钩子能使代理以函数的方式被调用：</p><ul><li><code>target</code> 是目标对象（函数是 JavaScript 中的对象）</li><li><code>thisArg</code> 是 <code>this</code> 的值</li><li><code>args</code> 是参数列表</li></ul><p>例如，让我们回想一下 <code>delay(f, ms)</code> 装饰器，它是我们在 <a href="https://juejin.cn/post/6844904089680084999" title="https://juejin.cn/post/6844904089680084999">装饰者模式，call/apply </a>一章中完成的。</p><p>在该章中，我们没有用 proxy 来实现它。调用 <code>delay(f, ms)</code> 返回一个函数，该函数会将在 <code>ms</code>毫秒后把所有调用转发到 <code>f</code>。</p><p>这是以前的基于函数的实现：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 返回一个超时后调用 f 函数的包装器</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// (*)</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">f</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 这次包装后，sayHi 在3秒后被调用</span>sayHi <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, John! （3秒后）</span></code></pre><p>正如我们已经看到的那样，大多数情况下都是可行的。包装函数 <code>(*)</code> 在超时后执行调用。</p><p>但是包装函数不会转发属性读/写操作或其他任何操作。包装后，无法访问原有函数的属性，比如 <code>name</code>，<code>length</code>和其他：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">f</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">alert</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 （函数的 length 是其声明中的参数个数）</span>sayHi <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 （在包装器声明中，参数个数为0)</span></code></pre><p><code>Proxy</code> 功能强大得多，因为它将所有东西转发到目标对象。</p><p>让我们使用 <code>Proxy</code> 而不是包装函数：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> thisArg<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">target</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>sayHi <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 (*) proxy 转发“获取 length” 操作到目标对象</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, John! （3秒后）</span></code></pre><p>结果是相同的，但现在不仅调用，而且代理上的所有操作都转发到原始函数。所以 sayHi.length 在 <code>(*)</code> 行包装后正确返回结果(*)。</p><p>我们有一个“更丰富”的包装器。</p><p>还存在其他钩子：完整列表在本章的开头。它们的使用模式与上述类似。</p><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p><code>Reflect</code> 是一个内置对象，可简化的创建 <code>Proxy</code>。</p><p>以前的内部方法，比如<code>[[Get]]</code>，<code>[[Set]]</code> 等等都只是规范，不能直接调用。</p><p><code>Reflect</code> 对象使调用这些内部方法成为可能。它的方法是内部方法的最小包装。</p><p>这是 <code>Reflect</code> 执行相同操作和调用的示例：</p><table><thead><tr><th>操作</th><th><code>Reflect</code> 调用</th><th>内部方法</th></tr></thead><tbody><tr><td><code>obj[prop]</code></td><td><code>Reflect.get(obj, prop)</code></td><td><code>[[Get]]</code></td></tr><tr><td><code>obj[prop] = value</code></td><td><code>Reflect.set(obj, prop, value)</code></td><td><code>[[Set]]</code></td></tr><tr><td><code>delete obj[prop]</code></td><td><code>Reflect.deleteProperty(obj, prop)</code></td><td><code>[[Delete]]</code></td></tr><tr><td><code>new F(value)</code></td><td><code>Reflect.construct(F, value)</code></td><td><code>[[Construct]]</code></td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>例如：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span></code></pre><p>尤其是，<code>Reflect</code> 允许我们使用函数（<code>Reflect.construct</code>，<code>Reflect.deleteProperty</code>，……）执行操作（<code>new</code>，<code>delete</code>，……）。这是一个有趣的功能，但是这里还有一点很重要。</p><p><strong>对于每个可被 <code>Proxy</code> 捕获的内部方法，<code>Reflect</code> 都有一个对应的方法 Reflect，其名称和参数与 <code>Proxy</code> 钩子相同。</strong></p><p>因此，我们可以用 <code>Reflect</code> 来将操作转发到原始对象。</p><p>在此示例中，钩子<code>get</code> 和 <code>set</code> 透明地（好像它们都不存在）将读/写操作转发到对象，并显示一条消息：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">GET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (1)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> val<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (2)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> name <span class="token operator">=</span> user<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// shows "GET name"</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Pete"</span><span class="token punctuation">;</span> <span class="token comment">// shows "SET name=Pete"</span></code></pre><p>这里:</p><ul><li><code>Reflect.get</code> 读取一个对象属性</li><li><code>Reflect.set</code> 写入对象属性，成功返回 <code>true</code> ，否则返回 <code>false</code></li></ul><p>就是说，一切都很简单：如果钩子想要将调用转发给对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了。</p><p>在大多数情况下，我们可以不使用 <code>Reflect</code> 完成相同的事情，例如，使用<code>Reflect.get(target, prop, receiver)</code> 读取属性可以替换为 <code>target[prop]</code>。尽管有一些细微的差别。</p><h3 id="代理一个-getter"><a href="#代理一个-getter" class="headerlink" title="代理一个 getter"></a>代理一个 getter</h3><p>让我们看一个示例，说明为什么 <code>Reflect.get</code> 更好。我们还将看到为什么 <code>get/set</code> 有第四个参数 <code>receiver</code>，而我们以前没有使用过它。</p><p>我们有一个带有一个 <code>_name</code> 属性和一个 getter 的对象 <code>user</code>。</p><p>这是一个 Proxy：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  _name<span class="token operator">:</span> <span class="token string">"Guest"</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>userProxy<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Guest</span></code></pre><p>该 <code>get</code> 钩子在这里是“透明的”，它返回原来的属性，不会做别的任何事情。对于我们的示例而言，这就足够了。</p><p>一切似乎都很好。但是让我们将示例变得更加复杂。</p><p>另一个对象 <code>admin</code>从 <code>user</code> 继承后，我们可以观察到错误的行为：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  _name<span class="token operator">:</span> <span class="token string">"Guest"</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> target<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// (*) target = user</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span>  _name<span class="token operator">:</span> <span class="token string">"Admin"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// Expected: Admin</span><span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Guest （？！？）</span></code></pre><p>读取 <code>admin.name</code> 应该返回 <code>"Admin"</code>，而不是 <code>"Guest"</code>！</p><p>怎么了？也许我们在继承方面做错了什么？</p><p>但是，如果我们删除代理，那么一切都会按预期进行。</p><p>问题实际上出在代理中，在 <code>(*)</code>行。</p><ol><li><p>当我们读取 <code>admin.name</code>，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型。</p></li><li><p>原型是 <code>userProxy</code>。</p></li><li><p>从代理读取 <code>name</code> 属性时，<code>get</code> 钩子会触发并从原始对象返回 <code>target[prop]</code> 属性，在 <code>(*)</code>行</p><p>当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 getter，它将在 <code>this=target</code> 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> 的 <code>this._name</code> 即来自 <code>user</code>。</p></li></ol><p>为了解决这种情况，我们需要 <code>get</code> 钩子的第三个参数 <code>receiver</code>。它保证传递正确的 <code>this</code> 给 getter。在我们的情况下是 <code>admin</code>。</p><p>如何为 getter 传递上下文？对于常规函数，我们可以使用 <code>call/apply</code>，但这是一个 getter，它不是“被调用”的，只是被访问的。</p><p><code>Reflect.get</code> 可以做到的。如果我们使用它，一切都会正常运行。</p><p>这是更正后的变体：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  _name<span class="token operator">:</span> <span class="token string">"Guest"</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> userProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// receiver = admin</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (*)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token operator">:</span> userProxy<span class="token punctuation">,</span>  _name<span class="token operator">:</span> <span class="token string">"Admin"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Admin</span></code></pre><p>现在 <code>receiver</code>，保留了对正确 <code>this</code> 的引用（即<code>admin</code>）的引用，该引用将在 <code>(*)</code> 行中使用<code>Reflect.get</code>传递给 getter。</p><p>我们可以将钩子重写得更短：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Reflect</code> 调用的命名方式与钩子完全相同，并且接受相同的参数。它们是通过这种方式专门设计的。</p><p>因此， <code>return Reflect...</code> 会提供一个安全的提示程序来转发操作，并确保我们不会忘记与此相关的任何内容。</p><h2 id="Proxy-的局限"><a href="#Proxy-的局限" class="headerlink" title="Proxy 的局限"></a>Proxy 的局限</h2><p>代理提供了一种独特的方法，可以在最底层更改或调整现有对象的行为。但是，它并不完美。有局限性。</p><h3 id="内置对象：内部插槽（Internal-slots）"><a href="#内置对象：内部插槽（Internal-slots）" class="headerlink" title="内置对象：内部插槽（Internal slots）"></a>内置对象：内部插槽（Internal slots）</h3><p>许多内置对象，例如 <code>Map</code>, <code>Set</code>, <code>Date</code>, <code>Promise</code> 等等都使用了所谓的 “内部插槽”。</p><p>它们类似于属性，但仅限于内部使用，仅用于规范目的。例如， <code>Map</code> 将项目存储在 <code>[[MapData]]</code>中。内置方法直接访问它们，而不通过 <code>[[Get]]/[[Set]]</code> 内部方法。所以 <code>Proxy</code> 不能拦截。</p><p>为什么要在意呢？他们是内部的！</p><p>好吧，这就是问题。在像这样的内置对象被代理后，代理对象没有这些内部插槽，因此内置方法将失败。</p><p>例如：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></code></pre><p>在内部，一个 <code>Map</code> 将所有数据存储在其 <code>[[MapData]]</code> 内部插槽中。代理对象没有这样的插槽。<a href="https://link.juejin.cn/?target=https://tc39.es/ecma262/%23sec-map.prototype.set" title="https://tc39.es/ecma262/#sec-map.prototype.set">内建方法 <code>Map.prototype.set</code></a> 方法试图访问内部属性 <code>this.[[MapData]]</code>，但由于 <code>this=proxy</code> 在 <code>proxy</code> 中不能找到它，只能失败。</p><p>幸运的是，有一种解决方法：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">"function"</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>proxy<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 (works!)</span></code></pre><p>现在它可以正常工作，因为 <code>get</code> 钩子将函数属性（例如 <code>map.set</code>）绑定到目标对象（<code>map</code>）本身。</p><p>与前面的示例不同，<code>proxy.set(...)</code> 内部 <code>this</code> 的值并不是 <code>proxy</code>，而是原始对象 <code>map</code>。因此，当<code>set</code> 钩子的内部实现尝试访问 <code>this.[[MapData]]</code> 内部插槽时，它会成功。</p><p><code>Array</code> 没有内部插槽</p><p>一个明显的例外：内置 <code>Array</code> 不使用内部插槽。那是出于历史原因，因为它出现于很久以前。</p><p>因此，代理数组时没有这种问题。</p><h3 id="私有字段"><a href="#私有字段" class="headerlink" title="私有字段"></a>私有字段</h3><p>类的私有字段也会发生类似的情况。</p><p>例如，<code>getName()</code> 方法访问私有的 <code>#name</code> 属性并在代理后中断：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  #name <span class="token operator">=</span> <span class="token string">"Guest"</span><span class="token punctuation">;</span>  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></code></pre><p>原因是专用字段是使用内部插槽实现的。JavaScript 访问它们时不使用 <code>[[Get]]/[[Set]]</code>。</p><p>在调用 <code>getName()</code> 时 <code>this</code> 的值是代理后的 <code>user</code>，它没有带私有字段的插槽。</p><p>再次，bind 方法的解决方案使它恢复正常：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  #name <span class="token operator">=</span> <span class="token string">"Guest"</span><span class="token punctuation">;</span>  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>#name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> value <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value <span class="token operator">==</span> <span class="token string">"function"</span> <span class="token operator">?</span> <span class="token function">value</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">:</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Guest</span></code></pre><p>该解决方案有缺点，如前所述：将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能。</p><h3 id="Proxy-target"><a href="#Proxy-target" class="headerlink" title="Proxy != target"></a>Proxy != target</h3><p>代理和原始对象是不同的对象。很自然吧？</p><p>因此，如果我们使用原始对象作为键，然后对其进行代理，则找不到代理：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> allUsers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    allUsers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>allUsers<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>allUsers<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre><p>如我们所见，代理后，我们在 <code>allUsers</code> 中找不到 <code>user</code>，因为代理是一个不同的对象。</p><p>Proxy 无法拦截严格相等性测试 <code>===</code></p><p>Proxy 可以拦截许多运算符，例如 new（使用 <code>construct</code>），in（使用 <code>has</code>），delete（使用 <code>deleteProperty</code>）等。</p><p>但是没有办法拦截对象的严格相等性测试。一个对象严格只等于自身，没有其他值。</p><p>因此，比较对象是否相等的所有操作和内置类都会区分 target 和 proxy。这里没有透明的替代品。</p><h2 id="可取消的-Proxy"><a href="#可取消的-Proxy" class="headerlink" title="可取消的 Proxy"></a>可取消的 Proxy</h2><p>一个</p><p>可撤销</p><p>的代理是可以被禁用的代理。</p><p>假设我们有一个资源，并且想随时关闭对该资源的访问。</p><p>我们可以做的是将其包装成可撤销的代理，而没有任何钩子。这样的代理会将操作转发给对象，我们可以随时将其禁用。</p><p>语法为：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该调用返回一个带有 <code>proxy</code> 和 <code>revoke</code> 函数的对象以将其禁用。</p><p>这是一个例子：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>  data<span class="token operator">:</span> <span class="token string">"Valuable data"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// proxy 正常工作</span><span class="token function">alert</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Valuable data</span><span class="token comment">// 之后某处调用</span><span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// proxy 不再工作（已吊销）</span><span class="token function">alert</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span></code></pre><p>调用 <code>revoke()</code> 会从代理中删除对目标对象的所有内部引用，因此不再连接它们。之后可以对目标对象进行垃圾回收。</p><p>我们还可以将 <code>revoke</code> 存储在 <code>WeakMap</code> 中，以便能够通过代理对象轻松找到它：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> revokes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>  data<span class="token operator">:</span> <span class="token string">"Valuable data"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>revokes<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>proxy<span class="token punctuation">,</span> revoke<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ..later in our code..</span>revoke <span class="token operator">=</span> revokes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error（已吊销）</span></code></pre><p>这种方法的好处是我们不必随身携带 revoke。我们可以在需要时从 map <code>proxy</code> 上获取它。</p><p>此处我们使用<code>WeakMap</code> 而不是 <code>Map</code> ，因为它不会阻止垃圾收集。如果代理对象变得“无法访问”（例如，没有变量再引用它），则 <code>WeakMap</code> 允许将其与 它的 <code>revoke</code> 对象一起从内存中擦除，因为我们不再需要它了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Proxy</code> 是对象的包装，将代理上的操作转发到对象，并可以选择捕获其中的一些操作。</p><p>它可以包装任何类型的对象，包括类和函数。</p><p>语法为：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment">/* traps */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>……然后，我们应该在所有地方使用 <code>proxy</code> 而不是 <code>target</code>。代理没有自己的属性或方法。如果提供了钩子，它将捕获操作，否则将其转发给 <code>target</code> 对象。</p><p>我们可以捕获：</p><ul><li>读取（<code>get</code>），写入（<code>set</code>），删除（<code>deleteProperty</code>）属性（甚至是不存在的属性）。</li><li>函数调用（<code>apply</code> 钩子）。</li><li><code>new</code> 操作（<code>construct</code> 钩子）。</li><li>许多其他操作（完整列表在本文开头和 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">docs</a> 中）。</li></ul><p>这使我们能够创建“虚拟”属性和方法，实现默认值，可观察对象，函数装饰器等等。</p><p>我们还可以将对象多次包装在不同的代理中，并用多个函数进行装饰。</p><p>该<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a> API 旨在补充 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>。对于任何 <code>Proxy</code> 钩子，都有一个带有相同参数的 <code>Reflect</code> 调用。我们应该使用它们将调用转发给目标对象。</p><p>Proxy 有一些局限：</p><ul><li>内置对象具有“内部插槽”，对这些对象的访问无法被代理。请参阅上面的解决方法。</li><li>私有类字段也是如此，因为它们是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象 <code>this</code> 才能访问它们。</li><li>对象相等性测试 <code>===</code> 不能被拦截。</li><li>性能：基准测试取决于引擎，但通常使用最简单的代理访问属性所需的时间要长几倍。实际上，这仅对某些“瓶颈”对象重要。</li></ul><h2 id="几个小实例任务"><a href="#几个小实例任务" class="headerlink" title="几个小实例任务"></a>几个小实例任务</h2><h3 id="读取不存在的属性时出错"><a href="#读取不存在的属性时出错" class="headerlink" title="读取不存在的属性时出错"></a>读取不存在的属性时出错</h3><p>通常，尝试读取不存在的属性会返回 <code>undefined</code>。</p><p>创建一个代理，在尝试读取不存在的属性时该代理抛出错误。</p><p>这可以帮助及早发现编程错误。</p><p>编写一个接受 <code>target</code> 对象，并返回添加此方面功能的 proxy 的 <code>wrap(target)</code> 函数。</p><p>应满足如下结果：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token comment">/* 你的代码 */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>user <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：属性不存在</span></code></pre><p>解决方案</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token keyword">in</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Property doesn't exist: "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>user <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: Property doesn't exist</span></code></pre><h3 id="用-1-索引访问数组"><a href="#用-1-索引访问数组" class="headerlink" title="用-1 索引访问数组"></a>用-1 索引访问数组</h3><p>在某些编程语言中，我们可以使用从结尾算起的负索引访问数组元素。</p><p>像这样：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 3，最后一个元素</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 2，从末尾开始向前移动一步</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 1，从末尾开始向前移动两步</span></code></pre><p>换句话说，<code>array[-N]</code> 与 <code>array[array.length - N]</code> 相同。</p><p>创建一个 proxy 来实现该行为。</p><p>那应该是这样的：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment">/* your code */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token function">alert</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span><span class="token comment">// 其他数组也应该适用于这个功能</span></code></pre><p>解决方案</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// even if we access it like arr[1]</span>      <span class="token comment">// prop is a string, so need to convert it to number</span>      prop <span class="token operator">=</span> <span class="token operator">+</span>prop <span class="token operator">+</span> target<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token function">alert</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code></pre><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>创建一个通过返回代理“使对象可观察”的 <code>makeObservable(target)</code> 函数。</p><p>它的工作方式如下：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">/* your code */</span><span class="token punctuation">}</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span> <span class="token comment">// alerts：设置 name 属性为 John</span></code></pre><p>换句话说，<code>makeObservable</code> 返回的对象就像原始对象一样，但是也具有将 <code>handler</code> 函数设置为在任何属性更改时都被调用的方法 <code>observe(handler)</code> 。</p><p>每当属性更改时，都会使用属性的名称和值调用 <code>handler(key, value)</code> 。</p><p>P.S. 在此任务中，请仅注意写入属性。可以以类似方式实现其他操作。</p><p>解决方案</p><p>该解决方案包括两部分：</p><ol><li> 无论 <code>.observe(handler)</code> 何时被调用，我们都需要在某个地方记住 handler，以便以后可以调用它。我们可以使用 Symbol 作为属性键，将 handler 直接存储在对象中。</li><li> 我们需要一个带 <code>set</code> 钩子的 proxy 来在发生任何更改时调用处理程序。</li></ol><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> handlers <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"handlers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 1. 初始化 handler 存储数组</span>  target<span class="token punctuation">[</span>handlers<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储 handler 函数到数组中以便于未来调用</span>  target<span class="token punctuation">.</span><span class="token function-variable function">observe</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 2. 创建代理以处理更改</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> success <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 转发写入操作到目标对象</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 如果设置属性的时候没有报错</span>        <span class="token comment">// 调用所有 handler</span>        target<span class="token punctuation">[</span>handlers<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">handler</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> success<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user <span class="token operator">=</span> <span class="token function">makeObservable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">SET </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"John"</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Proxy </category>
          
          <category> Reflect </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxy </tag>
            
            <tag> Reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2021/10/20/git-ming-ling/"/>
      <url>/2021/10/20/git-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="GIT-命令"><a href="#GIT-命令" class="headerlink" title="GIT 命令"></a>GIT 命令</h3><h4 id="git-basics"><a href="#git-basics" class="headerlink" title="git basics"></a>git basics</h4><table><thead><tr><th align="left">git init <directory></directory></th><th>在指定的⽬录下创建⼀个空的 git repo。不带参数将在当前⽬录下创建⼀个 git repo。</th></tr></thead><tbody><tr><td align="left">git clone <repo></repo></td><td>克隆⼀个指定 repo 到本地。指定的 repo 可 以是本地⽂件系统或者由 HTTP 或 SSH 指 定的远程路径。</td></tr><tr><td align="left">git config user.name <name></name></td><td>针对当前 repo 配置⽤户名。使⽤ –global 参数将配置全局⽤户名。</td></tr><tr><td align="left">git add <directory></directory></td><td>将指定目录的所有修改加⼊到下⼀次 commit 中。把<directory>替换成 <file>将 添加指定文件的修改。</file></directory></td></tr><tr><td align="left">git commit -m “<message>“</message></td><td>提交暂存区的修改，使用指定的 <message>作为提交信息，而不是打开文本编辑器输⼊提交信息。</message></td></tr><tr><td align="left">git status</td><td>显示哪些⽂件已被 staged、未被 staged 以及未跟踪 (untracked)。</td></tr><tr><td align="left">git log</td><td>以缺省格式显示全部 commit 历史。更多自定义参数请参考后续部分。</td></tr></tbody></table><h4 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h4><table><thead><tr><th>git diff</th><th>⽐较⼯作区和暂存区的修改。</th></tr></thead><tbody><tr><td>git diff HEAD</td><td>⽐较工作区和上⼀次 commit 后的修改。</td></tr><tr><td>git diff –cached</td><td>⽐较暂存区和上⼀次 commit 后的修改。</td></tr></tbody></table><h4 id="undoing-change"><a href="#undoing-change" class="headerlink" title="undoing change"></a>undoing change</h4><table><thead><tr><th align="left">git revert <commit></commit></th><th align="left">对指定 <commit>创建⼀个 undo 的 commit，并应⽤到当前分⽀。</commit></th></tr></thead><tbody><tr><td align="left">git reset <file></file></td><td align="left">将 <file>从暂存区移除，但保持⼯作区不 变。此操作不会修改⼯作区的任何⽂件。</file></td></tr></tbody></table><h4 id="rewaiting-git-history"><a href="#rewaiting-git-history" class="headerlink" title="rewaiting git history"></a>rewaiting git history</h4><table><thead><tr><th align="left">git commit -m <message> –amend</message></th><th align="left">将当前 staged 修改合并到最近⼀次的 commit 中。</th></tr></thead><tbody><tr><td align="left">git rebase <base></td><td align="left">基于 <base>对当前分⽀进⾏ rebase。<base>可以是 commit、分⽀名称、tag 或相对于 HEAD 的 commit。</td></tr><tr><td align="left">git reflog</td><td align="left">显示本地 repo 的所有 commit ⽇志。</td></tr></tbody></table><h4 id="git-branches"><a href="#git-branches" class="headerlink" title="git branches"></a>git branches</h4><table><thead><tr><th>git branch</th><th>显示本地 repo 的所有分⽀。</th></tr></thead><tbody><tr><td>git switch -c <branch></branch></td><td>创建并切换到⼀个新的名为 <branch>的分⽀。去掉-c 参数将切换到⼀个已有分⽀。</branch></td></tr><tr><td>git merge <branch></branch></td><td>将指定 <branch>分⽀合并到当前分⽀。</branch></td></tr></tbody></table><h4 id="remote-repositories"><a href="#remote-repositories" class="headerlink" title="remote repositories"></a>remote repositories</h4><table><thead><tr><th align="left">git remote add <name> <url></url></name></th><th align="left">添加⼀个新的远程连接。添加后可使用<name>作为指定 <url>远程连接的名称。</url></name></th></tr></thead><tbody><tr><td align="left">git fetch <remote> <branch></branch></remote></td><td align="left">从指定<remote>抓取指定<branch>的所有 commit 到本地 repo。去掉 <branch>将抓取远程所有分⽀的修改。</branch></branch></remote></td></tr><tr><td align="left">git pull <remote></remote></td><td align="left">从指定<remote>抓取所有分⽀的 commit 并⽴刻合并到本地 repo。</remote></td></tr><tr><td align="left">git push <remote> <branch></branch></remote></td><td align="left">将本地指定<branch>推送到指定远程<remote>。如果远程没有对应的分⽀，将⾃动在远程创建此分⽀。</remote></branch></td></tr></tbody></table><h4 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h4><table><thead><tr><th align="left">git config – global user.name <name></name></th><th align="left">配置当前用户名，使⽤–global 参数将针对当前系统登录用户生效。</th></tr></thead><tbody><tr><td align="left">git config – global user.email <email></email></td><td align="left">配置当前⽤户 Email。</td></tr><tr><td align="left">git config – global alias. <alias-name> <git-command></git-command></alias-name></td><td align="left">配置⼀个 git 命令的快捷⽅式。例如：配置 ”alias.glog log –graph –oneline”使 ”git glog”相当于 ”git log –graph –oneline”.</td></tr><tr><td align="left">git config – system core.editor <editor></editor></td><td align="left">配置⽂本编辑器，例如 vi，在必要时⾃动打开此⽂本编辑器。</td></tr><tr><td align="left">git config – global –edit</td><td align="left">打开当前⽤户的 git 全局配置并编辑。</td></tr></tbody></table><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><table><thead><tr><th>git log -<limit></limit></th><th align="left">限制 log 的显示数量。例如：”git log -5”仅 显示最新 5 条 commit。</th></tr></thead><tbody><tr><td>git log –oneline</td><td align="left">每⾏显示⼀条 commit。</td></tr><tr><td>git log –author “<pattern>“</pattern></td><td align="left">按提交者名字搜索并显示 commit。</td></tr><tr><td>git log –grep “<pattern>“</pattern></td><td align="left">按指定内容搜索并显示 commit。</td></tr><tr><td>git log <since>..<until></until></since></td><td align="left">显示指定范围的 commit。范围参数可以是 commit ID、分⽀名称、HEAD 或任意相对 位置。</td></tr><tr><td>git log – <file></file></td><td align="left">仅显示包含指定⽂件修改的 commit。</td></tr><tr><td>git log –graph</td><td align="left">使⽤–graph 参数显示图形化的 branch 信 息。</td></tr></tbody></table><h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><table><thead><tr><th>git reset</th><th align="left">移除所有暂存区的修改，但不会修改⼯作区。</th></tr></thead><tbody><tr><td>git reset –hard</td><td align="left">移除所有暂存区的修改，并强制删除所有⼯作区的修改。</td></tr><tr><td>git reset <commit></commit></td><td align="left">将当前分⽀回滚到指定<commit>，清除暂存区的修改，但保持⼯作区状态不变。</commit></td></tr><tr><td>git reset <commit> –hard</commit></td><td align="left">将当前分⽀回滚到指定<commit>，清除暂存区的修改，并强制删除所有⼯作区的修改。</commit></td></tr></tbody></table><h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><table><thead><tr><th>git rebase -i <base></th><th align="left">以交互模式对当前分支做 rebase</th></tr></thead></table><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><table><thead><tr><th align="left">git pull –rebase <remote></remote></th><th align="left">抓取所有的远程分支，并以 rebase 模式并入本地的 repo 而不是 merge</th></tr></thead></table><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><table><thead><tr><th align="left">git push <remote> –force</remote></th><th align="left">将本地分⽀推送到远程。不要使⽤–force 参数，除⾮你完全明⽩此操作的后果。</th></tr></thead><tbody><tr><td align="left">git push <remote> –tags</remote></td><td align="left">使⽤ push 命令并不会⾃动将本地 tag 推送 到远程。加上–tags 参数会将所有本地 tag 推送到远程。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配的几种方案记录</title>
      <link href="/2021/10/14/yi-dong-duan-gua-pei-de-ji-chong-fang-an-ji-lu/"/>
      <url>/2021/10/14/yi-dong-duan-gua-pei-de-ji-chong-fang-an-ji-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="移动端适配的几种方案记录"><a href="#移动端适配的几种方案记录" class="headerlink" title="移动端适配的几种方案记录"></a>移动端适配的几种方案记录</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用</li><li>按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用<code>rem</code>||<code> vw</code>相对单位，不需要缩放的使用<code>px</code></li><li>固定尺寸+弹性布局，不需要缩放（<code>viewport</code>、<code>vm</code>、<code>rem</code>）但是等比适配，放在<code>ipad</code>上的时候（设计稿以手机屏幕设计），页面的元素会很大很丑，所以并不是所有的场景下，页面都做整体的缩放（<code>viewport</code> 自动处理的也很好了）。利用合理的布局也可以比如<code>flex</code>、<code>grid</code></li></ol><h4 id="viewport-适配"><a href="#viewport-适配" class="headerlink" title="viewport 适配"></a>viewport 适配</h4><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110141424520.jpg" alt="2" style="zoom: 50%;"><p>设计稿的宽度为<code>750px</code>,写完页面之后元素自动缩小，适配<code>375px</code>宽度的屏幕。</p><p><code>&lt;meta name="viewport" content="width=750,initial-scale=0.5"&gt;</code></p><p><code>inital-scale = 屏幕的宽度 / 设计稿的宽度</code>。但是移动端的屏幕肯定不止一种宽度，所以需要动态的设置 <code>inital-scale</code>的值。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>    <span class="token keyword">const</span> <span class="token constant">WIDTH</span> <span class="token operator">=</span> <span class="token number">750</span>    <span class="token keyword">const</span> <span class="token function-variable function">mobileAdapter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> scale <span class="token operator">=</span> screen<span class="token punctuation">.</span>width <span class="token operator">/</span> <span class="token constant">WIDTH</span>      <span class="token keyword">let</span> content <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">width=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">WIDTH</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, initial-scale=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>scale<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, maximum-scale=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>scale<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, minimum-scale=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>scale<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>      <span class="token keyword">let</span> meta <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'meta[name=viewport]'</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>meta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        meta <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'meta'</span><span class="token punctuation">)</span>        meta<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'viewport'</span><span class="token punctuation">)</span>        document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>meta<span class="token punctuation">)</span>      <span class="token punctuation">}</span>      meta<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">mobileAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    window<span class="token punctuation">.</span>onorientationchange <span class="token operator">=</span> mobileAdapter <span class="token comment">//屏幕翻转时再次执行,翻转屏幕的时候高度和宽度对换</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span></code></pre><p><code>document.querySelector('meta[name=viewport]')</code></p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110141407674.png" alt="image-20211014140709642" style="zoom:150%;"><blockquote><p>缺点：</p><p>边线的问题，不同尺寸下，等比缩放之后边线的粗细不一样。而且全部的元素都是等比缩放，实际的显示效果可能不太好。</p></blockquote><h4 id="vw-适配（部分等比缩放）"><a href="#vw-适配（部分等比缩放）" class="headerlink" title="vw 适配（部分等比缩放）"></a>vw 适配（部分等比缩放）</h4><blockquote><p>对于不需要缩放的元素，继续使用<code>px</code>，对于需要缩放的元素，使用<code>vw</code></p></blockquote><ol><li>开发者拿到设计稿（假设设计稿尺寸为<code>750px</code>，设计稿的元素标注是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换，把<code>px</code>换成<code>vw</code>。比如页面元素字体标注的大小是<code>32px</code>，换成<code>vw</code>为 <code>(100/750)*32 vw</code>。因为<code>750px = 100vw</code></li><li>对于需要等比缩放的元素，<code>CSS</code>使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位<code>px</code></li></ol><p>为了开发环境，可以利用自定义<code>css</code>变量</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1"</span><span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>    <span class="token keyword">const</span> <span class="token constant">WIDTH</span> <span class="token operator">=</span> <span class="token number">750</span>    <span class="token comment">//:root { --width: 0.133333 } 1px等于多少vm ---&gt; 100vw就是750px嘛，那1vm就是100/750</span>    document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">'--width'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">/</span> <span class="token constant">WIDTH</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span></code></pre><blockquote><p>注意：</p><p>此时不需要设置<code>initial-scale</code></p></blockquote><p>业务代码</p><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">.header</span> <span class="token punctuation">{</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span>28vw * <span class="token function">var</span><span class="token punctuation">(</span>--WIDTH<span class="token punctuation">)</span><span class="token punctuation">)</span> // 相当于<span class="token punctuation">(</span>28 * WIDTH<span class="token punctuation">)</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="rem-适配"><a href="#rem-适配" class="headerlink" title="rem 适配"></a>rem 适配</h4><ol><li>开发者拿到设计稿（假设设计稿尺寸为<code>750px</code>，设计稿的元素标是基于此宽度标注）</li><li>开始开发，对设计稿的标注进行转换</li><li>对于需要等比缩放的元素，<code>CSS</code>使用转换后的单位</li><li>对于不需要缩放的元素，比如边框阴影，使用固定单位<code>px</code></li></ol><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110141425849.jpg" alt="1" style="zoom:50%;"><p>假设设计稿的某个字体大小是<code>40px</code>, 手机屏幕上的字体大小应为<code>420/750*40 = 22.4px</code>(体验好)，换算成<code>rem</code>（相对于 <code>html</code>根节点，假设<code>html</code>的<code>font-size = 100px</code>）则这个字体大小为<code>0.224 rem</code></p><p>写样式时，对应的字体设置为<code>0.224 rem</code>即可，其他元素尺寸也做换算…如果就这样做的话，那所有的需要缩放的都需要自动动手算一遍，转换思路：看到<code>40px</code>，就应该写<code>40/100=0.4rem</code>, 这样看到就知道多少，就可以不用计算了。此时规定<code>html</code>的<code>font-size</code>就不是<code>100px</code>，应该是<code>(420*100)/750 = 56px</code>。<code>100</code>这个数是我们自己规定的。</p><blockquote><p>计算思路：</p><table><thead><tr><th align="center"></th><th align="center">屏幕</th><th align="center">设计稿</th></tr></thead><tbody><tr><td align="center"></td><td align="center">420px</td><td align="center">750px</td></tr><tr><td align="center">html 的 font-size</td><td align="center">56px</td><td align="center">100px</td></tr></tbody></table><p><code>420/x=750/100 ===&gt; x=56px</code></p><p>我们在开发的时候是在<code>750px</code>的设计稿基础上开发。此时页面的<code>html</code>的<code>font-size</code>为<code>100px</code>，而 rem 就是相对于该值计算，也就是需要缩放的<code>40px</code>，直接写成<code>40/100 = 0.4rem</code>。而在<code>420px</code>的屏幕中的<code>html</code>的<code>font-size</code>设置成 56px 就可以。当然<code>100</code>是自己取的值，为了方便计算，可以取其他值，但是不要取<code>1px</code>,浏览器对其会有不同的计算(不准确)</p></blockquote><p>现在要做的就是，根据不同的屏幕宽度，设置<code>html</code>的<code>font-size</code>值</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1"</span><span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>    <span class="token keyword">const</span> <span class="token constant">WIDTH</span> <span class="token operator">=</span> <span class="token number">750</span> <span class="token comment">//设计稿尺寸</span>    <span class="token keyword">const</span> <span class="token function-variable function">setView</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> screen<span class="token punctuation">.</span>width <span class="token operator">/</span> <span class="token constant">WIDTH</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'px'</span>    <span class="token punctuation">}</span>    <span class="token function">setView</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    window<span class="token punctuation">.</span>onorientationchange <span class="token operator">=</span> setView <span class="token comment">// 屏幕翻转之后重新调用一次</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span></code></pre><p>业务代码</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 使用css</span><span class="token punctuation">.</span>header<span class="token punctuation">{</span>    font<span class="token operator">-</span>size<span class="token operator">:</span> <span class="token number">.28</span>rem<span class="token punctuation">}</span><span class="token comment">// 使用sass （函数指令）</span>@<span class="token keyword">function</span> <span class="token function">px2rem</span><span class="token punctuation">(</span><span class="token parameter">$px</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    @<span class="token keyword">return</span> $px <span class="token operator">*</span> <span class="token number">1</span>rem <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>header<span class="token punctuation">{</span>    font<span class="token operator">-</span>size<span class="token operator">:</span><span class="token function">px2rem</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>推荐阅读：</p><p><a href="https://juejin.cn/post/6844903845617729549">关于移动端适配，你必须要知道的(超级详细)</a></p>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考vue-element-admin的i18n实现思路</title>
      <link href="/2021/10/13/can-kao-vue-element-admin-de-i18n-shi-xian-si-lu/"/>
      <url>/2021/10/13/can-kao-vue-element-admin-de-i18n-shi-xian-si-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="国际化-Vue-ElementUI-的实现"><a href="#国际化-Vue-ElementUI-的实现" class="headerlink" title="国际化(Vue+ElementUI)的实现"></a>国际化(Vue+ElementUI)的实现</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>npm install vue-i18n --save-dev</code></p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// src/main.js</span><span class="token keyword">import</span> i18n <span class="token keyword">from</span> <span class="token string">'@/lang/index.js'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>ElementUI，<span class="token punctuation">{</span>        <span class="token function-variable function">i18n</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span>value</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> i18n<span class="token punctuation">.</span><span class="token function">t</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token comment">// ElementUI默认只兼容vue-i18n的5.x版本。该行代码是为了兼容7.x甚至更新的版本</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  i18n<span class="token punctuation">,</span>  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// src/lang/index.js</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token keyword">import</span> VueI18n <span class="token keyword">from</span> <span class="token string">"vue-i18n"</span><span class="token punctuation">;</span><span class="token keyword">import</span> Cookies <span class="token keyword">from</span> <span class="token string">"js-cookie"</span><span class="token punctuation">;</span><span class="token keyword">import</span> elementEnLocale <span class="token keyword">from</span> <span class="token string">"element-ui/lib/locale/lang/en"</span><span class="token punctuation">;</span> <span class="token comment">// element-ui 的语言包</span><span class="token keyword">import</span> elementZhLocale <span class="token keyword">from</span> <span class="token string">"element-ui/lib/locale/lang/zh-CN"</span><span class="token punctuation">;</span> <span class="token comment">// element-ui 的语言包</span><span class="token keyword">import</span> enLocale <span class="token keyword">from</span> <span class="token string">"./en"</span><span class="token punctuation">;</span><span class="token keyword">import</span> zhLocale <span class="token keyword">from</span> <span class="token string">"./zh"</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueI18n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token punctuation">{</span>  en<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token comment">// 导入多个语言包</span>    <span class="token operator">...</span>enLocale<span class="token punctuation">,</span>    <span class="token operator">...</span>elementEnLocale<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  zh<span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span>zhLocale<span class="token punctuation">,</span>    <span class="token operator">...</span>elementZhLocale<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> chooseLanguage <span class="token operator">=</span> Cookies<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"language"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>chooseLanguage<span class="token punctuation">)</span> <span class="token keyword">return</span> chooseLanguage<span class="token punctuation">;</span>  <span class="token comment">// if has not choose language</span>  <span class="token keyword">const</span> language <span class="token operator">=</span> <span class="token punctuation">(</span>    navigator<span class="token punctuation">.</span>language <span class="token operator">||</span> navigator<span class="token punctuation">.</span>browserLanguage  <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// z-cn</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>language<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> locales <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>messages<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> locale <span class="token keyword">of</span> locales<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>language<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>locale<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> locale<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token string">"zh"</span><span class="token punctuation">;</span> <span class="token comment">// 默认返回的是中文</span><span class="token punctuation">}</span><span class="token keyword">const</span> i18n <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueI18n</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">// set locale</span>  <span class="token comment">// options: en | zh | es</span>  locale<span class="token operator">:</span> <span class="token function">getLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">//  语言标识</span>  <span class="token comment">// set locale messages</span>  messages<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> i18n<span class="token punctuation">;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// ./zh</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  route<span class="token operator">:</span> <span class="token punctuation">{</span>    dashboard<span class="token operator">:</span> <span class="token string">'首页'</span><span class="token punctuation">,</span>    documentation<span class="token operator">:</span> <span class="token string">'文档'</span><span class="token punctuation">,</span>    guide<span class="token operator">:</span> <span class="token string">'引导页'</span><span class="token punctuation">,</span>    permission<span class="token operator">:</span> <span class="token string">'权限测试页'</span>    <span class="token operator">...</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  navbar<span class="token operator">:</span> <span class="token punctuation">{</span>    dashboard<span class="token operator">:</span> <span class="token string">'首页'</span><span class="token punctuation">,</span>    github<span class="token operator">:</span> <span class="token string">'项目地址'</span><span class="token punctuation">,</span>    logOut<span class="token operator">:</span> <span class="token string">'退出登录'</span><span class="token punctuation">,</span>    profile<span class="token operator">:</span> <span class="token string">'个人中心'</span><span class="token punctuation">,</span>    theme<span class="token operator">:</span> <span class="token string">'换肤'</span><span class="token punctuation">,</span>    size<span class="token operator">:</span> <span class="token string">'布局大小'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h4 id="vue-i18n-数据渲染的模板语法"><a href="#vue-i18n-数据渲染的模板语法" class="headerlink" title="vue-i18n 数据渲染的模板语法"></a>vue-i18n 数据渲染的模板语法</h4><p>模板语法暂时分为三种：</p><pre class="language-vue" data-language="vue"><code class="language-vue">//vue组件模板的使用&lt;div&gt;{{$t('navbar.github')}}&lt;/div&gt;//vue组件模板数据绑定的使用&lt;input :placeholder="$t('navbar.github')"&gt;&lt;/input&gt;//vue组件data中赋值的使用data:{   msg:this.$t('navbar.github');  // 在template模板中是不需要使用this来访问vue实例变量滴}</code></pre><h4 id="路由与面包屑国际化的语法问题"><a href="#路由与面包屑国际化的语法问题" class="headerlink" title="路由与面包屑国际化的语法问题"></a>路由与面包屑国际化的语法问题</h4><p><strong>面包屑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110131642640.png" alt="image-20211013164258567"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110131643725.png" alt="image-20211013164313694"></p><p>通过<code>generateTitle</code>转成<code>route.[xxx]</code>的格式，即是访问<code>zh.js</code>中的<code>key</code>值格式。进而进行翻译转换。</p><p><strong>路由</strong></p><p>而该项目路由是通过动态路由加载菜单的形式生成的侧边栏。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110131647063.png" alt="image-20211013164737019"></p><h4 id="i18n-的几个-api"><a href="#i18n-的几个-api" class="headerlink" title="i18n 的几个 api"></a>i18n 的几个 api</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">$t</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 返回翻译后的结果<span class="token function">$te</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> 检查存在本地语言环境信息key，返回布尔值 例如<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">navbar.github</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">(</span>整个是个<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">key</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> vue-admin </category>
          
          <category> i18n </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-admin </tag>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态路由权限的解决方案</title>
      <link href="/2021/10/13/dong-tai-lu-you-quan-xian-de-jie-jue-fang-an/"/>
      <url>/2021/10/13/dong-tai-lu-you-quan-xian-de-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-动态添加路由及生成菜单"><a href="#Vue-动态添加路由及生成菜单" class="headerlink" title="Vue 动态添加路由及生成菜单"></a>Vue 动态添加路由及生成菜单</h2><p>写后台管理系统，估计有不少人遇过这样的需求：根据后台数据动态添加路由和菜单。<br><br>为什么这么做呢？因为不同的用户有不同的权限，能访问的页面是不一样的。<br><br>思路是仿照<code>vue-element-admin</code>。<br></p><h3 id="动态生成路由"><a href="#动态生成路由" class="headerlink" title="动态生成路由"></a>动态生成路由</h3><p>利用 vue-router 的 <code>addRoutes</code> 方法可以动态添加路由。</p><p>先看一下官方介绍：</p><p><strong>router.addRoutes</strong></p><pre class="language-js" data-language="js"><code class="language-js">router<span class="token punctuation">.</span><span class="token function">addRoutes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>routes<span class="token operator">:</span> Array<span class="token operator">&lt;</span>RouteConfig<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>动态添加更多的路由规则。参数必须是一个符合 <code>routes</code> 选项要求的数组。</p><p>举个例子：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token operator">:</span> <span class="token string">"/login"</span><span class="token punctuation">,</span>      name<span class="token operator">:</span> <span class="token string">"login"</span><span class="token punctuation">,</span>      <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../components/Login.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">"/home"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的代码和下面的代码效果是一样的</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">"/home"</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>router<span class="token punctuation">.</span><span class="token function">addRoutes</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/login"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"login"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../components/Login.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在动态添加路由的过程中，如果有 404 页面，一定要放在最后添加，否则在登陆的时候添加完页面会重定向到 404 页面。</p><p>类似于这样，这种规则一定要最后添加。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>path<span class="token operator">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">'/404'</span><span class="token punctuation">}</span></code></pre><h3 id="动态生成菜单"><a href="#动态生成菜单" class="headerlink" title="动态生成菜单"></a>动态生成菜单</h3><p>假设后台返回来的数据长这样</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 左侧菜单栏数据</span>menuItems<span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    name<span class="token operator">:</span> <span class="token string">"home"</span><span class="token punctuation">,</span> <span class="token comment">// 要跳转的路由名称 不是路径</span>    size<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token comment">// icon大小</span>    type<span class="token operator">:</span> <span class="token string">"md-home"</span><span class="token punctuation">,</span> <span class="token comment">// icon类型</span>    text<span class="token operator">:</span> <span class="token string">"主页"</span><span class="token punctuation">,</span> <span class="token comment">// 文本内容</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    text<span class="token operator">:</span> <span class="token string">"二级菜单"</span><span class="token punctuation">,</span>    type<span class="token operator">:</span> <span class="token string">"ios-paper"</span><span class="token punctuation">,</span>    children<span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        type<span class="token operator">:</span> <span class="token string">"ios-grid"</span><span class="token punctuation">,</span>        name<span class="token operator">:</span> <span class="token string">"t1"</span><span class="token punctuation">,</span>        text<span class="token operator">:</span> <span class="token string">"表格"</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        text<span class="token operator">:</span> <span class="token string">"三级菜单"</span><span class="token punctuation">,</span>        type<span class="token operator">:</span> <span class="token string">"ios-paper"</span><span class="token punctuation">,</span>        children<span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span>            type<span class="token operator">:</span> <span class="token string">"ios-notifications-outline"</span><span class="token punctuation">,</span>            name<span class="token operator">:</span> <span class="token string">"msg"</span><span class="token punctuation">,</span>            text<span class="token operator">:</span> <span class="token string">"查看消息"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            type<span class="token operator">:</span> <span class="token string">"md-lock"</span><span class="token punctuation">,</span>            name<span class="token operator">:</span> <span class="token string">"password"</span><span class="token punctuation">,</span>            text<span class="token operator">:</span> <span class="token string">"修改密码"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>            type<span class="token operator">:</span> <span class="token string">"md-person"</span><span class="token punctuation">,</span>            name<span class="token operator">:</span> <span class="token string">"userinfo"</span><span class="token punctuation">,</span>            text<span class="token operator">:</span> <span class="token string">"基本资料"</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>来看看怎么将它转化为菜单栏，我在这里使用了 <code>iview</code> 的组件，不用重复造轮子。</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 菜单栏 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span>  <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>asideMenu<span class="token punctuation">"</span></span>  <span class="token attr-name">theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dark<span class="token punctuation">"</span></span>  <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100%<span class="token punctuation">"</span></span>  <span class="token attr-name">@on-select</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gotoPage<span class="token punctuation">"</span></span>  <span class="token attr-name">accordion</span>  <span class="token attr-name">:open-names</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>openMenus<span class="token punctuation">"</span></span>  <span class="token attr-name">:active-name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>currentPage<span class="token punctuation">"</span></span>  <span class="token attr-name">@on-open-change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>menuChange<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 动态菜单 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(item, index) in menuItems<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Submenu</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.children<span class="token punctuation">"</span></span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Icon</span> <span class="token attr-name">:size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.size<span class="token punctuation">"</span></span> <span class="token attr-name">:type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.type<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowAsideTitle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item.text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(subItem, i) in item.children<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index + i<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Submenu</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subItem.children<span class="token punctuation">"</span></span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index + <span class="token punctuation">'</span>-<span class="token punctuation">'</span> + i<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Icon</span> <span class="token attr-name">:size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subItem.size<span class="token punctuation">"</span></span> <span class="token attr-name">:type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subItem.type<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowAsideTitle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{subItem.text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menuitem</span>            <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>menu-level-3<span class="token punctuation">"</span></span>            <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(threeItem, k) in subItem.children<span class="token punctuation">"</span></span>            <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>threeItem.name<span class="token punctuation">"</span></span>            <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index + i + k<span class="token punctuation">"</span></span>          <span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Icon</span> <span class="token attr-name">:size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>threeItem.size<span class="token punctuation">"</span></span> <span class="token attr-name">:type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>threeItem.type<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowAsideTitle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{threeItem.text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menuitem</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Submenu</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menuitem</span> <span class="token attr-name">v-else</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowAsideTitle<span class="token punctuation">"</span></span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subItem.name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Icon</span> <span class="token attr-name">:size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subItem.size<span class="token punctuation">"</span></span> <span class="token attr-name">:type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>subItem.type<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowAsideTitle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{subItem.text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menuitem</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Submenu</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menuitem</span> <span class="token attr-name">v-else</span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Icon</span> <span class="token attr-name">:size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.size<span class="token punctuation">"</span></span> <span class="token attr-name">:type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.type<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowAsideTitle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item.text}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menuitem</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">&gt;</span></span></code></pre><p>代码不用看得太仔细，理解原理即可，其实就是通过三次 <code>v-for</code> 不停的对子数组进行循环，生成三级菜单。</p><p>动态菜单这样就可以实现了。其实这里用递归会更好，因为不用写嵌套的<code>for</code>循环，万一有 5 层、6 层甚至更多</p><p><strong>动态路由</strong>，因为上面已经说过了用 <code>addRoutes</code> 来实现，现在看看具体怎么做。</p><p>首先，要把项目所有的页面路由都列出来，再用后台返回来的数据动态匹配，能匹配上的就把路由加上，不能匹配上的就不加。<br>最后把这个新生成的路由数据用 <code>addRoutes</code> 添加到路由表里。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 全部需要动态生成的路由</span><span class="token keyword">const</span> asyncRoutes <span class="token operator">=</span> <span class="token punctuation">{</span>  home<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"home"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"home"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../views/Home.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  t1<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"t1"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"t1"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../views/T1.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  password<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"password"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"password"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../views/Password.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  msg<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"msg"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"msg"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../views/Msg.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  userinfo<span class="token operator">:</span> <span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"userinfo"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"userinfo"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../views/UserInfo.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 后端传过来该角色需要生成的路由信息，前端来做对比，与asyncRoutes里面的路由对比，匹配到的添加进路由表</span><span class="token function">menusToRoutes</span><span class="token punctuation">(</span>menusData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将菜单信息转成对应的路由信息 动态添加</span><span class="token keyword">function</span> <span class="token function">menusToRoutes</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../components/Index.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    children<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token function">generateRoutes</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    path<span class="token operator">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span>    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"../components/Error.vue"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 最后添加404页面 否则会在登陆成功后跳到404页面</span>  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"*"</span><span class="token punctuation">,</span> redirect<span class="token operator">:</span> <span class="token string">"/error"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">generateRoutes</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>asyncRoutes<span class="token punctuation">[</span>item<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>    item<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      <span class="token comment">// 递归，子路由也是如此思路来生成</span>      <span class="token function">generateRoutes</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>项目的<a href="https://github.com/JingWZeng/vue-admin-template-iview">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> vue-admin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-admin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESLint超级详细</title>
      <link href="/2021/10/12/eslint-chao-ji-xiang-xi/"/>
      <url>/2021/10/12/eslint-chao-ji-xiang-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此文章转载于<a href="https://developer.51cto.com/art/202106/667105.htm###">从 ESLint 开始，说透我如何在团队项目中基于 Vue 做代码校验</a></p><p>解答了关于 ESLint 的很多疑惑，文章简明通俗易懂~~~</p></blockquote><p>最近遇到了一个老项目，比较有意思的是这个项目集前后端的代码于一起，而后端也会去修改前端代码，所以就出现了后端用 IntelliJ IDEA 来开发前端项目，而前端用 VSCode 来开发前端项目的情况。于是乎，出现了代码规范的问题，所以就有了这篇文章，整理了一下前端代码校验以及在 Vue 项目中的实践。</p><p>阅读完这篇文章，你可以收获：</p><ul><li>能够自己亲手写出一套 ESLint 配置;</li><li>会知道业界都有哪些著名的 JS 代码规范，熟读它们可以让你写出更规范的代码;</li><li>vue-cli 在初始化一个包含代码校验的项目时都做了什么;</li><li>Prettier 是什么?为什么要使用它?如何与 ESLint 配合使用?</li><li>EditorConfig 又是什么?如何使用?</li><li>如何在 VSCode 中通过插件来协助代码校验工作;</li><li>如何保证 push 到远程仓库的代码是符合规范的;</li></ul><p>下面开始阅读吧，如果你对 ESLint 比较熟悉，可以直接跳过这个部分。</p><h3 id="ESLint-是什么"><a href="#ESLint-是什么" class="headerlink" title="ESLint 是什么"></a>ESLint 是什么</h3><p>ESLint 是一个集代码审查和修复的工具，它的核心功能是通过配置一个个规则来限制代码的合法性和风格。</p><h2 id="配置解析器和解析参数"><a href="#配置解析器和解析参数" class="headerlink" title="配置解析器和解析参数"></a>配置解析器和解析参数</h2><p>ESLint 的解析器，早期的时候用的是 Esprima[1]，后面基于 Esprima v1.2.2 版本开发了一个新的解析器 Espree[2]，并且把它当做默认解析器。</p><p>除了使用 ESLint 自带的解析器外，还可以指定其他解析器：</p><ul><li>@babel/eslint-parser[3]：使 Babel 和 ESLint 兼容，对一些 Babel 语法提供支持;</li><li>@typescript-eslint/parser[4]：TSLint 被弃用后，TypeScript 提供了此解析器用于将其与 ESTree 兼容，使 ESLint 对 TypeScript 进行支持;</li></ul><p>为项目指定某个选择器的原则是什么?</p><ul><li>如果你的项目用到了比较新的 ES 语法，比如 ES2021 的 Promise.any()，那就可以指定 @babel/eslint-parser 为解析器;</li><li>如果项目是基于 TS 开发的，那就使用 @typescript-eslint/parser;</li></ul><p>“如果你对 ES 最新标准还不熟悉，可以看看这篇文章：送你一份精心总结的 3 万字 ES6 实用指南(下)</p><p>除了指定解析器 parser 外，还可以额外配置解析器参数 parserOption：</p><pre class="language-none"><code class="language-none">{    // ESLint 默认解析器，也可以指定成别的    parser: "espree",    parserOption: {        // 指定要使用的 ECMAScript 版本，默认值 5        ecmaVersion: 5,        // 设置为 script (默认) 或 module（如果你的代码是 ECMAScript 模块)        sourceType: "script",        // 这是个对象，表示你想使用的额外的语言特性,所有选项默认都是 false        ecmafeatures: {            // 是否允许在全局作用域下使用 return 语句            globalReturn: false,            // 是否启用全局 strict 模式（严格模式）            impliedStrict: false,            // 是否启用JSX            jsx: false,            // 是否启用对实验性的objectRest/spreadProperties的支持            experimentalObjectRestSpread: false        }    }}</code></pre><h2 id="指定环境-env"><a href="#指定环境-env" class="headerlink" title="指定环境 env"></a>指定环境 env</h2><p>指定不同的环境可以给对应环境下提供预设的全局变量。比如说在 browser 环境下，可以使用 window 全局变量;在 node 环境下，可以使用 process 全局变量等;</p><ul><li>ESLint 中可配置的环境比较多，这里有份完整的环境列表[5]，下面列出几个比较常见的：</li><li>browser：浏览器全局变量;</li><li>node：Node.js 全局变量和作用域;</li><li>es6：es6 中除了模块之外的其他特性，同时将自动设置 parserOptions.ecmaVersion 参数为 6;以此类推 ES2017 是 7，而 ES2021 是 12;</li><li>es2017：parserOptions.ecmaVersion 为 8;</li><li>es2020：parserOptions.ecmaVersion 为 11;</li><li>es2021：parserOptions.ecmaVersion 为 12;</li></ul><p>配置方式如下：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    env<span class="token operator">:</span> <span class="token punctuation">{</span>        browser<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        node<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        es6<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        commonjs<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        mocha<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        jquery<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以指定多个环境并不意味着配置的环境越多越好，实际配置的时候还是得依据当前项目的环境来选择。</p><h2 id="配置全局变量-globals"><a href="#配置全局变量-globals" class="headerlink" title="配置全局变量 globals"></a>配置全局变量 globals</h2><p>ESLint 的一些核心规则依赖于对代码在运行时可用的全局变量的了解。由于这些在不同环境之间可能会有很大差异，并且在运行时会进行修改，因此 ESLint 不会假设你的执行环境中存在哪些全局变量。</p><p>如果你想使用这些全局变量，那就可以通过 globals 来指定。比如在 react .eslintrc.js[6] 里就把 spyOnDev、 spyOnProd 等变量挂在了 global 下作为全局变量：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    globals<span class="token operator">:</span> <span class="token punctuation">{</span>        spyOnDev<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        spyOnProd<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对于它的值需要特别说明下：</p><ul><li>false、readable、readonly 这 3 个是等价的，表示变量只可读不可写;</li><li>true、writeable、writable 这 3 个是等价的，表示变量可读可写;</li></ul><h2 id="配置扩展-extends"><a href="#配置扩展-extends" class="headerlink" title="配置扩展 extends"></a>配置扩展 extends</h2><p>实际项目中配置规则的时候，不可能团队一条一条的去商议配置，太费精力了。通常的做法是使用业内大家普通使用的、遵循的编码规范;然后通过 extends 去引入这些规范。extends 配置的时候接受字符串或者数组：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'eslint:recommended'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:vue/essential'</span><span class="token punctuation">,</span>        <span class="token string">'eslint-config-standard'</span><span class="token punctuation">,</span> <span class="token comment">// 可以缩写成 'standard'</span>        <span class="token string">'@vue/prettier'</span><span class="token punctuation">,</span>        <span class="token string">'./node_modules/coding-standard/.eslintrc-es6'</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="从上面的配置，可以知道-extends-支持的配置类型可以是以下几种"><a href="#从上面的配置，可以知道-extends-支持的配置类型可以是以下几种" class="headerlink" title="从上面的配置，可以知道 extends 支持的配置类型可以是以下几种"></a>从上面的配置，可以知道 extends 支持的配置类型可以是以下几种</h3><ul><li>eslint 开头的：是 ESLint 官方的扩展;</li><li>plugin 开头的：是插件类型扩展，比如 plugin:vue/essential;</li><li>eslint-config 开头的：来自 npm 包，使用时可以省略前缀 eslint-config-，比如上面的可以直接写成 standard;</li><li>@开头的：扩展和 eslint-config 一样，只是在 npm 包上面加了一层作用域 scope;</li><li>一个执行配置文件的相对路径或绝对路径;</li></ul><p>那有哪些常用的、比较著名扩展可以被 extends 引入呢</p><ul><li>eslint:recommended：ESLint 内置的推荐规则，即 ESLint Rules 列表中打了钩的那些规则;</li><li>eslint:all：ESLint 内置的所有规则;</li><li>eslint-config-standard[7]：standard 的 JS 规范;</li><li>eslint-config-prettier[8]：关闭和 ESLint 中以及其他扩展中有冲突的规则;</li><li>eslint-config-airbnb-base：airbab 的 JS 规范;</li><li>eslint-config-alloy[9]：腾讯 AlloyTeam 前端团队出品，可以很好的针对你项目的技术栈进行配置选择，比如可以选 React、Vue(现已支持 Vue 3.0)、TypeScript 等;</li></ul><h2 id="使用插件-plugins"><a href="#使用插件-plugins" class="headerlink" title="使用插件 plugins"></a>使用插件 plugins</h2><h3 id="ESLint-提供插件是干嘛用的"><a href="#ESLint-提供插件是干嘛用的" class="headerlink" title="ESLint 提供插件是干嘛用的"></a>ESLint 提供插件是干嘛用的</h3><p>ESLint 虽然可以定义很多的 rules，以及通过 extends 来引入更多的规则，但是说到底只是检查 JS 语法。如果需要检查 Vue 中的 template 或者 React 中的 jsx，就束手无策了。所以引入插件的目的就是为了增强 ESLint 的检查能力和范围。</p><h3 id="如何配置插件"><a href="#如何配置插件" class="headerlink" title="如何配置插件"></a>如何配置插件</h3><p>ESLint 相关的插件的命名形式有 2 种：不带命名空间的和带命名空间的，比如：</p><ul><li>eslint-plugin- 开头的可以省略这部分前缀;</li><li>@/ 开头的;</li></ul><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"jquery"</span><span class="token punctuation">,</span> <span class="token comment">// 是指 eslint-plugin-jquery</span>    <span class="token string">"@jquery/jquery"</span><span class="token punctuation">,</span> <span class="token comment">// 是指 @jquery/eslint-plugin-jquery</span>    <span class="token string">"@foobar"</span><span class="token punctuation">,</span> <span class="token comment">// 是指 @foobar/eslint-plugin</span>  <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当需要基于插件进行 extends 和 rules 的配置的时候，需要加上插件的引用，比如：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'jquery'</span><span class="token punctuation">,</span>   <span class="token comment">// eslint-plugin-jquery</span>        <span class="token string">'@foo/foo'</span><span class="token punctuation">,</span> <span class="token comment">// @foo/eslint-plugin-foo</span>        '@bar<span class="token punctuation">,</span>      <span class="token comment">// @bar/eslint-plugin</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'plugin:jquery/recommended'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:@foo/foo/recommended'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:@bar/recommended'</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    rules<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">'jquery/a-rule'</span><span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>        <span class="token string">'@foo/foo/some-rule'</span><span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>        <span class="token string">'@bar/another-rule'</span><span class="token operator">:</span> <span class="token string">'error'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>以上配置来自 ESLint plugins[10]</p><h2 id="配置规则-rules"><a href="#配置规则-rules" class="headerlink" title="配置规则 rules"></a>配置规则 rules</h2><p>ESLint 提供了大量内置的规则，这里是它的规则列表 ESLint Rules，除此之外你还可以通过插件来添加更多的规则。</p><h3 id="规则的校验说明，有-3-个报错等级"><a href="#规则的校验说明，有-3-个报错等级" class="headerlink" title="规则的校验说明，有 3 个报错等级"></a>规则的校验说明，有 3 个报错等级</h3><ul><li>off 或 0：关闭对该规则的校验;</li><li>warn 或 1：启用规则，不满足时抛出警告，且不会退出编译进程;</li><li>error 或 2：启用规则，不满足时抛出错误，且会退出编译进程;</li></ul><p>通常规则只需要配置开启还是关闭即可;但是也有些规则可以传入属性，比如：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    rules<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">'quotes'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token string">'single'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// 如果不是单引号，则报错</span>        <span class="token string">'one-var'</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            <span class="token string">'var'</span><span class="token operator">:</span> <span class="token string">'always'</span><span class="token punctuation">,</span>  <span class="token comment">// 每个函数作用域中，只允许 1 个 var 声明</span>            <span class="token string">'let'</span><span class="token operator">:</span> <span class="token string">'never'</span><span class="token punctuation">,</span>   <span class="token comment">// 每个块作用域中，允许多个 let 声明</span>            <span class="token string">'const'</span><span class="token operator">:</span> <span class="token string">'never'</span><span class="token punctuation">,</span> <span class="token comment">// 每个块作用域中，允许多个 const 声明</span>        <span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如何知道某个扩展有哪些规则可以配置，以及每个规则具体限制?这里直接给出业内著名且使用比较多的规则列表的快速链接：</p><ul><li>ESLint rules，这整个列表对应 eslint:all，而打钩 ✔️ 的是 eslint:recommenmed;</li><li>Prettier rules</li><li>standard rules</li><li>airbnb rules</li><li>AlloyTeam vue rules</li></ul><h3 id="规则的优先级"><a href="#规则的优先级" class="headerlink" title="规则的优先级"></a>规则的优先级</h3><ul><li>如果 extends 配置的是一个数组，那么最终会将所有规则项进行合并，出现冲突的时候，后面的会覆盖前面的;</li><li>通过 rules 单独配置的规则优先级比 extends 高;</li></ul><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><h3 id="配置当前目录为-root"><a href="#配置当前目录为-root" class="headerlink" title="配置当前目录为 root"></a>配置当前目录为 root</h3><p>ESLint 检测配置文件步骤：</p><ol><li>在要检测的文件同一目录里寻找 .eslintrc.* 和 package.json;</li><li>紧接着在父级目录里寻找，一直到文件系统的根目录;</li><li>如果在前两步发现有 root：true 的配置，停止在父级目录中寻找 .eslintrc;</li><li>如果以上步骤都没有找到，则回退到用户主目录 ~/.eslintrc 中自定义的默认配置;</li></ol><p>通常我们都习惯把 ESLint 配置文件放到项目根目录，因此可以为了避免 ESLint 校验的时候往父级目录查找配置文件，所以需要在配置文件中加上 root: true。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>root<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><h3 id="添加共享数据"><a href="#添加共享数据" class="headerlink" title="添加共享数据"></a>添加共享数据</h3><p>ESLint 支持在配置文件添加共享设置，你可以添加 settings 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    settings<span class="token operator">:</span> <span class="token punctuation">{</span>        sharedData<span class="token operator">:</span> <span class="token string">'Hello'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>参考：ESLint 配置文件.eslintrc 参数说明[11]</p><h3 id="针对个别文件设置新的检查规则"><a href="#针对个别文件设置新的检查规则" class="headerlink" title="针对个别文件设置新的检查规则"></a>针对个别文件设置新的检查规则</h3><p>比如 webpack 的中包含了某些运行时的 JS 文件，而这些文件是只跑在浏览器端的，所以需要针对这部分文件进行差异化配置：</p><pre class="language-js" data-language="js"><code class="language-js">overrides<span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    files<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"lib/**/*.runtime.js"</span><span class="token punctuation">,</span> <span class="token string">"hot/*.js"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    env<span class="token operator">:</span> <span class="token punctuation">{</span>      es6<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      browser<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    globals<span class="token operator">:</span> <span class="token punctuation">{</span>      Promise<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    parserOptions<span class="token operator">:</span> <span class="token punctuation">{</span>      ecmaVersion<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>以上配置来自 webpack .eslintrc.js[12]</p><h3 id="如何校验"><a href="#如何校验" class="headerlink" title="如何校验"></a>如何校验</h3><p>上面细说了 ESLint 的各种配置项，以及针对 Vue 项目如何进行差异配置的说明。</p><p>现在我们知道了如何配置，但是你知道这些配置都是配置到哪里的吗?</p><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>ESLint 支持 3 种配置方式：</p><ul><li>命令行：不推荐，不做介绍;</li><li>单文件内注释：不推荐，不做介绍;</li><li>配置文件：配置文件的类型可以是好几种，比如：.js、.yml、json 等。推荐使用 .eslintrc.js;</li></ul><p>下面通过命令来生成一个配置文件：</p><pre class="language-js" data-language="js"><code class="language-js"># 安装 eslintnpm i eslint <span class="token operator">-</span><span class="token constant">D</span># 初始化一个配置文件npx eslint <span class="token operator">--</span>init</code></pre><p>最后会在当前目录生成一个 .eslintrc.js 文件。这里就不把代码贴出来了，没参考意义。</p><p>上面我们知道了可以将配置统一写到一个配置文件里，但是你知道该如何去触发这个配置文件的校验规则嘛?</p><h2 id="校验单个文件"><a href="#校验单个文件" class="headerlink" title="校验单个文件"></a>校验单个文件</h2><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 校验 a.js 和 b.js</span>npx eslint a<span class="token punctuation">.</span>js b<span class="token punctuation">.</span>js<span class="token comment">// 校验 src 和 scripts 目录</span>npx eslint src scripts</code></pre><h2 id="校验别的类型的文件"><a href="#校验别的类型的文件" class="headerlink" title="校验别的类型的文件"></a>校验别的类型的文件</h2><p>通常 ESLint 只能校验 JS 文件。比如需要校验 .vue 文件，光配置 vue 插件和 vue-eslint-parser 解析器是不够的，还需要让 ESLint 在查找文件的时候找到 .vue 文件。</p><p>可以通过 –ext 来指定具体需要校验的文件：</p><pre class="language-js" data-language="js"><code class="language-js">npx eslint <span class="token operator">--</span>ext <span class="token punctuation">.</span>js<span class="token punctuation">,</span><span class="token punctuation">.</span>jsx<span class="token punctuation">,</span><span class="token punctuation">.</span>vue src</code></pre><h2 id="自动修复部分校验错误的代码"><a href="#自动修复部分校验错误的代码" class="headerlink" title="自动修复部分校验错误的代码"></a>自动修复部分校验错误的代码</h2><p>rules 列表项中标识了一个扳手 🔧 图案的规则就标识该规则是可以通过 ESLint 工具自动修复代码的。如何自动修复呢?通过 –fix 即可。比如对于 ESLint Rules 里的这个 semi 规则，它就是带扳手图案的。</p><p>对于如下的 a.js 代码：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span></code></pre><p>当在配置文件配置了 ‘semi’: [2, ‘always’] 后，运行命令：</p><pre class="language-js" data-language="js"><code class="language-js">npx eslint <span class="token operator">--</span>fix a<span class="token punctuation">.</span>js</code></pre><p>校验直接就通过了，且会自动修复代码，在代码末尾自动加上分号。</p><h2 id="把校验命令加到-package-json"><a href="#把校验命令加到-package-json" class="headerlink" title="把校验命令加到 package.json"></a>把校验命令加到 package.json</h2><p>检验命令比较长，也难记，习惯上会把这些命名直接写到 package.json 里：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"lint"</span><span class="token operator">:</span> <span class="token string">"npx eslint --ext .js,.jsx,.vue src"</span><span class="token punctuation">,</span>        <span class="token string">"lint:fix"</span><span class="token operator">:</span> <span class="token string">"npx eslint --fix --ext .js,.jsx,.vue src"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="过滤一些不需要校验的文件"><a href="#过滤一些不需要校验的文件" class="headerlink" title="过滤一些不需要校验的文件"></a>过滤一些不需要校验的文件</h2><p>对于一些公共的 JS、测试脚本或者是特定目录下的文件习惯上是不需要校验的，因此可以在项目根目录通过创建一个 .eslintignore 文件来配置，告诉 ESLint 校验的时候忽略它们：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">public</span> <span class="token operator">/</span> src <span class="token operator">/</span> main<span class="token punctuation">.</span>js<span class="token punctuation">;</span></code></pre><p>除了 .eslintignore 中指定的文件或目录，ESLint 总是忽略 /node_modules/ 和 /bower_components/ 中的文件;因此对于一些目前解决不了的规则报错，但是如果又急于打包上线，在不影响运行的情况下，我们就可以利用 .eslintignore 文件将其暂时忽略。</p><h3 id="在-Vue-项目中的实践"><a href="#在-Vue-项目中的实践" class="headerlink" title="在 Vue 项目中的实践"></a>在 Vue 项目中的实践</h3><p>上面把 ESLint 的几乎所有的配置参数和校验方式都详细的介绍了一遍，但是如果想在项目中落地，仅仅靠上面的知识还是不够的。下面将细说如何在 Vue 中落地代码校验。</p><p>关于如何在 Vue 中落地代码校验，一般是有 2 种情况：</p><ul><li>通过 vue-cli 初始化项目的时候已经选择了对应的校验配置</li><li>对于一个空的 Vue 项目，想接入代码校验</li></ul><p>其实这 2 种情况最终的校验的核心配置都是一样的，只是刚开始的时候安装的包有所区别。下面通过分析 vue-cli 配置的代码校验，来看看它到底做了哪些事情，通过它安装的包以及包的作用，我们就会知道如何在空项目中配置代码校验了。</p><h2 id="通过-vue-cli-初始化的项目"><a href="#通过-vue-cli-初始化的项目" class="headerlink" title="通过 vue-cli 初始化的项目"></a>通过 vue-cli 初始化的项目</h2><p>如果你的项目最初是通过 vue-cli 新建的，那么在新建的时候会让你选</p><ul><li>是否支持 eslint;</li><li>是否开启保存校验;</li><li>是否开启提交前校验;</li></ul><p>如果都开启了话，会安装如下几个包：</p><ul><li>eslint：前面 2 大章节介绍的就是这玩意，ESLint 出品，是代码校验的基础包，且提供了很多内置的 Rules，比如 eslint:recommended 经常被作为项目的 JS 检查规范被引入;</li><li>babel-eslint：一个对 Babel 解析器的包装，使其能够与 ESLint 兼容;</li><li>lint-staged：请看后面 pre-commit 部分;</li><li>@vue/cli-plugin-eslint</li><li>eslint-plugin-vue</li></ul><p>下面重点介绍 @vue/cli-plugin-eslint 和 eslint-plugin-vue，说下这 2 个包是干嘛的。</p><h3 id="vue-cli-plugin-eslint"><a href="#vue-cli-plugin-eslint" class="headerlink" title="@vue/cli-plugin-eslint"></a>@vue/cli-plugin-eslint</h3><p>这个包它主要干了 2 件事情：</p><h3 id="第一件事"><a href="#第一件事" class="headerlink" title="第一件事"></a>第一件事</h3><p>往 package.json 里注册了一个命令：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"lint"</span><span class="token operator">:</span> <span class="token string">"vue-cli-service lint"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行这个命令之后，它会去检查和修复部分可以修复的问题。默认查找的文件是 src 和 tests 目录下所有的 .js,.jsx,.vue 文件，以及项目根目录下所有的 js 文件(比如，也会检查 .eslintrc.js)。</p><p>当然你也可以自定义的传入参数和校验文件：</p><pre class="language-js" data-language="js"><code class="language-js">vue<span class="token operator">-</span>cli<span class="token operator">-</span>service lint <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">...</span>files<span class="token punctuation">]</span></code></pre><p>支持的参数如下：</p><ul><li>–no-fix: 不会修复 errors 和 warnings;</li><li>–max-errors [limit]：指定导致出现 npm ERR 错误的最大 errors 数量;</li></ul><h3 id="第二件事"><a href="#第二件事" class="headerlink" title="第二件事"></a>第二件事</h3><p>增加了代码保存触发校验的功能 lintOnSave，这个功能默认是开启的。如果想要关闭这个功能，可以在 vue.config.js 里配置，习惯上只开启 development 环境下的代码保存校验功能：</p><pre class="language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  lintOnSave<span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">"development"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>lintOnSave 参数说明：</p><ul><li>true 或者 warning：开启保存校验，会将 errors 级别的错误在终端中以 WARNING 的形式显示。默认的，WARNING 将不会导致编译失败;</li><li>false：不开启保存校验;</li><li>error：开启保存校验，会将 errors 级别的错误在终端中以 ERROR 的形式出现，会导致编译失败，同时浏览器页面变黑，显示 Failed to compile。</li></ul><h3 id="eslint-plugin-vue"><a href="#eslint-plugin-vue" class="headerlink" title="eslint-plugin-vue"></a>eslint-plugin-vue</h3><p>eslint-plugin-vue 是对 .vue 文件进行代码校验的插件。</p><p>针对这个插件，它提供了这几个扩展</p><ul><li>plugin:vue/base：基础</li><li>plugin:vue/essential：预防错误的(用于 Vue 2.x)</li><li>plugin:vue/recommended：推荐的，最小化任意选择和认知开销(用于 Vue 2.x);</li><li>plugin:vue/strongly-recommended：强烈推荐，提高可读性(用于 Vue 2.x);</li><li>plugin:vue/vue3-essential：(用于 Vue 3.x)</li><li>plugin:vue/vue3-strongly-recommended：(用于 Vue 3.x)</li><li>plugin:vue/vue3-recommended：(用于 Vue 3.x)</li></ul><p>各扩展规则列表：vue rules</p><h3 id="看到这么一堆的扩展，是不是都不知道选哪个了"><a href="#看到这么一堆的扩展，是不是都不知道选哪个了" class="headerlink" title="看到这么一堆的扩展，是不是都不知道选哪个了"></a>看到这么一堆的扩展，是不是都不知道选哪个了</h3><p>代码规范的东西，原则还是得由各自的团队去磨合商议出一套适合大家的规则。不过，如果你用的是 Vue2，我这里可以推荐 2 套 extends 配置：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token comment">// Vue 官方示例上的配置</span>   <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'eslint:recommended'</span><span class="token punctuation">,</span> <span class="token string">'plugin:vue/recommended'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token comment">// 或者使用 AlloyTeam 团队那套</span>   <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'alloy'</span><span class="token punctuation">,</span> <span class="token string">'alloy/vue'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="配置和插件对应的解析器"><a href="#配置和插件对应的解析器" class="headerlink" title="配置和插件对应的解析器"></a>配置和插件对应的解析器</h3><p>如果是 Vue 2.x 项目，配置了 eslint-plugin-vue 插件和 extends 后，template 校验还是会失效，因为不管是 ESLint 默认的解析器 Espree 还是 babel-eslint 都只能解析 JS，无法解析 template 的内容。</p><p>而 vue-eslint-parser 只能解析 template 的内容，但是不会解析 JS，因此还需要对解析器做如下配置：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    parser<span class="token operator">:</span> <span class="token string">'vue-eslint-parser'</span><span class="token punctuation">,</span>    parseOptions<span class="token operator">:</span> <span class="token punctuation">{</span>        parser<span class="token operator">:</span> <span class="token string">'babel-eslint'</span><span class="token punctuation">,</span>        ecmaVersion<span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>        sourceType<span class="token operator">:</span> <span class="token string">'module'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'eslint:recommended'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:vue/recommended'</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'vue'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>参考：eslint-plugin-vue faq[13]</p><h2 id="让-Prettier-管控代码风格"><a href="#让-Prettier-管控代码风格" class="headerlink" title="让 Prettier 管控代码风格"></a>让 Prettier 管控代码风格</h2><p>针对 Prettier 不得不提出以下疑问?</p><ul><li>Prettier 是什么?</li><li>为什么有了 ESLint，还需要引入 Prettier 呢?它两之间有什么区别?</li><li>如何配置 Prettier?</li><li>Prettier 如何和 ESLint 结合使用?</li><li>Prettier 是什么</li></ul><p>用它自己的话来说：我是一个自以为是的代码格式化工具，而且我支持的文件类型很多，比如：</p><ul><li>JavaScript(包括实验中的特性)</li><li>JSX</li><li>Vue</li><li>TypeScript</li><li>CSS、Less、SCSS</li><li>HTML</li><li>JSON</li><li>Markdown</li></ul><p>以及还有一些其他类型的文件。</p><h3 id="Prettier-对比-ESLint"><a href="#Prettier-对比-ESLint" class="headerlink" title="Prettier 对比 ESLint"></a>Prettier 对比 ESLint</h3><p>我们知道 ESLint 负责了对代码的校验功能，并且主要提供了 2 类规则：</p><ul><li>检查格式化的规则</li><li>检查代码质量的规则</li></ul><p>说到底 ESLint 就是通过一条条的规则去限制代码的规范，但是这些规则毕竟是有限的，而且更重要的是这些规则的重点并不在代码风格上，所以单凭 ESLint 并不能完全的统一代码风格。</p><p>这个时候就需要引入 Prettier 了，因为它干的事就是只管代码格式化，不管代码质量。</p><p>“Prettier：在代码风格这一块，我一直拿捏的死死的。</p><h3 id="如何配置-Prettier"><a href="#如何配置-Prettier" class="headerlink" title="如何配置 Prettier"></a>如何配置 Prettier</h3><p>初始化操作：</p><pre class="language-js" data-language="js"><code class="language-js"># 安装包npm i prettier <span class="token operator">-</span><span class="token constant">D</span># 新建 <span class="token punctuation">.</span>prettierrc<span class="token punctuation">.</span>jsecho module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&gt;</span> <span class="token punctuation">.</span>prettierrc<span class="token punctuation">.</span>js# 新建 <span class="token punctuation">.</span>prettierignoreecho <span class="token operator">&gt;</span> <span class="token punctuation">.</span>prettierignore</code></pre><p>Prettier 支持可以配置参数不多，总共才 21 个，这里是所有参数的说明 prettier options[14]</p><p>所有参数都有默认值，也就是说即使你没有配置 .prettierrc.js，当你用 Prettier 去格式化代码的时候全部都会走默认配置。针对个别参数，你不想用默认设置的话，就可以在 .prettierrc.js 配置具体想要的值。</p><p>如下，把项目中会用到的参数进行一个说明：</p><pre class="language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  printWidth<span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token comment">//（默认值）单行代码超出 80 个字符自动换行</span>  tabWidth<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">//（默认值）一个 tab 键缩进相当于 2 个空格</span>  useTabs<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 行缩进使用 tab 键代替空格</span>  semi<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//（默认值）语句的末尾加上分号</span>  singleQuote<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 使用单引号</span>  quoteProps<span class="token operator">:</span> <span class="token string">"as-needed"</span><span class="token punctuation">,</span> <span class="token comment">//（默认值）仅仅当必须的时候才会加上双引号</span>  jsxSingleQuote<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 在 JSX 中使用单引号</span>  trailingComma<span class="token operator">:</span> <span class="token string">"all"</span><span class="token punctuation">,</span> <span class="token comment">// 不用在多行的逗号分隔的句法结构的最后一行的末尾加上逗号</span>  bracketSpacing<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//（默认值）在括号和对象的文字之间加上一个空格</span>  jsxBracketSameLine<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 把 &gt; 符号放在多行的 JSX 元素的最后一行</span>  arrowParens<span class="token operator">:</span> <span class="token string">"avoid"</span><span class="token punctuation">,</span> <span class="token comment">// 当箭头函数中只有一个参数的时候可以忽略括弧</span>  vueIndentScriptAndStyle<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//（默认值）对于 .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容</span>  embeddedLanguageFormatting<span class="token operator">:</span> <span class="token string">"off"</span><span class="token punctuation">,</span> <span class="token comment">// 不允许格式化内嵌的代码块，比如 markdown  文件里的代码块</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>“扩展阅读：关于 Trailing commas[15] 你或许想了解更多。</p><p>然后可以通过命令来格式化代码：</p><pre class="language-js" data-language="js"><code class="language-js"># 将格式化当前目录及子目录下所有文件npx prettier <span class="token operator">--</span>write <span class="token punctuation">.</span># 检查某个文件是否已经格式化npx prettier <span class="token operator">--</span>check src<span class="token operator">/</span>main<span class="token punctuation">.</span>js</code></pre><p>如果有些文件不想被 Prettier 格式化，可以将其写入到 .prettierignore 里：</p><pre class="language-js" data-language="js"><code class="language-js">build<span class="token operator">/</span><span class="token keyword">package</span><span class="token punctuation">.</span>json<span class="token keyword">public</span><span class="token operator">/</span>test<span class="token comment">/*.*</span></code></pre><h3 id="Prettier-和-ESLint-一起干活更配哦"><a href="#Prettier-和-ESLint-一起干活更配哦" class="headerlink" title="Prettier 和 ESLint 一起干活更配哦"></a>Prettier 和 ESLint 一起干活更配哦</h3><p>上面介绍了 Prettier 的具体配置，这里主要介绍和 ESLint 结合使用的配置和注意事项。</p><p>和 ESLint 配合使用需要用到 eslint-plugin-prettier 这个插件：</p><pre class="language-js" data-language="js"><code class="language-js">npm i eslint<span class="token operator">-</span>plugin<span class="token operator">-</span>prettier <span class="token operator">-</span><span class="token constant">D</span></code></pre><p>配置：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'prettier'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    rules<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">'prettier/prettier'</span><span class="token operator">:</span> <span class="token string">'error'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个插件的工作原理是先调用 Prettier 对你的代码进行格式化，然后会把格式化前后不一致的地方进行标记，通过配置 ‘prettier/prettier’: ‘error’ 此条规则会将标记地方进行 error 级别的报错提示，然后可以通过 ESLint 的 –fix 自动修复功能将其修复。</p><h3 id="冲突了怎么办"><a href="#冲突了怎么办" class="headerlink" title="冲突了怎么办"></a>冲突了怎么办</h3><p>通过前面的介绍，我们知道 ESLint 也是会对代码风格做一些限制的，而 Prettier 主要就是规范代码风格，所以在把它们结合一起使用的时候是存会在一些问题的。对于个别规则，会使得双方在校验后出现代码格式不一致的问题。</p><p>那么当 Prettier 和 ESLint 出现冲突之后，该怎么办呢?</p><p>用 Prettier 的话来说很简单，只要使用 eslint-config-prettier 就可以了。解决冲突的思路就是通过将这个包提供的扩展放到 extends 最后面引入，依据 rules 生效的优先级，所以它会覆盖前面起冲突的规则，比如：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'eslint:recommended'</span><span class="token punctuation">,</span>        <span class="token string">'prettier'</span><span class="token punctuation">,</span>  <span class="token comment">// 必须放最后</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>除了能覆盖和 ESLint 中起冲突的规则之外，eslint-config-prettier 还能覆盖来自以下插件的规则(只列了部分)：</p><ul><li>eslint-plugin-standard</li><li>eslint-plugin-vue</li></ul><p>那 eslint-config-prettier 到底提供了哪些覆盖规则呢?直接看这个列表：eslint-config-prettier rules</p><p>如果想覆盖某些插件的规则，需要引入对应插件的扩展，比如：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'standard'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:vue/recommended'</span><span class="token punctuation">,</span>        <span class="token string">'prettier/standard'</span><span class="token punctuation">,</span>      <span class="token comment">// 覆盖 eslint-config-stanard</span>        <span class="token string">'prettier/vue'</span><span class="token punctuation">,</span>           <span class="token comment">// 覆盖 eslint-plugin-vue</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>“提示：在 eslint-config-prettier 8.0.0 版本后，extends 不再需要为单独的插件引入对应扩展来覆盖冲突了，统一引入 ‘prettier’ 即可。</p><p>如果同时使用了 eslint-plugin-prettier 和 eslint-config-prettier 可以这么配置：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>   <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'plugin:prettier/recommended'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>它其实和下面这些配置是等价的：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'prettier'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// eslint-config-prettier 提供的，用于覆盖起冲突的规则</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'prettier'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// 注册 eslint-plugin-prettier 插件</span>    rules<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">'prettier/prettier'</span><span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>        <span class="token string">'arrow-body-style'</span><span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>        <span class="token string">'prefer-arrow-callback'</span><span class="token operator">:</span> <span class="token string">'off'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所以如果是在 Vue 2 项目中配置 ESLint 和 Prettier 会这么配置：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    parser<span class="token operator">:</span> <span class="token string">'vue-eslint-parser'</span><span class="token punctuation">,</span>    parseOptions<span class="token operator">:</span> <span class="token punctuation">{</span>        parser<span class="token operator">:</span> <span class="token string">'babel-eslint'</span><span class="token punctuation">,</span>        ecmaVersion<span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>        sourceType<span class="token operator">:</span> <span class="token string">'module'</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'eslint:recommended'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:vue/recommended'</span><span class="token punctuation">,</span>        <span class="token string">'plugin:prettier/recommended'</span><span class="token punctuation">,</span>  <span class="token comment">// 在前面 Vue 配置的基础上加上这行</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'vue'</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>其实如果你的项目是用 vue-cli 初始化的，且选择了 eslint + prettier 方案的话，生成的项目中，.eslintrc.js 配置文件中 extends 的配置是这样的：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">'plugin:vue/essential'</span><span class="token punctuation">,</span>        <span class="token string">'eslint:recommended'</span><span class="token punctuation">,</span>        <span class="token string">'@vue/prettier'</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>它的最后一项扩展是 @vue/prettier，这个对应的是 @vue/eslint-config-prettier 这个包，让我们看看这个包下面的 index.js 内容：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    plugins<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'prettier'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token keyword">extends</span><span class="token operator">:</span> <span class="token punctuation">[</span>        require<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'eslint-config-prettier'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        require<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'eslint-config-prettier/vue'</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    rules<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">'prettier/prettier'</span><span class="token operator">:</span> <span class="token string">'warn'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个和我们上面配置的内容是相差无几的，而引入 eslint-config-prettier/vue 是因为这个 @vue/eslint-config-prettier 包依赖的 eslint-config-prettier 版本是 ^6.0.0 版本的，所以在处理冲突的时候需要特别指定和对应类型插件匹配的扩展。</p><h2 id="让-EditorConfig-助力多编辑器开发吧"><a href="#让-EditorConfig-助力多编辑器开发吧" class="headerlink" title="让 EditorConfig 助力多编辑器开发吧"></a>让 EditorConfig 助力多编辑器开发吧</h2><p>EditorConfig[16] 是个啥玩意?它可以对多种类型的单文件进行简单的格式化，它提供的配置参数很少：</p><pre class="language-js" data-language="js"><code class="language-js"># 告诉 EditorConfig 插件，这是根文件，不用继续往上查找root <span class="token operator">=</span> <span class="token boolean">true</span># 匹配全部文件<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span># 设置字符集charset <span class="token operator">=</span> utf<span class="token operator">-</span><span class="token number">8</span># 缩进风格，可选 space、tabindent_style <span class="token operator">=</span> tab# 缩进的空格数，当 indent_style <span class="token operator">=</span> tab 将使用 tab_width# 否则使用 indent_sizeindent_size <span class="token operator">=</span> <span class="token number">2</span>tab_width <span class="token operator">=</span> <span class="token number">2</span># 结尾换行符，可选 lf、cr、crlfend_of_line <span class="token operator">=</span> lf# 在文件结尾插入新行insert_final_newline <span class="token operator">=</span> <span class="token boolean">true</span># 删除一行中的前后空格trim_trailing_whitespace <span class="token operator">=</span> <span class="token boolean">true</span># 匹配md结尾的文件<span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">.</span>md<span class="token punctuation">]</span>insert_final_newline <span class="token operator">=</span> <span class="token boolean">false</span>trim_trailing_whitespace <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><p>虽然它提供的格式化的配置参数很少，就 3 个，缩进风格、是否在文件末尾插入新行和是否删除一行中前后空格。但是它还是非常有必要存在的，理由有 3 个：</p><ul><li>能够在不同的编辑器和 IDE 中保持一致的代码风格;</li><li>配合插件打开文件即自动格式化，非常方便</li><li>支持格式化的文件类型很多;</li></ul><p>如果需要让以上的配置生效，还得在 VSCode 里安装 EditorConfig for VS Code 这个插件配合使用。</p><h3 id="重点来了"><a href="#重点来了" class="headerlink" title="重点来了"></a>重点来了</h3><p>可以看到 EditorConfig 和 Prettier 会存在一些重复的配置，比如都提供了对缩进的配置参数，所以在实际使用的时候需要避免它们，或者把他们的参数设置为一致。</p><h2 id="在-VSCode-中支持-ESLint"><a href="#在-VSCode-中支持-ESLint" class="headerlink" title="在 VSCode 中支持 ESLint"></a>在 VSCode 中支持 ESLint</h2><p>前面做的配置，都需要执行命令才能进行检查和修复代码，还是挺不方便的，如果我希望编辑完或者保存的时候去检查代码该如何做呢?可以直接在 IDE 里安装 ESLint 插件，因为我使用的是 VSCode，所以这里只介绍在 VSCode 中的配置。</p><ul><li>在使用前，需要把 ESLint 扩展安装到 VSCode 里，这里我就不细说安装步骤了。安装完成后，需要在设置里写入配置：</li><li>在 VSCode 左下角找到一个齿轮 ⚙ 图标，点击后选择设置选项，这个时候打开了设置面板;</li><li>然后在 VSCode 右上角找到打开设置(json)的图标，点击后，会打开 settings.json 文件;</li></ul><p>然后把以下配置贴进去即可;</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"eslint.alwaysShowStatus"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token comment">// 总是在 VSCode 显示 ESLint 的状态</span>    <span class="token string">"eslint.quiet"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>             <span class="token comment">// 忽略 warning 的错误</span>    <span class="token string">"editor.codeActionsOnSave"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token comment">// 保存时使用 ESLint 修复可修复错误</span>        <span class="token string">"source.fixAll"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token string">"source.fixAll.eslint"</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>配置说明，在 ESLint 2.0.4 版本开始：</p><ul><li>不需要通过 eslint.validate 来指定校验的文件类型了，已经自动支持了 .vue 文件;</li><li>editor.codeActionsOnSave 开启保存自动修复功能;</li></ul><p>当这样配置之后呢，每次编辑代码 ESLint 都会实时校验代码，且当保存的时候会自动 fix，是不是很方便呢。不过对于有些无法自动 fix 的代码就需要你手动去修改了，如果不想修改的话就可以配置 rules 把该条规则给关闭掉。</p><p>其实在团队开发的时候，最好把针对 VSCode 的配置，写一个文件跟随着项目，一起提交到远程仓库，这样的话就保证了项目成员都是用的这套配置。比如可以在项目根目录新建 .vscode/settings.json，然后写入上面的那串配置内容。</p><h2 id="在提交前做校验-pre-commit"><a href="#在提交前做校验-pre-commit" class="headerlink" title="在提交前做校验 pre-commit"></a>在提交前做校验 pre-commit</h2><p>以上只是通过 ESLint 自动修复能够修复的错误以及通过 Prettier 进行代码的格式化，但是在实际开发的时候难免会遇到无法 fix 的错误，可能开发人员也忘记修改，如果这个时候把代码提交到远程仓库，那就把糟糕的代码给提交上去了。</p><p>那么如何杜绝把糟糕的代码提交上去呢?可以通过配置 git hooks 的 pre-commit 钩子来实现这个目的。主要是利用了 husky[17] 和 lint-staged[18] 这 2 个包。husky 就是用来配置 git hooks 的，而 lint-staged 则是对拿到的 staged 文件进行处理，比如执行 npx eslint –fix 进行代码校验。</p><p>具体操作步骤如下：</p><p>1、执行以下命令：</p><pre class="language-js" data-language="js"><code class="language-js">npx mrm lint<span class="token operator">-</span>staged</code></pre><p>会自动安装 lint-staged 和 husky 并且在 package.json 里写入 lint-staged。</p><p>“注意：mrm 是一个自动化工具，它将根据 package.json 依赖项中的代码质量工具来安装和配置 husky 和 lint-staged，因此请确保在此之前安装并配置所有代码质量工具，如 Prettier 和 ESlint。</p><p>如果上面顺利会在 package.json 里写入 lint-staged，可以自行修改让它支持 .vue 文件的校验：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"lint-staged"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token string">"*.{js,vue}"</span><span class="token operator">:</span> <span class="token string">"eslint --cache --fix"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2、启动 git hooks</p><pre class="language-js" data-language="js"><code class="language-js">npx husky install</code></pre><p>经过上面的命令后，v6 版本的 husky 会在项目根目录新建一个 .husky 目录。如果是 v4 版本的则会写入到 package.json 里。</p><p>3、创建 pre-commit 钩子</p><pre class="language-js" data-language="js"><code class="language-js">npx husky add <span class="token punctuation">.</span>husky<span class="token operator">/</span>pre<span class="token operator">-</span>commit <span class="token string">"npx lint-staged"</span></code></pre><p>到这里后，git commit 前自动执行代码校验和修复的功能就算完成了。然后你可以试试修改文件，然后提交试试。</p><p><a href="https://s6.51cto.com/oss/202106/18/ee85e3e0b534a49c4fa3809ed4ff7944.png?x-oss-process=image/format,jpg"><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110121439749.jpeg" alt="img"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章比较长，前前后后讲了很多代码校验的东西，现在我们来梳理下。</p><p>首先用 ESLint 来做代码校验，它自带的 ruels 能提供 2 种类型的校验，分别是代码错误校验和代码格式校验，而 ESLint 本身的核心工作其实就是校验和修复错误的代码，而对格式化的规则提供的不多。</p><p>所以如果想要对代码格式化进行一个更加精细的配置则需要借助 Prettier，因为它是只负责风格的管控，所以用它再适合不过了。但是如果把 ESLint 和 Prettier 结合起来一起使用的话，就可能会出现规则的冲突了，毕竟它们两者都会对风格进行处理，所以这个时候就可以通过 eslint-config-prettier 这个扩展来把冲突的规则进行关闭，这个扩展不仅可以关闭和 ESLint 内置规则的冲突，还可以关闭实际项目中引用到的扩展规则的冲突，比如和 Vue、React、TypeScript、Flow 的冲突。</p><p>在把 ESLint 和 Prettier 结合的时候，我们希望让 ESLint 来检查代码错误，而 Prettier 校验代码风格，那么这个时候其实是有 2 个任务的，需要用 2 条命令来处理的。但是有了 eslint-plugin-prettier 这个插件后就可以很方便的把它们结合起来，当需要校验代码错误的时候 ESLint 自动会给你校验，当然前提是 VSCode 里必须按照 ESLint 插件，而当需要校验代码风格的时候 ESLint 就会调用 Prettier 的能力进行代码风格的检查。</p><p>文章的后面分别又细说了 EditorConfig 和提交代码前校验的处理，这里就不多讲了。</p><p>看到这里希望你对代码校验和规范有一个新的认识，不过我最希望的是你能够自己动手为你的项目配置一套校验规则。</p><p>参考资料</p><p>[1] <a href="http://esprima.org/">Esprima</a></p><p>[2] <a href="https://github.com/eslint/espree">Espree</a></p><p>[3] <a href="https://github.com/babel/babel/tree/main/eslint/babel-eslint-parser">@babel/eslint-parser</a></p><p>[4] <a href="https://github.com/typescript-eslint/typescript-eslint">@typescript-eslint/parser</a></p><p>[5] <a href="https://eslint.org/docs/user-guide/configuring/language-options#specifying-environments">Specifying Environments</a></p><p>[6] <a href="https://github.com/facebook/react/blob/master/.eslintrc.js">react .eslintrc.js</a></p><p>[7] <a href="https://github.com/standard/eslint-config-standard">eslint-config-standard</a></p><p>[8] <a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a></p><p>[9] <a href="https://github.com/AlloyTeam/eslint-config-alloy">eslint-config-alloy</a></p><p>[10] <a href="https://eslint.org/docs/user-guide/configuring/plugins#configuring-plugins">ESLint plugins</a></p><p>[11] <a href="https://gist.github.com/rswanderer/29dc65efc421b3b5b0442f1bd3dcd046">ESLint 配置文件.eslintrc 参数说明</a></p><p>[12] <a href="https://github.com/webpack/webpack/blob/master/.eslintrc.js">webpack .eslintrc.js</a></p><p>[13] <a href="https://eslint.vuejs.org/user-guide/#faq">eslint-plugin-vue</a></p><p>[14] <a href="https://prettier.io/docs/en/options.html#print-width">prettier options</a></p><p>[15] <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas#trailing_commas_in_functions">Trailing commas</a></p><p>[16] <a href="https://editorconfig.org/">EditorConfig</a></p><p>[17] <a href="https://typicode.github.io/husky/#/?id=install">husky</a></p><p>[18] <a href="https://github.com/okonet/lint-staged">lint-staged</a></p>]]></content>
      
      
      <categories>
          
          <category> ESLint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中使用JSX</title>
      <link href="/2021/09/30/vue-zhong-shi-yong-jsx/"/>
      <url>/2021/09/30/vue-zhong-shi-yong-jsx/</url>
      
        <content type="html"><![CDATA[<h3 id="JSX-使用理由"><a href="#JSX-使用理由" class="headerlink" title="JSX 使用理由"></a>JSX 使用理由</h3><p>每个组件上都有一个<code>render</code>函数,其写法是<code>this.$createElement('div', {}, [...])</code>,非常的不直观，<code>JSX</code>可以改进这种写法，使其更加直观方便。</p><blockquote><p>注意: 如果在组件上定义了<code>render</code>方法，则<code>Vue</code>将忽略<code>template</code>定义。因为 <code>template</code>最终还是需要编译成<code>render</code>的格式。</p></blockquote><h3 id="啥叫-JSX-呢"><a href="#啥叫-JSX-呢" class="headerlink" title="啥叫 JSX 呢"></a>啥叫 JSX 呢</h3><blockquote><p>JSX 是 JavaScript 的类似 XML 的语法扩展，没有任何定义的语义。</p></blockquote><p>通过<code>babel</code>将<code>JSX</code>转成<code>JS</code>。简单来说呢，<code>JSX</code>就是在<code>JS</code>中写类似<code>HTML</code>的语法。</p><p>如果使用的<code>Vue-cli</code>大于或等于 3.0 版本，那么就直接可以使用<code>JSX</code>的语法了。</p><h3 id="在-Vue-中使用-JSX-需要注意的地方"><a href="#在-Vue-中使用-JSX-需要注意的地方" class="headerlink" title="在 Vue 中使用 JSX 需要注意的地方"></a>在 Vue 中使用 JSX 需要注意的地方</h3><ul><li>要监听<code>JSX</code>中的事件，我们需要<code>“on”</code>前缀。 例如，将<code>onClick</code>用于单击事件。</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">render</span> <span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>绑定变量，注意这里不是使用<code>:</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">render</span> <span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>button content<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>generatedText<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>将<code>HTML</code>字符串设置为元素的内容，使用<code>domPropsInnerHTML</code>而不是使用<code>v-html</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">render</span> <span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>button domPropsInnerHTML<span class="token operator">=</span><span class="token punctuation">{</span>htmlContent<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>我们也可以展开一个大对象：</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">render</span> <span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>button <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>largeProps<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>    <span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="导入-JSX-组件"><a href="#导入-JSX-组件" class="headerlink" title="导入 JSX 组件"></a>导入 JSX 组件</h3><p>在<code>Vue</code>中使用<code>JSX</code>的另一个好处是，我们不再需要注册所需的每个组件。 我们只是导入和使用。组件的正常使用是需要注册的。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../components"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button primary<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Edit<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> vue-JSX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
            <tag> Vue-JSX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router基本使用</title>
      <link href="/2021/09/30/vue-router-ji-ben-shi-yong/"/>
      <url>/2021/09/30/vue-router-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="路由的基本使用方法"><a href="#路由的基本使用方法" class="headerlink" title="路由的基本使用方法"></a>路由的基本使用方法</h3><p><code>vue-router</code>的使用分为三步</p><ol><li><p>引入<code>vue-router</code>，并使用<code>Vue.use(VueRouter)</code></p></li><li><p>定义路由数组<code>const routes = {}</code>，并将数组<code>routes</code>传入<code>VueRouter实例</code>，并将实例暴露出去<code>export default new VueRouter({ routes})</code></p></li><li><p>将<code>VueRouter</code>实例引入到<code>main.js</code>，并注册到根<code>Vue</code>实例</p></li></ol><blockquote><p>注意：this.$route、this.$router</p><ul><li><p>this.$route：表示的是当前的路由信息。<code>this.$route.matched</code>是一个数组，包含了当前路由的所有的嵌套记录，即是<code>routes</code>配置中的对象数组，包括自己的信息和<code>children</code>数据。</p></li><li><p>this.$router：表示的是全局的路由信息。通过<code>vue</code>根实例中注入<code>router</code>实例，然后再注入到每个子组件，从而让整个应用都有路由功能。所有的页面都可以访问。比如常用的是<code>this.$router.push()</code>。如果提供了<code>path</code>，<code>params</code>会被忽略，例如：</p><p><code>this.$router.push({path: 'home', params: { page: 2}}) </code>这里的<code>params</code>会被忽略。同样的规则也适用于<code>router-link</code>的<code>to</code>属性</p></li></ul></blockquote><blockquote><p>使用<code>route-link</code>组件进行路径跳转</p><p>使用<code>router-view</code>组件进行路由对应内容展示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109291625624.jpg" alt="0"></p>]]></content>
      
      
      <categories>
          
          <category> Vue-router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
            <tag> Vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS小偏门</title>
      <link href="/2021/09/30/js-xiao-pian-men/"/>
      <url>/2021/09/30/js-xiao-pian-men/</url>
      
        <content type="html"><![CDATA[<ul><li><p>复制数组<code>array.concat()</code></p></li><li><p><code>console.table(obj)</code>用于对象或者对象数组。<code>console.clear()</code>清空控制台</p></li><li><p><code>eval()</code>参数是字符串，将字符串变成可执行的<code>JS</code>代码</p></li><li><p><code>a</code>标签的<code>href</code>的动态参数，可以设置为参数设置不同的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>a <span class="token operator">:</span>href<span class="token operator">=</span><span class="token string">"'www.ZJingW.blog?id='+userId"</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span><span class="token keyword">let</span> userId <span class="token operator">=</span><span class="token number">1111</span></code></pre></li><li><p>this 既不指向函数自身也不指向函数的词法作用域。this 实际上是在函数调用的时发生的绑定，<strong>它指向啥完全取决函数在哪里被调用</strong></p></li><li><p>调用栈-&gt;为了到达当前执行位置所调用的所有的函数 | 调用位置–&gt;当前正在执行的函数的前一个调用中</p></li><li><p><code>html5</code> 的<code>meta</code></p></li></ul><pre class="language-html" data-language="html"><code class="language-html">meta 有4个属性 name http-equiv charset content content和它们搭配使用，content ='具体的描述' name 主要用于描述网页content就是进一步说明name，也就是指定具体的name对象 http-equiv相当于http的文件头作用，比如说定义htt平参数啥的 1.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> //html5固定的写法,简写 2.X-UA-Compatible(浏览器采取何种版本渲染当前页面)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge,chrome=1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>//指定IE和Chrome使用最新版本渲染当前页面3.cache-control(指定请求和响应遵循的缓存机制)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cache-control<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no-cache<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施） public :缓存所有响应，但并非必须。因为max-age也可以做到相同效果 private :只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）maxage :表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用60 秒。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span>  <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cache-control<span class="token punctuation">"</span></span>  <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no-siteapp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>的作用是避免在移动端浏览时，被百度自动转码4.expires(网页到期时间)，就是网页资源过了设置这个时间之后，就重新请求资源是否改变，改变则更新5.refresh(自动刷新并指向某页面)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>refresh<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2; url=<span class="token punctuation">'</span>https://myblog-six.vercel.app/<span class="token punctuation">'</span><span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>//意思是2秒后跳转向我的博客6.Set-Cookie(cookie设定)如果网页过期，那么这个网页存在本地的cookie也会自动被删除<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Set-Cookie<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name,data<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> //格式</code></pre><ul><li><code>vh</code>就是当前屏幕可见高度的 1%，也就是说 <code>height:100vh === height:100%</code></li></ul><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">// 问题来了:固定页脚做法&lt;body&gt;&lt;main&lt;/main&gt;&lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;1.已知footer的高度，去设置&lt;main&gt;的最小高度min-height:calc(100vh - footer的高度)  // 注意 -的前后需要有空格，不然不生效2.未知footer的高度 利用flexBox。body设置flex，同时min-height:100vh，并把伸缩方向设置成column，mian设置成flex：1flex 只要设置了大于0的值，就获得可伸缩的特性如果main设置了flex:2 ,footer设置了flex:1 。那么main的高度是footer的两倍    body</span> <span class="token punctuation">{</span>  <span class="token property">min-height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main</span> <span class="token punctuation">{</span>  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> brown<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">footer</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><code>:first-child</code>表示在一组兄弟元素中的第一个元素。注意是相同的元素</li><li><code>text-shadow</code></li></ul><pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">    <span class="token selector">div</span> <span class="token punctuation">{</span>      <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>      <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>      <span class="token property">font-size</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>      <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector">.a</span> <span class="token punctuation">{</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> deeppink<span class="token punctuation">;</span>      <span class="token property">color</span><span class="token punctuation">:</span> #fff<span class="token punctuation">;</span>      <span class="token property">text-shadow</span><span class="token punctuation">:</span> 1px 1px black<span class="token punctuation">,</span> 1px -1px black<span class="token punctuation">,</span> -1px 1px black<span class="token punctuation">,</span> -1px<span class="token punctuation">,</span> -1px<span class="token punctuation">,</span> black<span class="token punctuation">;</span>      <span class="token comment">/* 没有背景颜色，相当于镶边效果  x y blur color x为负数，阴影在左，y为负数，阴影在右*/</span>    <span class="token punctuation">}</span>    <span class="token selector">.glow</span> <span class="token punctuation">{</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> #203<span class="token punctuation">;</span>      <span class="token property">color</span><span class="token punctuation">:</span> #ffc<span class="token punctuation">;</span>      <span class="token property">text-shadow</span><span class="token punctuation">:</span> 0 0 0.1em<span class="token punctuation">,</span> 0 0 0.3em<span class="token punctuation">;</span>      <span class="token comment">/* 没指定颜色，阴影就和文字一个颜色 */</span>    <span class="token punctuation">}</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>css<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>glow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>glow<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109171149919.png" alt="text-shodow"></p><ul><li><code>Set</code>方式去除字符串里面的重复字符</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Set</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>：添加某个值，返回 Set 结构本身。🤔<span class="token class-name">Set</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>：删除某个值，返回一个布尔值，表示删除是否成功。<span class="token class-name">Set</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>：返回一个布尔值，表示该值是否为Set的成员。<span class="token class-name">Set</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：清除所有成员，没有返回值。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109201517506.png" alt="image-20210920151716408"></p><ul><li><code>Object.defineProperty</code></li></ul><p>为对象新增属性或者修改属性的时候呢，有两种不同的方法：</p><ol><li>直接使用 = 赋值</li><li>使用<code>Object.defineProperty()</code>定义</li></ol><p>区别就是使用 = 的话，对象的该属性的<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都为<code>true</code>。</p><p>使用<code>defineProperty</code>的话，它们都是<code>false</code>,也就是该属性不可以被修改、被遍历、被删除。</p><p><code>configurable</code>:当且仅当该属性的<code>configurable</code>为<code>true</code>时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除</p><ul><li><code>URL</code>编码</li></ul><p>当期望获取一个可用的 URL 地址时，使用<code>encodeURI()</code><br>当需要对<code>URL</code>的参数进行编码时，使用<code>encodeURIComponent()</code>，如果它作用于整个<code>url</code>，它会编码<code>http://</code>导致完成后的不是一个可用的<code>url</code>地址<br><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html">关于<code>url</code>编码</a></p><ul><li>子组件想修改父组件的值并传给父组件</li></ul><p><code>vue</code>本身是单向数据流的，就是子组件不能直接修改父组件的值，如果子组件想更新父组件的值的话，可以利用<code>.sync</code>和<code>$emit(update:xxx)</code>。其实是简化了在子组件定义一个事件，父组件处理该事件。</p><p>子组件<code>son</code></p><p><code>this.$emit('update:myMsg',val);</code></p><p>父组件</p><p><code>&lt;son :my-msg.sync = "val"/&gt; //此处my-msg一定需要使用kebeb-base写法，驼峰是无效的</code></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json的字段说明</title>
      <link href="/2021/09/27/package-json-de-zi-duan-shuo-ming/"/>
      <url>/2021/09/27/package-json-de-zi-duan-shuo-ming/</url>
      
        <content type="html"><![CDATA[<blockquote><p>英文版的<code>package.json</code>介绍</p><p><a href="https://heynode.com/tutorial/what-packagejson/">https://heynode.com/tutorial/what-packagejson/</a></p></blockquote><h5 id="name"><a href="#name" class="headerlink" title="name"></a><code>name</code></h5><p><code>name</code>字段表示当前的文件名字，如果需要发布在<code>npm</code>上的话，作为唯一的标识。</p><h5 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h5><p><code>version</code>当前项目的版本，决定了该版本的所有依赖的版本。</p><h5 id="license"><a href="#license" class="headerlink" title="license"></a><code>license</code></h5><p><code>license</code>许可证，发布在<code>npm</code>的时候,许可证规定哪些人可以使用，哪些人不可以使用。</p><h5 id="author和contributors"><a href="#author和contributors" class="headerlink" title="author和contributors"></a><code>author</code>和<code>contributors</code></h5><pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"author"</span><span class="token operator">:</span> <span class="token string">"Jon Church jon@example.com https://www.osioslabs.com/#team"</span><span class="token punctuation">,</span><span class="token property">"contributors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Amber Matz"</span><span class="token punctuation">,</span><span class="token property">"email"</span><span class="token operator">:</span> <span class="token string">"example@example.com"</span><span class="token punctuation">,</span><span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.osiolabs.com/#team"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>作者和共享者，拥有<code>name</code> 、<code> email</code>、 <code> url</code>字段。</p><h5 id="description"><a href="#description" class="headerlink" title="description"></a><code>description</code></h5><p>发布在<code>npm</code>上的时候对该包的描述说明。</p><h5 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a><code>keywords</code></h5><p>作用跟<code>description</code>差不多，就是用于搜索引擎的关键字，说明字段而已。</p><h5 id="main"><a href="#main" class="headerlink" title="main"></a><code>main</code></h5><pre class="language-json" data-language="json"><code class="language-json"><span class="token property">"main"</span><span class="token operator">:</span><span class="token string">"src/index.js"</span></code></pre><p>定义项目的启动入口。如果你安装了包<code>foo-lib</code>，当你执行<code>require('foo-lib')</code>,返回的结果就是该文件<code>module.exports</code>暴露出来的属性。</p><h5 id="script"><a href="#script" class="headerlink" title="script"></a><code>script</code></h5><p>定义<code>npm run</code> 运行的脚本名字。</p><h5 id="repository"><a href="#repository" class="headerlink" title="repository"></a><code>repository</code></h5><p>它是仓库的意思，就是该项目放在了那个地方，例如<code>git</code>,属性有<code>type</code>、<code>url</code></p><h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a><code>dependencies</code></h5><p>生成依赖，它会下载到node_modules/文件夹中。 版本的符号关系如下</p><ul><li><code>^</code>: 不改变最左边的非零数字的更新，即可以在次要版本或补丁版本中进行更改，但不能在主要版本中进行更改。如果你写<code>^13.1.0</code>，运行时<code>npm update</code>，它可以更新到<code>13.2.0</code>，<code>13.3.0</code>甚至<code>13.3.1</code>，<code>13.3.2</code>等等，但不能更新到<code>14.0.0</code>或以上。限制的是最左边位置的数字。</li><li><code>~</code>：如果您<code>~0.13.0</code>在运行时编写<code>npm update</code>它可以更新到补丁版本：<code>0.13.1</code>可以，但<code>0.14.0</code>不是。限制的是中间位置的数字。</li><li><code>&gt;</code>：高于指定的版本的任何版本</li><li><code>&gt;=</code>：等于或高于指定的版本的任何版本</li><li><code>&lt;=</code>：等于或低于指定的版本的任何版本</li><li><code>&lt;</code>：低于指定的版本的任何版本</li><li><code>=</code>: 确切的版本</li><li><code>-</code>: 范围。例子：<code>2.1.0 - 2.6.2</code></li><li><code>||</code>: 组合。例子：<code>&lt; 2.1 || &gt; 2.6</code></li></ul><h5 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a><code>devDependencies</code></h5><p>开发依赖，不会在生产模式中使用这些资源的。安装的时候用<code>npm install --save-dev</code></p><h5 id="npmrc文件"><a href="#npmrc文件" class="headerlink" title=".npmrc文件"></a><code>.npmrc</code>文件</h5><p>有些团队有自己的私有的<code>npm</code>私有服,前端的话一些团队内的组件啦。如果想要拿到这里面的包的话就需要配置<code>npm</code>的下载镜像地址啦。该文件就是用来设置镜像地址的。</p><p>比如</p><p><code>@私有服:registry = https://npm.[私有服].cn/</code></p><p>当然该文件还有其他的一些配置项啦。</p>]]></content>
      
      
      <categories>
          
          <category> package.json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> package.json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx反向代理</title>
      <link href="/2021/09/27/nginx-fan-xiang-dai-li/"/>
      <url>/2021/09/27/nginx-fan-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><blockquote><p>正向代理</p><p>就是正常的客户端和服务端之间利用一部代理服务器来进行转发数据和缓存。但是这样有一个问题，就是服务端不知道请求是来自哪里？只有客户端知道。</p></blockquote><blockquote><p>反向代理</p><p>反向代理可以解决上述问题，服务器部分包括用于做反向代理的服务器和业务服务器，这样业务服务器就可以知道请求是来自代理服务器的，但是客户端不知道响应是来自哪里。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109261655203.png" alt="nginx2"></p><h4 id="nginx解决跨域的原理"><a href="#nginx解决跨域的原理" class="headerlink" title="nginx解决跨域的原理"></a><code>nginx</code>解决跨域的原理</h4><p>例如：</p><ul><li>前端server的域名为：<code>fe.server.com</code></li><li>后端服务的域名为：<code>dev.server.com</code></li></ul><p>现在我在<code>fe.server.com</code>对<code>dev.server.com</code>发起请求一定会出现跨域。</p><p>现在我们只需要启动一个<code>nginx</code>服务器，将<code>server_name</code>设置为<code>fe.server.com</code>,然后设置相应的<code>location</code>以拦截前端需要跨域的请求，最后将请求代理回<code>dev.server.com</code>。如下面的配置：</p><pre class="language-text" data-language="text"><code class="language-text">server {        listen       80;        server_name  fe.server.com;        location / {                proxy_pass dev.server.com;        }}</code></pre><p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code>访问<code>nginx</code>的<code>fe.server.com</code>属于同源访问，而<code>nginx</code>对服务端转发的请求不会触发浏览器的同源策略。</p><h3 id="nginx开启gzip代理"><a href="#nginx开启gzip代理" class="headerlink" title="nginx开启gzip代理"></a><code>nginx</code>开启<code>gzip</code>代理</h3><p>前端在打包的时候，一般不需要再<code>webpack</code>中配置<code>gzip</code>,让后端开启<code>gzip</code>压缩，浏览器得到压缩后的文件，自动解压缩。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡的意思就是让客户端的请求合理的分配到各个服务器上面，负载均衡在<code>nginx</code>中开启，还可以选择负载均衡的策略。后端还可以专门配一个虚拟服务器用来做静态资源服务器。</p><blockquote><p>具体的<code>nginx</code>配置可以参考</p><p><code>http://www.conardli.top/blog/article/前端工程化/前端开发者必备的nginx知识.html#负载均衡</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2021/09/27/hashmap/"/>
      <url>/2021/09/27/hashmap/</url>
      
        <content type="html"><![CDATA[<h4 id="HashMap的作用"><a href="#HashMap的作用" class="headerlink" title="HashMap的作用"></a><code>HashMap</code>的作用</h4><p><code>HashMap</code>哈希表，也叫做散列表。哈希表是一种比较特殊的数据结构，它遵循函数映射的思想，以<code>Key: Value</code>的方式存储数据。哈希表最大的特点是可以快速定位到要查找的数据，查询的时间复杂度接近O(1)。哈希表的原理并不复杂，简而言之就是根据<code>Key</code>来计算出存储位置，然后将数据放入该空间，查询时同样根据<code>Key</code>计算出存储位置后直接将相应的值取出。</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>根据<code>Key</code>来计算存储位置的计算规则我们称之为哈希函数。优化哈希表的关键就是表大小和哈希函数的选择。</p><p><strong>常用的哈希函数</strong></p><blockquote><p>除留取余法</p><p>这种方法应该是最常用的哈希定址方法了。H(x) = x % p假定哈希表长度为s,则p一般取不超过s的最大质数</p></blockquote><blockquote><p>直接定址法<br>比较常用的方法<br>H(x) = a * x + b</p></blockquote><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>哈希表还要解决的一个问题就是冲突，当选择了一个哈希函数之后，有可能不同的数据会计算出相同的key,比如H(x) = x % 5 这种算法，6 和 11 都会计算出1,此时就会产生冲突。如果不解决冲突，哈希表就无法构建出来。</p><p><strong>解决冲突的方法</strong></p><blockquote><p>链接地址法<br>将有冲突的数据放在一个链表里，当查询时会根据key查到链表的第一个节点，然后遍历整个链表，找到相应的值。</p></blockquote><blockquote><p>开放定址法<br>最具代表性的一种是线性探测法<br>H(x) = x % 5<br>数据样本: {5, 6, 8, 12, 11}<br>计算Key: { 0, 1, 3, 2, 1}<br>存储数组 [0, 1, 2, 3, 4, 5, 6, 7 …..]<br>  [5, 6, 12, 8, 11] 当存储11的时候，发现下标是1的位置以及被占据了，此时根据线性探测法的规则依次往后遍历，直到找到空的位置，所以在下标为4的位置填入11</p><p>线性探测法最大的问题是冲突累计，解决一个冲突的同时会占据别的key的位置，又造成了新的冲突。<br>改良的方法有二次方探测法和随机数探测法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端路由</title>
      <link href="/2021/09/27/qian-duan-lu-you/"/>
      <url>/2021/09/27/qian-duan-lu-you/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端路由的两个基本条件</p><ol><li>改变<code>url</code></li><li>页面不刷新</li></ol></blockquote><h3 id="Hash-路由"><a href="#Hash-路由" class="headerlink" title="Hash 路由"></a>Hash 路由</h3><ol><li><code>hash</code>只作用在浏览器，不会在请求中发送给服务器。</li><li><code>hash</code>发生变化时，浏览器并不会重新给后端发送请求加载页面。</li><li>修改<code>hash</code>时会在浏览器留下历史记录，可以通过浏览器返回按钮回到上一个页面。</li><li><code>hash</code> 发生变化时会触发 <code>hashchange</code> 事件，在该事件中可以通过 <code>window.location.hash</code> 获取到当前 hash 值。</li></ol><p>在添加路由的时候添加一个对象，包括<code>url</code>和跳转该地址的处理函数。hashchange 事件可以监听<code>url</code>的变化。</p><h3 id="History-路由"><a href="#History-路由" class="headerlink" title="History 路由"></a>History 路由</h3><p>利用<code>H5</code>的<code>history.pushState()</code>和<code>history.replaceState()</code>，分别可以添加和修改历史记录。它们是与 hash 一样具有修改<code>url</code>的功能，之后可以通过<code>windows</code>的<code>onpopstate</code>事件，来监听<code>url</code>的变化，进而处理该<code>url</code>的处理函数。</p><p>因为<code>History</code>路由改变的是浏览器的<code>url</code>,因为<code>url</code>改变了，此时如果手动的刷新页面，浏览器会认为是请求一个新的页面，但是新的页面是不存在的(因为<code>url</code>中显示的是通过<code>pushstate</code>加的记录，实际上没有对应的页面)，肯定会报错的！</p><p>所以需要配合后端，在服务端做<code>url</code>的重定向，就是如果找不到页面，那么就重定向到<code>index.html</code>,<code>vue</code>项目本身就是单页面应用，整个系统也只有一个<code>html</code></p><pre class="language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!--index.html--&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>router.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击跳转到 list<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>detail<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击跳转到 detail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">      <span class="token keyword">var</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      router<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"/list路由被添加进来啦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      router<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/detail"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      router<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> btn1 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      btn1<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/list"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> btn2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"detail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      btn2<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/detail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// router.js</span><span class="token keyword">function</span> <span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>routes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">/* 添加路由 */</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">re<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> re<span class="token punctuation">,</span> handler <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">/* 监听 url 变化  */</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">listen</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//路由切换</span>    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>      <span class="token string">"hashchange"</span><span class="token punctuation">,</span>      <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>hash <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>re<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token boolean">false</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">/* 前进到一个新的url  */</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">push</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">=</span> path <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">/* 替换成一个新的url  */</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">replace</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    path <span class="token operator">=</span> path <span class="token operator">||</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> i <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>      window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">?</span> i <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"#"</span> <span class="token operator">+</span> path    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">/* 返回到上一个url  */</span>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">back</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202110202059020.png" alt="router"></p>]]></content>
      
      
      <categories>
          
          <category> 路由 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尾调用</title>
      <link href="/2021/09/26/wei-diao-yong/"/>
      <url>/2021/09/26/wei-diao-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><blockquote><p>尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p></blockquote><p>需要注意的是最后一步不是指最后一行代码，甚至<code>return fn() - 1</code>,即使在同一行，也不是尾调用。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除<code>f()</code>的调用记录，只保留<code>g(3)</code>的调用记录。</p><p>这就叫做”尾调用优化”（<code>Tail call optimization</code>），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><blockquote><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p></blockquote><p>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（<code>stack overflow</code>）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">===</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 改成尾递归</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>total</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">===</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> total    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">*</span>total<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>递归函数的改写：</p><p>就是把内部变量改写成函数的参数。上述中需要用到的是total变量，把它改成函数的参数就可以。但是不太直观。这个时候可以利用柯里化<code>currying</code>,它的意思就是将多参数的函数转换成单参数的函数。例如：</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">currying</span><span class="token punctuation">(</span><span class="token parameter"><span class="token function">fx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">fx</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token comment">// call用来绑定作用域，防止乱跑，绑定的是f的作用域，m是f的函数参数，这个例子可以不用call</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span>total</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">===</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> total    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">*</span>total<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">const</span> f  <span class="token operator">=</span> <span class="token function">currying</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">// 120</span></code></pre><p>递归的本质是循环，循环可以用递归代替，但是用递归，就最好使用尾递归。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p><code>ES6的</code>尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><blockquote><p><code>arguments</code>：返回调用时函数的参数。</p><p><code>func.caller</code>：返回调用当前函数的那个函数。</p></blockquote><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真（不真实，看起来没有优化，如下图）。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109261152460.png"></p><p>看起来函数调用记录为5条，原因是没有开启严格模式，如果开启严格模式的话，禁止调式了,无法跟踪调用栈。</p>]]></content>
      
      
      <categories>
          
          <category> 函数式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2021/09/24/http/"/>
      <url>/2021/09/24/http/</url>
      
        <content type="html"><![CDATA[<h3 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h3><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109240942964.png" alt="image-20210924094205809"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>目的是为了保证客户端和服务端各自的可分发，就是为了确保对方是否确认收到，连接是否成功，也就是为啥<code>TCP</code>是可靠的连接</p><p>简要的说明就是利用<code>TCP</code>的标志<code>SYN</code>和<code>ACK</code>。发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名断。<code>TCP</code> 协议会再次以相同的顺序发送相同的数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109240946219.png" alt="image-20210924094620148"></p><h3 id="http无状态保存"><a href="#http无状态保存" class="headerlink" title="http无状态保存"></a>http无状态保存</h3><p><code>http</code>协议自身不具备保存之前发送的请求和响应的功能。如果为了实现保存状态的功能，可以利用cookie技术，<code>cookie</code>与<code>http</code>配合，就可以管理状态了。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241001237.png" alt="image-20210924100144178"></p><h3 id="URL和URI"><a href="#URL和URI" class="headerlink" title="URL和URI"></a>URL和URI</h3><p><code>URL</code>统一资源定定位符，也就是在浏览器中输入的地址，<code>URI</code>统一资源标识符，用来标识服务器中具体的某一个资源，也就是请求体内容。<code>URI</code>包含<code>URL</code></p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p><code>HEAD</code>方法和<code>GET</code>方法一样，只是不返回报文主体部分。用于确认<code>URI</code>的有效性及资源更新的日期时间等。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p><code>DELETE</code> 方法用来删除文件，是与<code>PUT</code>相反的方法(上传文件)。<code>DELETE</code>方法按请求<code>URI</code>删除指定的资源。但是，<code>HTTP/1.1</code>的<code>DELETE</code>方法本身和<code>PUT</code>方法一样不带验证机制，所以一般的<code>Web</code>网站也不使用<code>DELETE</code>方法。当配合<code>Web</code>应用程序的验证机制，或遵守<code>REST</code>标准时还是有可能会开放使用的。</p><h3 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h3><p> <code>OPTIONS</code>方法用来查询针对请求<code>URI</code>指定的资源支持的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241014932.png" alt="image-20210924101436881"></p><h3 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h3><p>TRACE 方法是让 Web 服务器端将之前的请求经过的路径返回的发放。发送请求时，在<code>Max-Forwards</code>首部字段中填入数值，每经过一个服务器端就将该数字减<code>1</code>，当数值刚好减到<code>0 </code>时，就停止继续传输，最后接收到请求的服务器端则返回状态码<code>200 OK</code>的响应。客户端通过 <code>TRACE</code>方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，<code>TRACE</code>方法就是用来确认连接过程中发生的一系列操作。但是，<code>TRACE</code>方法本来就不怎么常用，再加上它容易引发<code>XST</code>（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241017163.png" alt="image-20210924101739103"></p><h3 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h3><p><code>CONNECT</code>方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行<code>TCP</code>通信。主要使用<code>SSL</code>（Secure Sockets Layer，安全套接层）和<code>TLS</code>（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<code>CONNECT</code>方法的格式如下所示。</p><p><code>CONNECT 代理服务器名:端口号 HTTP版本</code></p><h3 id="http1-1新增的持久连接alive"><a href="#http1-1新增的持久连接alive" class="headerlink" title="http1.1新增的持久连接alive"></a>http1.1新增的持久连接alive</h3><p>持久连接就是建立一次<code>TCP</code>连接，只要任意一段没有断开连接，就可以保持<code>TCP</code>的连接，可以在这个连接中发送多次的<code>http</code>请求。在<code>http1.1</code>中，所有的连接默认都是持久连接。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241028553.png" alt="image-20210924102855479"></p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241032880.png" alt="image-20210924103216826"></p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><code>Cookie</code>会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存<code>Cookie</code>。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 <code>Cookie</code>值后发送出去。服务器端发现客户端发送过来的<code>Cookie</code>后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241036362.png" alt="image-20210924103615311"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241036604.png" alt="image-20210924103624559"></p><h3 id="服务端两种编码方式"><a href="#服务端两种编码方式" class="headerlink" title="服务端两种编码方式"></a>服务端两种编码方式</h3><ul><li>压缩</li></ul><p><code>gzip</code>压缩之后发给客户端，客户端解压缩该实体。属于内容编码的一种，内容编码指明应用在实体内容上的编码格式，并报出实体信息原样的压缩。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241049574.png" alt="image-20210924104947519"></p><ul><li>分割</li></ul><p>在<code>HTTP</code>通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码<code>Chunked TransferCoding</code></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241051913.png" alt="image-20210924105147859"></p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>比如一个图片下载中断，从中断处开始返回数据给客户端，就是范围请求。用<code>Range</code>来指定<code>byte</code>的范围</p><p><code>Range: bytes = 5001-10000</code></p><p>针对范围请求，响应会返回状态码为206 <code>Partial Content</code>(部分内容),对于多重范围的范围请求，响应会在首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code>后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码<code>200 OK</code>和完整的实体内容</p><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。比如需要显示中文还是英文。</p><p><code>Accept</code></p><p><code>Accept-Charset</code></p><p><code>Accept-Encoding</code></p><p><code>Accept-Language</code></p><p><code>Content-Language</code></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table><thead><tr><th align="center"></th><th align="center">类别</th><th align="center">原因短语</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息性状态码</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">成功状态码</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">重定向状态码</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误状态码</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">服务器错误状态码</td><td align="center">服务器处理请求出错</td></tr></tbody></table><ul><li>204 No Content</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241400622.png" alt="image-20210924140001523"></p><ul><li><p>206 Partial Content </p><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241400521.png" alt="image-20210924140040466"></p><ul><li>301 Moved Permanently(永久性的) 永久重定向</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241402164.png" alt="image-20210924140247109"></p><ul><li>302 Found 临时重定向</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241403706.png" alt="image-20210924140353652"></p><ul><li>303 See Other</li></ul><p>表示由于请求对应的资源存在另一个<code>url</code>,应该使用<code>get</code>方向定向获取请求的资源，与302有相同的功能，但是303明确表示客户端应该使用<code>get</code>方法获取</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241404090.png" alt="image-20210924140432027"></p><ul><li>304 Not Modified</li></ul><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 <code>3XX</code>类别中，但是和重定向没有关系。附带条件的请求是指采用<code>GET</code>方法的请求报文中包含<code>If-Match</code>，<code>If-Modified-Since</code>，<code>If-None-Match</code>，<code>If-Range</code>，<code>If-Unmodified-Since</code> 中任一首部。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241408325.png" alt="image-20210924140830269"></p><ul><li>307 Temporary(临时的) Redirect</li></ul><p>临时重定向，和302的含义相同。不同的就是307不会把<code>post</code>请求变成<code>get</code>请求，而302会把<code>post</code>请求变成<code>get</code>请求再重新向新的<code>url</code>发一次请求。</p><ul><li>400 Bad Request </li></ul><p>请求报文中存在语法错误，需要修改请求的内容后再次发送请求。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241413872.png" alt="image-20210924141359814"></p><ul><li>401 Unauthorized(未经授权的)</li></ul><p>需要认证的时候会返回401，第一次返回一个窗口用来填认证信息。第二次返回401，表示认证信息错误。</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241415442.png" alt="image-20210924141558351"></p><ul><li>403 Forbidden 禁止访问</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241417243.png" alt="image-20210924141732185"></p><ul><li>500 Internal Server Error</li></ul><p>服务器在执行请求的时候发生了错误</p><ul><li>503 Service Unavailable（无法使用）</li></ul><p>服务器无法使用</p><h3 id="网关、代理、隧道"><a href="#网关、代理、隧道" class="headerlink" title="网关、代理、隧道"></a>网关、代理、隧道</h3><ul><li>代理就是充当”中间人”的角色,作用有 ①利用缓存技术，缓存资源在代理服务器上②对网站做访问控制③获取访问日志</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241431465.png" alt="image-20210924143126370"></p><ul><li>网关和代理类似，也是”中间人”的角色，但是网关还可以进行协议的转换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241431063.png" alt="image-20210924143114001"></p><ul><li>隧道的目的是为了保证客户端和服务端进行安全的通行。与服务器之间建立一条通信线路，加<code>ssl</code>等加密手段进行通行。隧道不会解析<code>http</code>请求，隧道会在通信双方断开连接时结束。它是透明的，客户端不用在意隧道是否存在。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241434105.png" alt="image-20210924143454048"></p><h3 id="常用的首部字段说明"><a href="#常用的首部字段说明" class="headerlink" title="常用的首部字段说明"></a>常用的首部字段说明</h3><p><strong>全部字段表</strong></p><ol><li>通用首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241523112.png" alt="image-20210924152325070"></p><ol start="2"><li>请求首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241524827.png" alt="image-20210924152336694"></p><ol start="3"><li>响应首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241524179.png" alt="image-20210924152432141"></p><ol start="4"><li>实体首部字段</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241524746.png" alt="image-20210924152459708"></p><p><strong>Cache-Control</strong> </p><p>HTTP/1.1之前的字段是<code>Pragma</code>,为了兼容可以这样写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">Cache<span class="token operator">-</span>Control<span class="token operator">:</span> no<span class="token operator">-</span>cachePragma<span class="token operator">:</span> no<span class="token operator">-</span>cache</code></pre><blockquote><p>缓存请求指令</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241456764.png" alt="image-20210924145651720"></p><blockquote><p>缓存响应指令</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241457014.png" alt="image-20210924145724967"></p><ul><li><code>no-cache</code>指令的目的是为了防止从缓存中返回过期的资源。客户端不接受缓存过的响应，必须向服务器转发该请求。<code>no-cache</code>代表不缓存过期的资源，而<code>no-store</code>才是代表不缓存。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241459585.png" alt="image-20210924145931526"></p><ul><li><code>max-age</code>，没有超过这个时间，缓存服务器直接返回资源就可以，不需要通知源服务器，为0的时候代表缓存服务器需要将请求转发给源服务器。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241507772.png" alt="image-20210924150717700"></p><ul><li><code>no-transform</code>可以防止缓存服务器或者代理服务器压缩图片等操作。</li></ul><p><strong>Connection</strong></p><ol><li>控制不再转发给代理的首部字段</li></ol><p><code>Connection:不再转发的首部字段名</code></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241516619.png" alt="image-20210924151610550"></p><ol start="2"><li>管理持久化连接</li></ol><p><code>Connection:close</code></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241516041.png" alt="image-20210924151652996"></p><p><code>HTTP/1.1</code>的默认连接都是持久连接<code>Connection:keep-alive</code></p><p><strong>If-xxx</strong> </p><p>这种请求首部字段被称为条件请求。服务器接收到附带的条件之后，只有判断指定条件为真，才会执行请求。</p><ul><li><code>If-Match</code>和服务器的<code>ETag</code>一致，服务器会接受请求。设置为*的时候，只要资源存在就进行处理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241547218.png" alt="image-20210924154757101"></p><ul><li><code>If-Modified-Since</code>指定的日期时间后，资源发生了更新，服务器会接受请求</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241549636.png" alt="image-20210924154924519"></p><ul><li><code>If-None-Match</code> 字段值与服务器的<code>ETag</code>不一致的时候，可处理该请求。与<code>If-Match</code>相反。通常在<code>get</code>方法中用来获取最新的资源，随便指定一个服务器没有的数据，就可以了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109241553487.png" alt="image-20210924155359416"></p><ul><li><code>If-Range</code> 也是需要和服务端的<code>ETag</code>进行比较的，如果一致的话就返回需要的范围资源，如果不一致的话就返回需要的所有的资源。如果不使用<code>If-Range</code>的话，那么遇到这种情况客户端和服务端之间需要进行两次请求。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251336101.png" alt="image-20210925133639867"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251337330.png" alt="image-20210925133707273"></p><ul><li><code>Referer（来路）</code>可以查看请求的<code>URL</code>是从哪个<code>Web</code>页面发起的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251348612.png" alt="image-20210925134831560"></p><ul><li><code>ETag</code>是将资源以字符串的形势作为唯一标识的方式。服务器会为每份资源分配对应的<code>ETag</code>值。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251353514.png" alt="image-20210925135339470"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251354945.png" alt="image-20210925135414911"></p><ul><li><code>Vary</code>规定代理服务器只能缓存相同字段值的资源。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251358223.png" alt="image-20210925135831172"></p><ul><li><p><code>Content-MD5</code>客户端会对接受的报文主体执行相同的<code>MD5</code>算法，然后用来跟该字段的值进行比较。从而保证报文内容的完整性，但是需要注意的是这样是没有办法知道报文是否被篡改的，因为如果报文内容被篡改的话，那么报文的<code>MD5</code>也一样可以被篡改。</p></li><li><p><code>Expries(过期)</code>告诉客户端该资源的失效日期。如果是缓存服务器的话，在这个日期之前，资源的副本一直保存着，过了这个日期之后呢，就会转向源服务器请求资源。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251410919.png" alt="image-20210925141034872"></p><ul><li><p><code>Last-Modified</code>资源的最后修改时间</p></li><li><p><code>Cookie</code></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251412001.png" alt="image-20210925141248958"></p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251413667.png" alt="image-20210925141309637"></p><blockquote><ol><li><p>expires 不显示指定的话，就是会话的Cookie。Cookie一旦被发送到客户端，服务端是没有办法显示删除该Cookie的，但是可以通过覆盖过期的Cookie，来间接的对客户端的Cookie进行删除</p></li><li><p>path 收到cookie的文件目录范围</p></li><li><p>domain 比如，当指定 <code>example.com</code> 后，除 <code>example.com</code> 以外，<code>www.example.com</code>或 <code>www2.example.com</code> 等都可以发送 Cookie</p></li><li><p>HttpOnly 无法使用<code>document.cookie</code>拿到Cookie的内容</p></li></ol></blockquote><h3 id="HTTPS的加密原理"><a href="#HTTPS的加密原理" class="headerlink" title="HTTPS的加密原理"></a>HTTPS的加密原理</h3><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251433704.png" alt="image-20210925143346605"></p><p>简单来说就是利用非对称加密来传输对称加密需要用到的密钥。而证书机构就是用来判断该服务器是我想要访问的那个服务器。</p><h3 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h3><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251450631.png" alt="image-20210925145036564"></p><p>步骤 1：客户端把用户<code>ID</code>和密码等登录信息放入报文的实体部分，通常是以<code>POST</code>方法把请求发送给服务器。而这时，会使用<code>HTTPS</code>通信来进行<code>HTML</code>表单画面的显示和用户输入数据的发送。</p><p>步骤 2：服务器会发放用以识别用户的<code>Session ID</code>。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与<code>Session ID </code>绑定后记录在服务器端。向客户端返回响应时，会在首部字段 <code>Set-Cookie</code> 内写入 <code>SessionID</code>（如PHPSESSID=028a8c…）。你可以把 <code>Session ID</code> 想象成一种用以区分不同用户的等位号。然而，如果<code>Session ID</code>被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止<code>Session ID</code>被盗，或被猜出。为了做到这点，<code>Session ID</code> 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（<code>XSS</code>）造成的损失，建议事先在<code>Cookie</code>内加上<code>httponly </code>属性。</p><p>步骤 3：客户端接收到从服务器端发来的<code>Session ID</code>后，会将其作为<code>Cookie</code>保存在本地。下次向服务器发送请求时，浏览器会自动发送<code>Cookie</code>，所以<code>Session ID</code>也随之发送到服务器。服务器端可通过验证接收到的<code>Session ID</code>识别用户和其认证状态。</p><ul><li>还有一种方式是利用”加盐”处理,密码加盐<code>salt</code>，然后使用散列函数计算出散列值进行保存。<code>salt</code>其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。当两个用户使用了同一个密码时，由于随机生成的<code>salt</code>值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解</li></ul><h3 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h3><ol><li><code>AJax</code>异步更新</li><li><code>WebsScoket</code>客户端和服务端之间建立全双工的通信</li></ol><h3 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h3><ol><li>主动攻击，攻击的对象是服务器的资源，代表的有<code>SQL</code>注入攻击和<code>OS</code>命令注入</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251507169.png" alt="image-20210925150757117"></p><ol start="2"><li>被动攻击，利用圈套执行攻击代码。比如<code>Xss</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251509357.png" alt="image-20210925150903303"></p><ul><li><p>跨站脚本攻击（<code>Cross-Site Scripting，XSS</code>）是指通过存在安全漏洞的<code>Web</code>网站注册用户的浏览器内运行非法的<code>HTML</code>标签或<code>JavaScript</code>进行的一种攻击。动态创建的HTML代码可能是恶意的。</p></li><li><p><code>SQL</code>注入攻击：是指针对<code>Web</code>应用使用的数据库，通过运行非法的<code>SQL</code>而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。</p></li><li><p><code>OS</code>命令注入攻击（<code>OS Command Injection</code>）是指通过<code>Web</code>应用，执行非法的操作系统命令达到攻击的目的。只要在能调用<code>Shell</code>函数的地方就有存在被攻击的风险。</p></li><li><p>跨站点请求伪造（<code>Cross-Site Request Forgeries</code>，<code>CSRF</code>）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109251535087.png" alt="image-20210925153502013"></p><ul><li>其他</li></ul><ol><li>密码破解: 顾名思义</li><li>点击劫持：点击劫持（<code>Clickjacking</code>）是指利用透明的按钮或链接做成陷阱，覆盖在 <code>Web</code>页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（<code>UIRedressing</code>）。</li><li><code>Dos</code>攻击: 就是利用大量计算机对网站发起请求，导致服务器处理不过来停止掉。多台计算机发起的<code>DoS</code>攻击就叫做<code>DDoS</code>。</li><li>后门程序： 后门程序（<code>Backdoor</code>）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中一些深入概念</title>
      <link href="/2021/09/15/js-zhong-yi-xie-shen-ru-gai-nian/"/>
      <url>/2021/09/15/js-zhong-yi-xie-shen-ru-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>原型对象(<code>Person.prototype</code>) 是通过<code>Object</code>构造函数生成的，而实例的<code>__proto__</code>指向构造函数的<code>prototype</code>。这就是为啥原型链中最后指向的是<code>Object</code>。<code>null</code>代表没有对象，也就是<code>null</code>在此处表明无原型。蓝色的线就是所谓的原型链</p><p><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202109151017423.png" alt="prototype5"></p><p><em><strong>注意</strong></em></p><ul><li><code>constructor</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><p>当获取 <code>person.constructor </code>时，其实 <code>person </code>中并没有<code>constructor</code>属性,当不能读取到<code>constructor</code> 属性时，会从 <code>person</code>的原型也就是 <code>Person.prototype</code> 中读取，正好原型中有该属性，所以：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor</code></pre><ul><li><code>__proto__</code></li></ul><p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 <code>Person.prototype</code> 中，实际上，它是来自于<code> Object.prototype</code> ，与其说是一个属性，不如说是一个 <code>getter/setter</code>，当使用<code> obj.__proto__</code>时，可以理解成返回了 <code>Object.getPrototypeOf(obj)</code>。</p><ul><li>继承实质</li></ul><p>每一个对象都会从原型”继承”属性，引用《你不知道的JavaScript》中的话:</p><blockquote><p>继承意味着复制操作，然而<code>JavaScript</code>默认并不会复制对象的属性，相反，<code>JavaScript</code> 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p></blockquote><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>啥叫作用域？作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p><code>JavaScript</code>采用词法作用域，也就是静态作用域：函数的作用域在函数定义的时候就决定了。</p><p><strong>动态作用域是在函数调用的时候才决定的</strong></p><p>这个点是经常知道但是又经常搞错的地方，时刻记住函数在哪里调用并不重要，重要的函数定义在哪里。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 结果是 ??? 1</span></code></pre><p>假设<code>JavaScript</code>采用静态作用域，让我们分析下执行过程：</p><p>执行<code> foo</code> 函数，先从<code> foo</code> 函数内部查找是否有局部变量<code> value</code>，如果没有，就根据书写的位置，查找上面一层的代码，也就是 <code>value</code> 等于 1，所以结果会打印 1。</p><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>执行 <code>foo</code> 函数，依然是从 <code>foo</code> 函数内部查找是否有局部变量<code> value</code>。如果没有，就从调用函数的作用域，也就是<code> bar</code> 函数内部查找<code> value</code> 变量，所以结果会打印 2。</p><p>前面我们已经说了，<code>JavaScript</code>采用的是静态作用域，所以这个例子的结果是 1。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p><strong><code>JavaScript</code>永远都不是简单的顺序执行的</strong>。当执行一个函数的时候，就会创建一个执行上下文，并且把该执行上下文压入执行上下文栈。<code>JavaScript</code>创建一个执行上下文栈来管理所有的执行上下文。顾名思义，栈数据结构先进后出。不过，首先做的是把所有的全局变量压入栈底，当函数调用结束的时候，该全局变量依旧还在栈中。</p><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable Object,VO)</li><li>作用域链(Scope chain)</li><li><code>this</code></li></ul><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。包括全局上下文的变量对象和函数上下文的变量对象。全局上下文的变量对象没啥好说的。</p><p><strong>函数上下文变量对象</strong></p><p>执行上下文的执行过程分为两个部分</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><p>在函数上下文中，未进入执行阶段之前，变量对象(<code>VO</code>)中的属性都不能访问！但是进入执行阶段之后，变量对象(<code>VO</code>)转变为了活动对象(<code>AO</code>)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> <span class="token function-variable function">d</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>进入执行上下文后，这时候的<code>OA</code>只包括<code>Arguments</code>对象，就是函数的参数。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>    c<span class="token operator">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">}</span></code></pre><p>执行代码的时候，会按顺序执行，根据代码，修改变量对象的值</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token operator">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    c<span class="token operator">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token operator">:</span> reference to FunctionExpression <span class="token string">"d"</span><span class="token punctuation">}</span></code></pre><p><strong>经典例题</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// 执行代码之前，先进入执行上下文</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token keyword">var</span> foo<span class="token operator">=</span> <span class="token number">1</span><span class="token comment">// 打印函数，而不是undefined</span></code></pre><blockquote><p>因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">VO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    foo<span class="token operator">:</span> reference to <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token operator">~</span>foo<span class="token operator">:</span><span class="token keyword">undefined</span><span class="token comment">// 此处疑问: 此处变量声明的foo是否保存在VO中;以何种形式保存</span><span class="token punctuation">}</span></code></pre><p> 执行代码<code>console.log(foo)</code>，查找到了<code>VO</code>中的<code>foo</code>，输出结果。接着执行<code>foo=1</code>,执行后</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">VO</span><span class="token operator">=</span><span class="token punctuation">{</span>    foo<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><h2 id="参数按值传递"><a href="#参数按值传递" class="headerlink" title="参数按值传递"></a>参数按值传递</h2><blockquote><p><code>ECMAScript</code>中所有的函数的参数都是按值传递的</p></blockquote><p> 啥叫按值传递呢？</p><blockquote><p>也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另外一个变量一样</p></blockquote><p>举个简单的例子：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    v <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2}foo(value);console.log(value) // 1</span></code></pre><p>很好理解，当传递 <code>value</code>到函数<code>foo</code>中，相当于拷贝了一份 <code>value</code>，假设拷贝的这份叫 <code>_value</code>，函数中修改的都是 <code>_value</code>的值，而不会影响原来的 <code>value </code>值。</p><p>疑问：难道对象也是按值传递的吗？对象不应该是引用传递吗？通过传递一个指向该对象的指针(地址)，外部修改和函数内部修改都可以直接影响到该对象值的变化？答案是错误的，对象也是按值传递。不过这种”按值传递’’是特殊的,也是特殊的引用传递，叫做共享传递。<strong>引用传递是传递对象的引用，但是共享传递是传递对象的引用的副本</strong>，拷贝一份引用出来给参数。这样在函数里面修改该参数的属性值，并不会改变源对象里面的属性值。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2}foo(obj);console.log(obj.value) // 1</span></code></pre><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p><strong>类数组不可以使用数组的方法</strong>。注意数组方法<code>splice</code>和<code>slice</code>,<code>splice</code>改变原数组，<code>slice</code>不改变原数组</p><blockquote><p>间接调用数方法</p></blockquote><pre class="language-javas" data-language="javas"><code class="language-javas">var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3 }Array.prototype.join.call(arrayLike, '&amp;'); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // ["name", "age", "sex"] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item){    return item.toUpperCase();}); // ["NAME", "AGE", "SEX"]</code></pre><blockquote><p>类数组转数组</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arrayLike <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token string">'sex'</span><span class="token punctuation">,</span> length<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token comment">// 1. slice</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "age", "sex"] </span><span class="token comment">// 2. splice</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "age", "sex"] </span><span class="token comment">// 3. ES6 Array.from</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["name", "age", "sex"] </span><span class="token comment">// 4. apply</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arrayLike<span class="token punctuation">)</span><span class="token comment">// 5.es6的...</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arguments</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span><span class="token punctuation">}</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>arguments</code>对象的<code>length</code>属性值的是实参的长度，而不是形参的长度。<code>callee</code>属性可以调用函数自身。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">(</span>     data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span>       <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">.</span>xxx<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span>xxx <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0</span><span class="token comment">// 1</span><span class="token comment">// 2</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖</title>
      <link href="/2021/09/15/fang-dou/"/>
      <url>/2021/09/15/fang-dou/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote><p>你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行</p></blockquote><p>解决两个问题：</p><ol><li><code>this</code>的指向</li><li><code>event</code>对象</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getUserAction</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//console.log(this) //  此时的this指向的window,本来应该是&lt;div id="container"&gt;&lt;/div&gt;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// container.onmousemove = getUserAction;</span>container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>getUserAction<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>wait</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 修复this指向</span>        <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment">// 修复event对象</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments        <span class="token comment">//先清除掉之前的定时器</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>        <span class="token comment">//设置定时器，wait秒之后执行</span>        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p><strong>需求1-立刻执行</strong></p><p>不希望事件停止触发之后才执行，而是希望立刻执行函数，然后等到停止触发n秒之后，才可以重新执行。简单，只需要加一个判断，是不是立刻执行。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'container'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getUserAction</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    container<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">//console.log(this) //  此时的this指向的window,本来应该是&lt;div id="container"&gt;&lt;/div&gt;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// container.onmousemove = getUserAction;</span>container<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span>getUserAction<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span>wait<span class="token punctuation">,</span>immediate</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 修复this指向</span>        <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment">// 修复event对象</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments        <span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>immediate<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// -&gt;判断是不是立刻执行的</span>            <span class="token comment">// 如果已经执行过，不再执行</span>            <span class="token keyword">var</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timeout            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment">//设置定时器，wait秒之后执行</span>        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span>args<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>wait<span class="token punctuation">)</span>        <span class="token punctuation">}</span>       <span class="token comment">// + return result // 111</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment">/**如果getUserAction有返回值的话，当immediate为false的时候，因为使用了定时器又不是立刻执行，我们需要将func.apply(that,args)的返回值赋给变量，最后return的时候，值是undefined，所以我们只在immediate为true的时候返回函数的结果           - var timeout           + var timeout,result           - if(callNow) func.apply(that,args)           + if(callNow)  result = func.apply(that,args)           + return result // 111*/</span></code></pre><p><strong>需求2-取消防抖</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> timeout<span class="token punctuation">,</span> result<span class="token punctuation">;</span>    <span class="token keyword">var</span> <span class="token function-variable function">debounced</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果已经执行过，不再执行</span>            <span class="token keyword">var</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timeout<span class="token punctuation">;</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    debounced<span class="token punctuation">.</span><span class="token function-variable function">cancel</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        timeout <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> debounced<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call/apply/bind/new模拟实现</title>
      <link href="/2021/09/15/call-apply-bind-new-mo-ni-shi-xian/"/>
      <url>/2021/09/15/call-apply-bind-new-mo-ni-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="call的模拟实现"><a href="#call的模拟实现" class="headerlink" title="call的模拟实现"></a>call的模拟实现</h2><p><strong>模拟思路</strong></p><ol><li><code>call</code>改变了<code>this</code>的指向，指向到<code>foo</code></li><li><code>bar</code>函数执行了</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p>上面可以用类似逻辑实现</p><ol><li>将函数设置为对象的属性</li><li>执行该函数</li><li>删除该属性(函数)</li></ol><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 首先要获取调用call的函数，用this可以获取，就是foo函数</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 测试一下</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p><strong>最终版本</strong></p><p>加了三个东西：</p><ul><li>参数</li><li><code>this</code>参数可以传<code>null</code>, 此时指向的是<code>window</code></li><li>函数可以有返回值的</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> context <span class="token operator">||</span> window    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arguments['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//console.log(arguments[1]) // kevin </span>    <span class="token comment">//将数组的多个元素作为参数放进函数的参数里面</span>    <span class="token comment">//eval 会把里面的字符串解析成JavaScript代码进行执行</span>    <span class="token comment">//相当于 eval('context.fn(arguments[1],arguments[2])')  ===&gt; 解析成                  //context.fn(arguments[1],arguments[2])</span>    <span class="token comment">//args 是数组，下面这个语句会自动调用 toString的方法</span>    <span class="token comment">//console.log(args.toString()) // 'arguments[1],arguments[2]'</span>    <span class="token keyword">var</span> result <span class="token operator">=</span>   <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'context.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span><span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>     <span class="token comment">//console.log(result) // { value: 1, name: 'kevin', age: 18 } 返回值</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token comment">// 测试一下</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        value<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>        name<span class="token operator">:</span>name<span class="token punctuation">,</span>        age<span class="token operator">:</span>age    <span class="token punctuation">}</span><span class="token punctuation">}</span>bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span><span class="token comment">// 18</span><span class="token comment">// 1</span></code></pre><h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p><code>apply</code>和<code>call</code>作用完全一样的，只不过传参数不同。<code>apply </code>方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<code>call </code>方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">apply2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">||</span> window<span class="token punctuation">;</span>   <span class="token comment">// console.log(context) // {value:1} Object(context)-&gt;数组转成对象</span>    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> result<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arr['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'context.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// console.log(result) // { value: 1, name: 'k', age: 'e' } 返回值</span>    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 测试一下</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">{</span>        value<span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span>        name<span class="token operator">:</span>name<span class="token punctuation">,</span>        age<span class="token operator">:</span>age    <span class="token punctuation">}</span><span class="token punctuation">}</span>bar<span class="token punctuation">.</span><span class="token function">apply2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'kevin'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// kevin</span><span class="token comment">// 18</span><span class="token comment">// 1</span></code></pre><h2 id="bind的模拟实现"><a href="#bind的模拟实现" class="headerlink" title="bind的模拟实现"></a>bind的模拟实现</h2><ul><li>返回一个函数</li><li>可以传入参数，<code>bind</code>绑定的时候可以传，返回的函数在<code>bind</code>绑定参数的后面接着传</li><li>当<code>bind</code>返回的函数是构造函数的时候，<code>bind</code>指定的<code>this</code>就会无效，但是传入的参数依旧有效</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Function.prototype.bind - what is trying to be bound is not callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment">//  绑定bind的时候，传进去的参数</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// console.log(args) // [ 'daisy', 'man' ]</span>    <span class="token keyword">var</span> fNOP <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 中转 ，避免直接修改绑定函数的prototype</span>    <span class="token keyword">var</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 这个时候的arguments是执行函数的时候传进去的参数</span>        <span class="token comment">// console.log(bindArgs) // [ '18' ]</span>        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span>        <span class="token comment">// 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性</span>        <span class="token comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span>        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值</span>    <span class="token comment">// 原：fBound.prototype = self.prototype;</span>    <span class="token comment">// 现</span>    fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> self<span class="token punctuation">.</span>prototype    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span>sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// console.log(this.value);</span>    <span class="token comment">// console.log(name);</span>    <span class="token comment">// console.log(age);</span><span class="token punctuation">}</span><span class="token keyword">var</span> bindFoo <span class="token operator">=</span> bar<span class="token punctuation">.</span><span class="token function">bind2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'daisy'</span><span class="token punctuation">,</span><span class="token string">'man'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1</span><span class="token comment">// daisy</span><span class="token comment">// 18</span></code></pre><h2 id="new模拟实现"><a href="#new模拟实现" class="headerlink" title="new模拟实现"></a>new模拟实现</h2><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Otaku</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>habit <span class="token operator">=</span> <span class="token string">'Games'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">'something'</span><span class="token punctuation">}</span><span class="token class-name">Otaku</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>strength <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span><span class="token class-name">Otaku</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayYourName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// shift 返回删除的数组第一个元素 也就是构造函数</span>    <span class="token comment">// console.log(arguments) // { '0': 'Kevin', '1': '18' }shift会修改原数组、</span>    <span class="token comment">// 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</span>    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>    <span class="token comment">// 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</span>    <span class="token comment">// Constructor.apply(obj, arguments);</span>    <span class="token comment">// return obj;</span>    <span class="token comment">// +  构造函数有返回值的时候。判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么</span>    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">Constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>arguments<span class="token punctuation">)</span>    <span class="token comment">// console.log(obj) // Otaku { name: 'Kevin', age: '18', habit: 'Games' }</span>    <span class="token keyword">return</span> <span class="token keyword">typeof</span> ret <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> ret <span class="token operator">:</span> obj<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span>Otaku<span class="token punctuation">,</span> <span class="token string">'Kevin'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// Kevin</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>habit<span class="token punctuation">)</span> <span class="token comment">// Games</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>strength<span class="token punctuation">)</span> <span class="token comment">// 60</span>person<span class="token punctuation">.</span><span class="token function">sayYourName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// I am Kevin</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2021/09/02/she-ji-mo-shi-zhi-dan-li-mo-shi/"/>
      <url>/2021/09/02/she-ji-mo-shi-zhi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>单例就是保证一个类只有一个实例,实例的方法一般先判断实例是否存在,如果存在直接返回出来,如果不存在就先创建了再返回出来。这就可以保证一个类只有一个实例。在JS中,单例是一个命名空间的提供者,从命名空间里提供唯一的访问点来访问该对象。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>单例一般用在系统间各种模式的通信协调上,下面代码是单例的实践</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> Single <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 参数:传递给单例一个参数集合</span>    <span class="token keyword">function</span> <span class="token function">Signleton</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">let</span> args <span class="token operator">=</span> args <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Signle'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointX <span class="token operator">=</span> args<span class="token punctuation">.</span>pointX <span class="token operator">||</span> <span class="token number">6</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointY <span class="token operator">=</span> args<span class="token punctuation">.</span>pointY <span class="token operator">||</span> <span class="token number">10</span>    <span class="token punctuation">}</span>   <span class="token keyword">let</span> instance <span class="token comment">// 实例容器</span>   <span class="token keyword">let</span> _static <span class="token operator">=</span> <span class="token punctuation">{</span>       name<span class="token operator">:</span><span class="token string">'Signle'</span><span class="token punctuation">,</span>       <span class="token comment">// 获取实例的方法</span>       <span class="token comment">// 返回Signleton实例</span>       <span class="token function-variable function">getInstance</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token function">Signleton</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token comment">// 没有就创建一个</span>           <span class="token punctuation">}</span>           <span class="token keyword">return</span> instance <span class="token comment">// 有就直接return出来拿到</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> _static <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> s <span class="token operator">=</span> Single<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">{</span>pointX<span class="token operator">:</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>pointX<span class="token punctuation">)</span> <span class="token comment">// 7</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的异步编程</title>
      <link href="/2021/09/02/js-de-yi-bu-bian-cheng/"/>
      <url>/2021/09/02/js-de-yi-bu-bian-cheng/</url>
      
        <content type="html"><![CDATA[<p>异步是啥？程序的不连续执行就是异步,一个任务分几个部分,几个时间段完成</p><p>同步就是程序连续执行,1没执行完2就只能等着</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><blockquote><p><code>JS</code>对异步编程的实现,就是回调函数。把异步任务的第二段单独写在一个函数里面,等异步任务的第一段执行完毕的时候,就调用这个函数啊</p></blockquote><pre class="language-javascript" data-language="javascript"><code class="language-javascript">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'etc/passwd'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>上述代码中,<code>readFile</code>函数的第二个参数,就是回调函数,也就是任务的第二段,等到操作系统返回<code>/etc/passwd</code>这个文件之后,回调函数才会执行。</p><p>回调函数的第一个参数是<code>err</code>(如果没有错误,该参数就是<code>null</code>)?原因是执行分为两段,在这两段之间抛出的错误,程序无法捕捉,只能当成参数,传入第二段.</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身没问题,问题在于多个回调函数的嵌套。假定读取A文件之后,再读取B文件 。造成回调噩梦<code>callback hell</code></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileA<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err  <span class="token comment">// 捕获读取A失败的错误</span>    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileB<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err <span class="token comment">// 捕获读取B失败的错误  捕获读取A失败的错误其实可以不写,放在B这里捕获</span>        <span class="token comment">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>不是一种新的语法,而是一种新的回调函数的写法,解决了<code>callback hell</code>的问题。<code>then</code>方法加载回调函数,<code>catch</code>方法捕获执行第一段和第二段之间的错误</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> readFile <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs-readfile-promise'</span><span class="token punctuation">)</span><span class="token comment">//返回一个Promise版本的readFile函数</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//加载完fileA文件之后,再去执行then里面的回调函数</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileB<span class="token punctuation">)</span> <span class="token comment">// A读取完毕,开始加载B</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//加载完fileB文件之后,再去执行then里面的回调函数</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">throw</span> err <span class="token comment">// 捕获整个加载过程之中抛出的错误</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Promise</code>的缺点就是代码冗余,一堆的<code>then</code>,语义不清晰</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p><code>Generator</code>函数是协程在<code>ES6</code>中的实现,最大的特点就是可以交出函数的执行权(即暂停执行)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Genertor可以进行函数体内外部的数据交换和部署错误处理代码</span><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span> <span class="token comment">// yield 就是暂停</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">}</span><span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 返回第一个yield的结果 {value:3,done:false}</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// {value:undefined,done:true} g.next(2)=&gt; {value:2,done:true}</span>g<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span> <span class="token comment">// 可以被里面的try...catch代码块捕获</span></code></pre><p>实际例子</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> fetch <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node-fetch'</span><span class="token punctuation">)</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> url <span class="token operator">=</span> <span class="token string">"https://github.com/users/github"</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment">// 执行代码</span><span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> res <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//得到{value:result(Promise),done:false}</span><span class="token comment">// fetch返回的是一个Promise对象,所以用then方法来调用下一个next,then方法等fetch返回完毕后才执行,里面是任务的第二段.拿到result返回结果,再return结果出来</span>res<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><code>Generator</code>的缺点：流程管理不方便(何时执行第一阶段、何时执行第二阶段) <strong>基本不用它</strong></p><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3><p><code>async/await</code>是Generator的语法糖,<code>*</code>换成了<code>async</code>,<code>yield</code>换成了<code>await</code>。<code>async </code>函数是<code>ES7</code>的语法功能,不过可以在开发中正常使用,因为<code>Babel</code>已经支持,经转码之后就可以使用。</p><ul><li>指定50毫秒之后,输出“hi”</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>ms<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span>ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">timeout</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span></code></pre><ul><li><code>await</code>后面的<code>Promise</code>对象,运行的结果可能是<code>rejected</code>,所以最好把<code>awai</code>t命令放在<code>try...catch</code>代码块之中</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>        <span class="token keyword">await</span> <span class="token function">somethingReturnPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//另一种写法</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">await</span> <span class="token function">somethingReturnPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><ul><li><code>forEach</code>方法的参数改成<code>async</code>函数,也会有问题,原因是三个<code>db.post</code>操作是并发执行,也就是同时执行,而不是继发执行</li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFunc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token comment">// 可能得到错误的结果</span>    docs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 正确的做法是使用for循环</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> doc <span class="token keyword">of</span> docs<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><ul><li>如果希望多个请求并发执行,可以使用<code>Promise.all</code></li></ul><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFunc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 或者使用下面</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFunc</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> Promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">doc</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        doc<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> promise <span class="token keyword">of</span> promises<span class="token punctuation">)</span><span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">await</span> promise<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试功能页</title>
      <link href="/2021/08/31/ce-shi-gong-neng-ye/"/>
      <url>/2021/08/31/ce-shi-gong-neng-ye/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="38f3f22ee21db3680ba53f48b6e1b240efd52229d75f4c99c5bcab51b59f7669">bd25ed9264b080267271e137e33d0ce1874c72b7e3d7ffc49271f9d090e14bb8e7eeef201904066dc5fec581483b6f5b230759b47f327056f2c6087fb4372224ff41dd6a14a51a6f9c19a545b59bb412952ce03ecc8be9d6c47f8d0ee5714a97ce39d1a3050947b9f06c60dbb003869079b26abe7da67db1da28532cb1d35841be69ec6ddfe28bdcab1b34104726ee29f7d23b13cab0b9c924973d25e49b211cf467d4bdf99881bce00692fa10a01be08aff185b49104633183b9060185aafc7ac146a6e5fd2ae7c7b4a277a599d853ccb3bee614272cf7e81bbaff8829d5b77bdbec1568eefe7a02bfd3ef2533380d0bd2993ada136b49b7b8582773bb3fe7f8e98f20c7fe67ba1d5611ecc2d6bc19b1ba1d87e7b1cccbb0f3450f37ae298ca84037710c4a2daea768f8c60d5e6588d4de4e079b5369d91c9fd5d9423bf5588c1d4279ac486baaeeee09567b8c018b7ca43bafe735adeb76b9b798c3aaa86066540f0b64e42bb1bd42f8365f293011b085ce74b79cf1b23bbc66dda6ebf3d9a19f7216da231095cfd3cd45945daa958f9960c994542c51b2975852b5f5a9058e13acfb0a4635a9de1c6aefc05e1ce9c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">测试加密，这里的密码是：test</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github配置cdn注意事项</title>
      <link href="/2021/08/31/github-pei-zhi-cdn-zhu-yi-shi-xiang/"/>
      <url>/2021/08/31/github-pei-zhi-cdn-zhu-yi-shi-xiang/</url>
      
        <content type="html"><![CDATA[<h3 id="Github-CDN-Jsdelivr"><a href="#Github-CDN-Jsdelivr" class="headerlink" title="Github+CDN+Jsdelivr"></a>Github+CDN+Jsdelivr</h3><p><code>github</code>上新建个仓库存放这些需要<code>cdn</code>加速的资源。在<code>Releases</code>中创建<code>cdn</code>加速。图中<code>Choose a tag</code> 就是版本号,通过链接<code>https://cdn.jsdelivr.net/gh/JingWZeng/blog-CDN@1.0/img/</code>访问<code>cdn</code>加速的文件夹,<code>https://cdn.jsdelivr.net/gh/JingWZeng/blog-CDN@1.0/img/[文件名]</code>访问具体的文件。<br><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202108310924643.png"><br><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202108310920130.png"></p><p><code>picGo</code>如果需要利用<code>cdn</code>加速的话，只需要把默认地址设置成<code>https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg</code>。<code>markdownImg</code>是我的仓库名<br><img src="https://cdn.jsdelivr.net/gh/JingWZeng/markdownImg/img/202108310931535.png"></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可编辑的div</title>
      <link href="/2021/08/27/ke-bian-ji-de-div/"/>
      <url>/2021/08/27/ke-bian-ji-de-div/</url>
      
        <content type="html"><![CDATA[<p>如果利用<code>textarea</code>的输入框，只能输入文本，无法输入图片等。比较好的方法是利用可编辑的<code>div</code>进行实现。</p><h3 id="div的可编辑"><a href="#div的可编辑" class="headerlink" title="div的可编辑"></a>div的可编辑</h3><p><code>div</code>要完成可编辑，只需要设置<code>contenteditable = "true"</code>即可实现。我们可以监听用户输入的区域,用户输入的时候，获取其中的<code>innerText</code>，之后进行字数的限制判断，重新设置其<code>innerHtML</code>，超出的字数显示成其他颜色。在提交之前，对表单进行预验证，要求用户删除多余的字符，方可提交给后端。</p><p><span class="github-emoji"><span>🍡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f361.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>可编辑的<code>div</code>的难点在于光标难于控制，因此设置<code>html</code>的时候利用两层<code>div</code>重叠的方式进行解决</p><ul><li>上层的<code>div</code>用于文本的输入,背景颜色透明</li><li>下层的<code>div</code>节点用于高亮超出的部分文字，文字颜色设置为透明，超出的部分设置背景颜色进行高亮</li></ul><p><span class="github-emoji"><span>🌭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f32d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>bug1:<code>div</code>的高度自适应</strong></p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box"</span> contenteditable<span class="token operator">=</span><span class="token string">"true"</span> ref<span class="token operator">=</span><span class="token string">"box"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"hightLight"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">.</span>box<span class="token punctuation">{</span>    width<span class="token operator">:</span><span class="token number">400</span>px<span class="token punctuation">;</span>    min<span class="token operator">-</span>height<span class="token operator">:</span><span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token comment">//实现自适应</span>    max<span class="token operator">-</span>height<span class="token operator">:</span><span class="token number">400</span>px<span class="token punctuation">;</span>    margin<span class="token operator">-</span>left<span class="token operator">:</span>auto<span class="token punctuation">;</span>    margin<span class="token operator">-</span>right<span class="token operator">:</span>auto<span class="token punctuation">;</span>    padding<span class="token operator">:</span><span class="token number">3</span>px<span class="token punctuation">;</span>    outline<span class="token operator">:</span>none<span class="token punctuation">;</span> <span class="token comment">// div在获取焦点的时候有虚框,让它消失</span>    border<span class="token operator">:</span><span class="token number">1</span>px solid #dedede<span class="token punctuation">;</span>    word<span class="token operator">-</span>wrap<span class="token operator">:</span><span class="token keyword">break</span><span class="token operator">-</span>word<span class="token punctuation">;</span>    overflow<span class="token operator">-</span>x<span class="token operator">:</span>hidden<span class="token punctuation">;</span>    overflow<span class="token operator">-</span>y<span class="token operator">:</span>auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><span class="github-emoji"><span>🌮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f32e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug2:输入框的<code>placeholder</code></strong></p><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">.box:empty::before</span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token function">attr</span><span class="token punctuation">(</span>placehoder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>#dedede<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>之后就可以在<code>html</code>中使用<code>placeholder</code>属性。但是存在一些问题(点击回车的时候,会插入<code>&lt;div&gt;&lt;/div&gt;</code>或者<code>&lt;br&gt;</code>，这会导致一些问题，甚至影响到统计的字数)<br>解决办法:<br><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 通过<code>JS</code>手动的添加、移除<code>class</code>类处理<code>placeholder</code>的显示与隐藏</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>box<span class="token punctuation">.</span>is<span class="token operator">-</span>show<span class="token operator">-</span>ploacehoder<span class="token operator">:</span><span class="token operator">:</span>before<span class="token punctuation">{</span>    content<span class="token operator">:</span><span class="token function">attr</span><span class="token punctuation">(</span>placehoder<span class="token punctuation">)</span><span class="token punctuation">;</span>    color<span class="token operator">:</span>#dedede<span class="token punctuation">;</span>    position<span class="token operator">:</span>absolute<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// JS</span><span class="token keyword">let</span> box <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>refs<span class="token punctuation">.</span>box box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>box<span class="token punctuation">.</span>innerHTML <span class="token operator">===</span> <span class="token string">'&lt;div&gt;&lt;br&gt;&lt;/div&gt;'</span> <span class="token operator">||</span>    box<span class="token punctuation">.</span>innerHTML <span class="token operator">===</span> <span class="token string">'&lt;br&gt;'</span> <span class="token operator">||</span>    box<span class="token punctuation">.</span>innerHTML <span class="token operator">===</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'is-showPlaceholder'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    box<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'is-showPlaceholder'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 第一层<code>div</code>使用<code>textarea</code>替换，<code>textarea</code>中有<code>placeholder</code>属性</p><p><span class="github-emoji"><span>🍅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f345.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug3:输入中文的统计字数</strong><br>在中文输入的时候,中文还没有输入到输入框中的时候，字数已经在开始统计了，合理的是中文输入<code>composing</code>组合的过程中不应该计算字数，在<code>composed</code>组合完成输入到输入框中的时候再计算。<br><code>composing</code>:在中文输入中，组合开始<br><code>compsied</code>:在中文输入中，组合完成</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> isComposing <span class="token operator">=</span> <span class="token boolean">false</span>editorArea<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'compositionstart'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  isComposing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span>editorArea<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'compositionend'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  isComposing <span class="token operator">=</span> <span class="token boolean">false</span>  <span class="token comment">// 字数统计</span>  <span class="token keyword">let</span> text <span class="token operator">=</span> box<span class="token punctuation">.</span>innerText  <span class="token comment">// 判断字数是否超出限制</span>  <span class="token function">setCounter</span><span class="token punctuation">(</span>limitCnt <span class="token operator">-</span> text<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><span class="github-emoji"><span>🍌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug4:文件选择器于前端预览图片</strong><br>古老的时候是无法直接在前端预览图片的，那时候借助的是ajax预先把图片发送给服务端，服务端返回图片的地址，前端利用img标签进行显示。不论用户需不需要上传该图片，该图片等会被上传到服务器中。<br>现在的做法:</p><ul><li><code>fileReader</code>—&gt;我不用</li><li> <code>URL.creatObjectURL</code> <span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><code>URL.creatObjectURL()</code>方法会创建一份DOMString对象，它包含url，这个url的生命周期跟创建它的窗口绑定，并且这个url就是操作的对象的映射地址（临时地址）<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"file"</span> accept<span class="token operator">=</span><span class="token string">"image/*"</span> ref <span class="token operator">=</span> <span class="token string">'imgFiles'</span> @change<span class="token operator">=</span><span class="token string">"handleChange"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>img <span class="token operator">:</span>src<span class="token operator">=</span><span class="token string">"srcImg"</span><span class="token operator">&gt;</span><span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> fileObj <span class="token operator">=</span> event<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">//对于type="file" input.files[0]得到当前选中的file对象</span>    <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>srcImg <span class="token operator">=</span> file <span class="token operator">?</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>fileObj<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">}</span></code></pre><span class="github-emoji"><span>🍎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f34e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug5:拖动于前端预览图片</strong><br>拖动是利用<code>html5</code>中的<code>drop</code>、<code>drogover</code>、<code>drogleave</code>方法<br>drogover:移进到了敏感区域，一直调用<br>注意:<span class="github-emoji"><span>🔊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>需要阻止它们的默认方法,负责网页会自动打开该图片</li><li><code>DataTransfer</code>对象出现在拖拽事件中，具体包括开始拖拽<code>dragstart</code>事件，拖拽进入<code>dragenter</code>事件，拖拽离开<code>dragleave</code>事件，拖拽经过<code>dragover</code>事件，拖拽释放<code>drop</code>事件以及拖拽结束<code>dragend</code>事件。</li><li><code>DataTransfer.items </code>（只读）<br>提供<code>DataTransferItemList</code>对象，该对象是所有拖动数据的列表。<pre class="language-javascript" data-language="javascript"><code class="language-javascript">@drogover <span class="token operator">=</span> <span class="token string">"handleDrogover"</span>@drop<span class="token operator">=</span> <span class="token string">"handleDrop"</span><span class="token function">handleDrogover</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">handleDrop</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> dt <span class="token operator">=</span> e<span class="token punctuation">.</span>dataTransfer    <span class="token keyword">const</span> oFile <span class="token operator">=</span> dt<span class="token punctuation">.</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// 文件对象</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">image</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>oFile<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// 判断是否为图片对象</span>    <span class="token keyword">const</span> blod <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blod</span><span class="token punctuation">(</span><span class="token punctuation">[</span>oFile <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">// 生成Blod对象</span>    <span class="token keyword">const</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> imgSrc <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>blod<span class="token punctuation">)</span><span class="token comment">//URL.createObjectURL()可以处理File对象、Blod对象</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc    img<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        box<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><span class="github-emoji"><span>🍇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f347.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>bug6:<code>formData</code>传输多个文件</strong><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>fileObj<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'file[]'</span><span class="token punctuation">,</span>fileObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 不可以直接console.log(formData)----&gt;需要利用formData.get([key])</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 可编辑的div </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 可编辑的div </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly的Tag-Plugins</title>
      <link href="/2021/08/26/butterfly-de-tag-plugins/"/>
      <url>/2021/08/26/butterfly-de-tag-plugins/</url>
      
        <content type="html"><![CDATA[<pre class="language-butterFly-Tag" data-language="butterFly-Tag"><code class="language-butterFly-Tag">{% note red 'fas fa-fan' flat%}这是三片呢？还是四片？{% endnote %}</code></pre><div class="note icon flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>更多信息见:<a href="https://butterfly.js.org/posts/c9711c19/">butterfly官网标签外挂</a></p>]]></content>
      
      
      <categories>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2文档总结</title>
      <link href="/2021/08/25/vue-wen-dang-zong-jie/"/>
      <url>/2021/08/25/vue-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<ol><li><code>data</code>对象所有的属性被加入到Vue的响应式系统(被创建的时候就已经存在才是,临时加入的不是)<br>一开始的声明其实就是让他在创建的时候就存在。如果用如果用<code>Objectfreeze(obj)</code>,阻止<code>obj</code>修改自己的属性,所以响应式系统就不能追踪他的变化</li><li><code>v-once</code>只执行一次插值,当数据改变的时候,插值的内容不会再更新</li><li><code>v-html</code>可以把<code>html</code>代码执行出来,用户提供的信息不要这样用,<code>Xss</code>攻击,只对可信的东西用就好。<code>Xss</code>攻击可以利用<code>Xss</code>库进行配置</li><li>用在<code>html</code>属性上面不可以用<code>{{}}`,需要用`v-bind`的。其实如果`v-bind`的属性是`false`\ `null` \ `undefined`的话,渲染出来的该`html`元素不会含有该属性的。`{{}}</code>和<code>v-bind</code>中都可以放<code>JavaScript</code>表达式,<code>v-bind</code>的属性名会被强制转换成小写,</li><li><code>v-bind</code> 和 <code>v-on</code>的缩写<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">:</span>herf <span class="token operator">=</span> <span class="token string">"ur1"</span><span class="token comment">//动态参對的缩写</span><span class="token operator">:</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"url"</span>@click <span class="token operator">=</span> <span class="token string">"dosomething"</span>@<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"dosomething"</span></code></pre></li><li>计算属性的使用和普通属性一样绑定在<code>html</code>元素上面</li><li>插值可以调用<code>methods</code>里面的方法</li><li>计算属性有缓存,看的是它所对应的依赖是否改变,如果改变才会重新求值,如果没有变化,则不会。<code>methods</code>的话是每次调用都会执行的<pre class="language-javascript" data-language="javascript"><code class="language-javascript">computed<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function-variable function">now</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//该属性now不会再更新,因为Date.now ()不是响应式依</span>        <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>当一些数据需要随着其他数据变动而变动的时候,你特别容易滥用<code>watch</code>,其实用<code>computed</code>会更好一点,<code>computed</code>可以监听到<code>data</code>里面的响应式数据(做为计算属性的依赖之后)</li><li>计算属性默认是只有<code>getter</code>,有需要的时候需要自己提供<code>setter</code>方法来做,就是更改属性的时候调用,做一下事情</li><li><code>watch</code>:当数据变化的时候执行异步或者开销比较大的操作的时候</li><li><code>class</code>和<code>style</code>动态的切换<code>class</code>,<code>class</code>和<code>:class</code>是可以共存在个html元素上面的<pre class="language-css" data-language="css"><code class="language-css"><span class="token punctuation">:</span>class = <span class="token property">obj或者</span><span class="token punctuation">:</span>class=[]<span class="token comment">/*这个obj/[]当然可以定义computer的返回值或者data里面调用子组件时候使用:class会传入到子组件的class*/</span></code></pre></li><li><code>Vue</code>渲染的时候会复用些相同<code>html</code>标签,有些需求是不可以被复用的,此时可以给该标签或者组件添加<code>key</code>属性,确定唯一性。</li><li><code>v-show</code>渲染的元素是始终存在<code>dom</code>中的,只是控制<code>display</code>的属性切换,<code>v-lf</code>会重复创建和销毁的,<code>v-show</code>不可以用在<code>template</code>中,也不可以<code>v-else</code>搭配使用</li><li><code>v-for="(1,2)"</code>参数1是item,参数2是index.他们两个的位置不可以被改变<br>遍历的是数组的时候<pre class="language-javascript" data-language="javascript"><code class="language-javascript">v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item of itens"</span>和v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item of items"</span>效果是一样的</code></pre></li><li><code>v-for</code>被遍历的是对象的时候,<code>v-for="(value,key,index)"</code>第个参数是值,第二个键名,第三个是索引</li><li>嵌套的<code>v-for</code>中不要使用<code>computed</code>方法</li><li>访问原生的JS事件对象的时候,可以使用特殊变量<code>$event</code>作为参数传到方法中</li><li>事件修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//阻止事件继续传播</span>@click<span class="token punctuation">.</span>stop<span class="token comment">//提交事件不再加载页面</span>@submit<span class="token punctuation">.</span>prevent<span class="token comment">//捕获-&gt;目标-&gt;冒泡 内部触发的事件先在外部处理,之后才去内部元素处理</span>@click<span class="token punctuation">.</span>capture<span class="token comment">//事件自身才会触发</span>@click<span class="token punctuation">.</span>self<span class="token comment">//阻止所有的点击</span>@click<span class="token punctuation">.</span>prevent<span class="token punctuation">.</span>self<span class="token comment">//阻止自身的点击</span>@click<span class="token punctuation">.</span>self<span class="token punctuation">.</span>prevent<span class="token comment">//点击事件只会触发一次</span>@click<span class="token punctuation">.</span>once<span class="token comment">//不想阻止事件的默认行为,比如滚动事件的滚动行为</span>@<span class="token operator">:</span>scroll<span class="token punctuation">.</span>passive <span class="token comment">//---&gt;不阻止默认事件的发生</span></code></pre></li><li>按键修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//arrowUp/pageDown等</span>@keyup<span class="token punctuation">.</span>enter <span class="token comment">//keyCode</span>@keyup<span class="token punctuation">.</span><span class="token number">13</span><span class="token comment">//全局定义按键修饰符的名字</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>keyCodes<span class="token punctuation">.</span>f1 <span class="token operator">=</span> <span class="token number">112</span> <span class="token comment">//@keyup.f1</span><span class="token comment">//兼容老的浏览器,为键盘起的小名</span><span class="token punctuation">.</span>enter<span class="token operator">/</span><span class="token punctuation">.</span>tab<span class="token operator">/</span><span class="token punctuation">.</span>delete<span class="token operator">&lt;</span>删除事件<span class="token operator">/</span>退格键<span class="token operator">&gt;</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.esc</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span>space<span class="token operator">/</span><span class="token punctuation">.</span>up<span class="token operator">/</span><span class="token punctuation">.</span>down<span class="token operator">/</span><span class="token punctuation">.</span>left<span class="token operator">/</span><span class="token punctuation">.</span>right</code></pre></li><li>系统修饰符:按下响应的键才可以触发鼠标或者其他按键的事件<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>ctrl  <span class="token punctuation">.</span>alt  <span class="token punctuation">.</span>shift <span class="token punctuation">.</span>meta<span class="token operator">&lt;</span>windows图标键<span class="token operator">&gt;</span><span class="token comment">// Alt + C</span>@keyup<span class="token punctuation">.</span>alt<span class="token punctuation">.</span><span class="token number">67</span><span class="token comment">//Ctrl + click</span>@keyup<span class="token punctuation">.</span>click<span class="token punctuation">.</span>ctrl<span class="token comment">//exact精确控制系统修饰符的组合触发的事件</span><span class="token comment">//即使alt、shift被按下,也可以触发,因为按下ctrl+click就可以满足条件</span>@click<span class="token punctuation">.</span>ctrl<span class="token comment">//有且仅有ctrl被按下才会触发</span>@click<span class="token punctuation">.</span>ctrl<span class="token punctuation">.</span>exact<span class="token comment">//没有任何系统修饰符按下才会触发</span>@click<span class="token punctuation">.</span>exact</code></pre></li><li>鼠标修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>left<span class="token punctuation">.</span>right<span class="token punctuation">.</span>middle</code></pre></li><li><code>v-model</code>修饰符<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">.</span>lazy <span class="token comment">// 只有change事件发生的时候,才会同步数据</span><span class="token punctuation">.</span>number<span class="token comment">//自动将输入的值转number-&gt;parseFloat解析,无法解析的话,返回原始值</span><span class="token punctuation">.</span>trim<span class="token comment">//自动过滤输入的首尾空白字符</span></code></pre></li><li><code>$emit([事件名],args)</code>在父组件中可以通过<code>$event</code>来得到这个<code>args</code>的值</li><li>动态组件用<code>is</code>这个属性</li><li>组件的名字全部小写而且用<code>-</code>字符连接。在非模板字符串中,也就是不在<code>template</code>中,无法使用<code>&lt;myComponent/&gt;</code>,只能写成<code>&lt;my-component/&gt;</code></li><li><code>props['myData']</code>,<code>props</code>中命名是驼峰,<code>html</code>会把它们全部转成<code>kebab-case</code>。比如<code>my-data</code></li><li>事件名用<code>kebab-case</code>,因为<code>html</code>会全部转成小写</li><li><code>props</code>是单向数据流,父亲的数据会更新到儿子那边,所以是响应式的。儿子那边不能修改来自父亲的值,因为父亲更新会改变该值。解决办法:深拷贝一份数据,用来做其他的事情-&gt;分两种情况:</li></ol><ul><li>如果是想把<code>props</code>的值做为子组件本地的数据使用,可以在<code>data</code>里面定义一个变量,把<code>props</code>属性值给该变量</li><li>如果是希望把<code>props</code>里面的值做一个基础的原始值,在子组件中显示的话,可以防止<code>computed</code>中做处理</li></ul><ol start="30"><li><code>props</code>做自定义验证<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1.</span> props<span class="token operator">:</span><span class="token punctuation">{</span>    foo<span class="token operator">:</span><span class="token punctuation">{</span>        <span class="token function-variable function">validator</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'success'</span><span class="token punctuation">,</span><span class="token string">'warining'</span><span class="token punctuation">,</span><span class="token string">'danger'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indxOf</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">2.</span>props<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token comment">//判断是不是Perosn的实例</span>    author<span class="token operator">:</span>Person<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">firstname<span class="token punctuation">,</span>lastname</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstname <span class="token operator">=</span> firstname    <span class="token keyword">this</span><span class="token punctuation">.</span>lastname <span class="token operator">=</span> lastname<span class="token punctuation">}</span></code></pre></li><li><code>$attrs</code>与 <code>$listens</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//在子组件中使用</span><span class="token number">1</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">2</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token comment">//在2中用</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">:$attrs</span><span class="token template-punctuation string">`</span></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">@listens</span><span class="token template-punctuation string">`</span></span> <span class="token operator">-</span><span class="token operator">&gt;</span>接受<span class="token number">1</span>中没有进入<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">props</span><span class="token template-punctuation string">`</span></span>里面的其他属性和<span class="token number">1</span>的全部方法<span class="token comment">//在3中用</span>接受<span class="token number">1</span>和<span class="token number">2</span>中没有进入 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">props</span><span class="token template-punctuation string">`</span></span>里面的其他属性和<span class="token number">1</span>和<span class="token number">2</span>的全部方法</code></pre></li><li>组件的<code>.sync</code>修饰符就是让子组件做改变的时候同步到父组件中,和<code>props</code>传值<code>/$emit</code>中效果一样。组件中使用<code>v-model</code>也可以实现<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"something"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>input <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"something"</span> @input<span class="token operator">=</span><span class="token string">"something=$event.target.value"</span><span class="token operator">&gt;</span><span class="token comment">//在组件中使用v-model</span><span class="token punctuation">{</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token punctuation">}</span>测试用的<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//初始的title = '1111'</span><span class="token operator">&lt;</span>Child v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">/</span><span class="token operator">&gt;</span>Vue<span class="token punctuation">.</span><span class="token function">Component</span><span class="token punctuation">(</span><span class="token string">'Child'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>    template<span class="token operator">:</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;    {{value}}   ------------&gt;用来测试(2),现在显示'1111'    &lt;button @click="change()"&gt;按钮&lt;/button&gt;    &lt;/div&gt;,    props:['value'],     methods:{        change(){            this.$emit('input','22222') --------------&gt; 一定要触发input事件,点击之后测试(1)/(2)变成'22222'        }    }    </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><code>keep-alive</code>可以用来保存切换之后页面的存在状态</li><li><code>filters</code>中用着<code>{{}}/v-bind</code>中,用|隔开,<code>原始值|过滤方法A|过滤方法B</code>,<code>A</code>得到的结果到<code>B</code>。或者<code>value|A(arg1,arg2)</code></li><li>对象和数组,<code>Vue</code>无法检测它们的变化,解决办法:<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1.</span> 对于对象<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token keyword">set</span>向嵌套对象添加响应式的数据<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span><span class="token punctuation">[</span>属性名<span class="token punctuation">]</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment">//如果是添加多个属性,需要让原对象与要混合的进去的属性组合成一个新的对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>someObj<span class="token punctuation">,</span><span class="token punctuation">{</span>a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token number">2.</span> 对于数组<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>实现vm<span class="token punctuation">.</span>items<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span> newVal的效果<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&gt;</span>这种不是响应式的<span class="token punctuation">,</span>下面的才是<span class="token comment">//set</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span>index<span class="token punctuation">,</span>newVal<span class="token punctuation">)</span><span class="token comment">//splice</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>newVal<span class="token punctuation">)</span></code></pre></li><li><code>$parent</code>可以访问父亲的<code>data</code>属性,但最好不要这样做。<code>ref</code>给我一个组件的<code>id</code>,通过<code>this.$refs.[id]</code>来访问,refs不是响应式的,所以不应该在模板中或者<code>computed</code>使用</li><li><code>nextTick()</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//tick的意思是一次事件循环-&gt;保证虚拟dom被挂在真是dom之后立刻执行,数据被更新到dom之后立刻执行</span><span class="token number">1.</span> Promisemethods<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">updataMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'已更新'</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">//未更新</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token comment">//已更新</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">2.</span>Async<span class="token operator">/</span>Awaitmethods<span class="token operator">:</span><span class="token punctuation">{</span>   <span class="token keyword">async</span> <span class="token function">updataMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> <span class="token string">'已更新'</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span> <span class="token comment">//未更新</span>        <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$nextTick       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>textContent<span class="token punctuation">)</span><span class="token comment">//已更新</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex文档总结</title>
      <link href="/2021/08/25/vuex-wen-dang-zong-jie/"/>
      <url>/2021/08/25/vuex-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p><code>state</code>里面的值的处理方式与<code>computed</code>属性一样,依赖<code>data</code>里面的值并且做缓存(也就是混入<code>computer</code>)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">state<span class="token operator">:</span><span class="token punctuation">{</span>    userId<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span><span class="token comment">// 混入computed里面</span>computed<span class="token operator">:</span><span class="token punctuation">{</span>   <span class="token comment">// ...mapState(['name1'],['name2']...)</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function-variable function">name1</span><span class="token operator">:</span><span class="token parameter">state</span><span class="token operator">=&gt;</span>state<span class="token punctuation">.</span>name1<span class="token punctuation">,</span>        <span class="token function-variable function">name2</span><span class="token operator">:</span><span class="token parameter">state</span><span class="token operator">=&gt;</span>state<span class="token punctuation">.</span>name2<span class="token punctuation">,</span>        <span class="token operator">...</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p><code>getter</code>里面的值的处理方式与<code>computed</code>属性一样,依赖<code>data</code>里面的值并且做缓存(也就是混入<code>computer</code>)</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">getter<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">setGender</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">const</span> gender <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token operator">:</span><span class="token string">'保密'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">:</span><span class="token string">'女'</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> gender<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapGetters<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span>computed<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'setGender'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><ul><li><code>commit</code> === 同步</li><li>第一个参数永远是<code>state</code></li><li>混入<code>methods</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript">mutations<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">setUser</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>useId</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        state<span class="token punctuation">.</span>useId <span class="token operator">=</span> userId    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'mutations里面的方法名'</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapMutations<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span>methods<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'[setUser]'</span><span class="token punctuation">)</span>    <span class="token comment">//传递参数在调用this.setUser(args)既可</span>    <span class="token comment">//this.setUser(args)映射成this.$store.commit('setUser',args)</span><span class="token punctuation">}</span></code></pre><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4></li><li><code>dispatch</code> === 异步</li><li>通过调用<code>mutations</code>里面的方法进行更改<code>state</code></li><li>混入<code>methods</code><pre class="language-javascript" data-language="javascript"><code class="language-javascript">actions<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token function">login</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commit<span class="token punctuation">}</span><span class="token punctuation">,</span>val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'setUser'</span><span class="token punctuation">,</span>val<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">1.</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'mutations里面的方法名'</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token number">2.</span> <span class="token keyword">import</span> <span class="token punctuation">{</span>mapActions<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'Vuex'</span>methods<span class="token operator">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">//传递参数在调用this.login(args)既可</span>    <span class="token comment">//this.login(args)映射成this.$store.dispatch('login',args)</span>    <span class="token comment">//对login重命名</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">LOGIN</span><span class="token operator">:</span><span class="token string">'login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">LOGIN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web存储</title>
      <link href="/2021/08/24/web-cun-chu/"/>
      <url>/2021/08/24/web-cun-chu/</url>
      
        <content type="html"><![CDATA[<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><code>Cookie</code>是S端发送C端的一个小数据,下次请求的时候C端带上该数据,S端确认是不是同一个浏览器发送过来的数据。</p><blockquote><p>用处</p></blockquote><ol><li>保持登录的状态</li><li>个性化设置(主题)</li><li>浏览器的行为跟踪<br>缺点: <code>Cookie</code>会造成额外的性能开销,每次请求的时候会携带。</li></ol><p><strong>S端收到<code>http</code>请求的时候,S端在响应报文首部添加一个<code>set-cookie</code>的选项, C端收到之后会保存下<code>Cookie</code>,之后的C端每次请求通过请求头部将<code>Cookie</code>信息携带上</strong><br><code>set-Cookie</code>:<strong>&lt;cookie名&gt;=&lt;cookie值&gt;</strong><br><strong>cookie的分类</strong></p><ul><li>会话期的<code>cookie</code>(浏览器关闭之后就没有了,不需要设置过期的时间)</li><li>持久性的<code>cookie</code>(有一个过期时间,设定的时间只跟C端有关,和S端无关的)</li><li>第三方的<code>cookie</code>(<code>cookie</code>是同源的,第三方的<code>cookie</code>就是域和页面的域不同,只用于广告追踪)</li></ul><p><strong>cookie的属性</strong></p><ol><li><code>secure</code>:表示<code>cookie</code>只可以通过<code>https</code>进行传输,不可以使用<code>http</code>进行</li><li><code>httpOnly</code>:避免<code>xss</code>攻击的,就是该<code>cookie</code>设置了<code>httpOnly</code>的话,<code> JavaScript</code>脚本是不可以对该<code>cookie</code>进行调用的,只可以发送给服务器</li><li>作用域属性:规定哪些页面可以使用该<code>cookie</code>.通过<code>domian</code>和<code>path</code>属性来设置。<code>domain</code>包含子域名也可以得到该<code>cookle</code><br><code>path</code>的话指定主机的路径哪些可以接受<code>cookie</code>(指定根路径之后,下面的子路径也可以拿到)<pre class="language-none"><code class="language-none">path = /docs则以下可以拿到cookie/docs/web//docs/web/http/</code></pre></li><li><code>SameSite cookleSameSite=Strict</code></li></ol><p>可以取下面3个值</p><ul><li><p><code>None</code>没有做设置</p></li><li><p><code>Strict</code>只发送给相同站点请求的<code>cookle</code>(就是当前页面的<code>URL</code>与请求目标的<code>URL</code>完全一致)如果请求来自的网址和当前的<code>location</code>的地址不一样,则该<code>cookie</code>不会被发送</p></li><li><p><code>Lax</code>默认的</p></li></ul><p>5.过期时间</p><ul><li><code>session</code>: 表示会话性<code>cookie</code></li></ul><p><code>set-cookie</code> 响应头是服务器返回的响应头,用来在浏范器中种下<code>cookie</code>,一旦被种下,当浏范器访问符合条件的<code>url</code>地址的时候,会自动带上这个<code>cookie</code></p><h4 id="Session待定"><a href="#Session待定" class="headerlink" title="Session待定"></a>Session待定</h4><h4 id="token待定"><a href="#token待定" class="headerlink" title="token待定"></a>token待定</h4><h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><blockquote><p>勾引用户进入第三方的网站,在第三方的网站中,向被攻击的网站发送跨站清求,利用用户在被攻击的网站的登凭证<code>cookie</code>,绕过了后台的用户验证,达到冒充用户访问被攻击的网站进行相关的操作。</p></blockquote><ol><li>CSRF通常是第二方的网站发起</li><li>CSRF攻击者不可以获取到cookle等信息,只是使用而已</li></ol><blockquote><p>防护策略</p></blockquote><ol><li>阻止不明外域的访问</li></ol><ul><li>同源策略</li><li><code>Samesite Cookle</code></li></ul><ol start="2"><li>提交时要求附加本域才能获取信息</li></ol><ul><li><code>SCRF Token</code></li><li>双重的<code>Cookie</code>认证</li></ul><blockquote><p>Token解释</p></blockquote><ol><li>将<code>Token</code>输入到页面中,不能存在<code>Cookie</code>中,否则样被冒充,只能放在服务器的<code>session</code>中</li><li>页面请求携带这个<code>Token</code></li><li>服务器会验证<code>Token</code>是否正确</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期总结</title>
      <link href="/2021/08/24/vue-sheng-ming-zhou-qi-zong-jie/"/>
      <url>/2021/08/24/vue-sheng-ming-zhou-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ul><li><code>beforeCreate</code><br><code>data</code>和<code>methods</code>中的数据还没有被初始化</li><li><code>created</code><br><code>data</code>和<code>methods</code>中的数据已经被初始化,最早在这里进行操作他们的数据</li><li><code>beforeMounte</code><br>模板已经在内存中编辑完成了,但是还没有把模板渲染到页面中去。此时对dom元素无法进行相关的操作,页面中的元素还没有真正的替换出来,页面还是旧的</li><li><code>mounted</code><br>内存中的模板,已经真实的挂载到了页面中,用户可以看到已经渲染好的页面。实例披创建好的最后步,如果没有其他操作,他就安安静静的保存在内存之中<h4 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h4></li><li><code>beforeUpdote</code><br><code>data</code>里面的数据发生改变的时候才会触发0次或者多次。表示界面还没有被更新,但是数据已经被更新了。数据与页面不同步更新的,虚拟dom的特性</li><li><code>updated</code><br>数据和页面更新已经同步了,就是虚拟<code>dom</code>已经被变成了真实的<code>dom</code><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4></li><li><code>beforeDestroy</code><br><code>vue</code>实例的销毁阶段,实例身上所有的<code>data</code>、 <code>methods</code>以及指令和过这器等等还是可用的状态。</li><li><code>destroy</code><br>这里组件以及被完全销毁,实例身上所有的<code>data</code>、<code>methods</code>以及指令和过这器等已经是不可用的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Router文档总结</title>
      <link href="/2021/08/24/vue-router-wen-dang-zong-jie/"/>
      <url>/2021/08/24/vue-router-wen-dang-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="两种声明的方式"><a href="#两种声明的方式" class="headerlink" title="两种声明的方式"></a>两种声明的方式</h4><ul><li>声明式导航<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'about'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{path:'</span>about<span class="token string">'}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{name:'</span>about<span class="token string">'}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{name:'</span>about<span class="token string">',params:{userId:'</span><span class="token number">123</span><span class="token string">'}}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">'{name:'</span>about<span class="token string">',query:{plan:'</span><span class="token keyword">private</span><span class="token string">'}}'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span></code></pre></li><li>编程式导航<br>动态路由匹配: <code>url</code>地址中有一部分是一样的,另外一部分是动态变化的,这些动态变化就是路由参数,也就是动态路由匹配。两种方式:<blockquote><ol><li>用路由对象</li><li>使用<code>props</code></li></ol><ul><li>当<code>props</code>是<code>boolean</code>时候,路由对象里面的参数会被设置成组件的属性 <code>props:['id']</code></li><li>当<code>props</code>是<code>Object</code>时候,原样设置成组件的属性,没有设置在里面就拿不到</li><li>当<code>props</code>是<code>function</code>时候,啥也可以获取,接受路由对象做为自己的形参</li></ul></blockquote></li></ul><h4 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h4><p>路由的跳转是个大的过程,分为跳转前中后等等细小的过程,在每一个过程中有一 个相应的函教, 这个函数可以让你操作一些其他事情</p><ol><li>全局的(就是当触发路由的时候就会触发)<ul><li><code>beforeEach</code><br>路由还没有跳转之前就通知,防止跳转之后再告知就晚了,经常用来做登录的验证。</li><li><code>beforeResolve</code><br>导航被确认之前,同时组件内守卫和异步路由组件被解析之后执行也就是在<code>beforeEach</code>和组件内的<code>beforeRouteEnter</code>之后,<code>afterEach</code>之前调用。</li><li><code>afterEach</code><br>路由跳转完成之后触发</li></ul></li><li>路由独享的(就是在配路由的时候可以设置的钩子,该路由才有的)<ul><li><code>beforeEnter</code><br>和beforeEach是样的作用</li></ul></li><li>组件内部的(是指在组件内部执行的钩子函数,给该组件被配置在的路由添加生命周期的钩子函数)<ul><li><code>beforeRouterEnter</code><br>在<code>beforeCreated</code>之前调用,是拿不到<code>this</code>的,用<code>this</code>是访问不了组件的实例对象的,可以通过<code>next</code>函数,参数传入一个回调函数来获取组件实例,这个回调函数在路由被确认的时候就会调用。组件实例作为回调函故的参数。可以获取服务端的数据,当成功获取并能进入路由的时候,调用<code>next</code>通过<code>vm</code>访问组件实例进行赋值等操作。<code>next</code>中的函数调用在进入<code>mounted</code>之后。</li></ul></li></ol><ul><li><code>beforeRouterUpdate</code><br>当前路由改变的时候,并且该组件可以通过<code>this</code>访问实例。<code>/foo/1</code> 和<code>/foo/2</code>之间跳转组件会被复用,当前的<code>query</code>改变的时候,组件会被复用。</li><li><code>beforeRouterLeave</code><br>导航离开该组件的路由的时候调用,可以访问该组件的实例<code>this</code></li></ul><p><strong>参数</strong></p><ol><li><code>to</code> (目标路由对象)</li><li><code>from</code> (即将离开的路由对象)</li><li><code>next</code> (佛珠的线)<ul><li>但凡涉及到<code>next</code>的钩子,必须调用<code>next()</code>才可以继续执行下一个钩子,否则路由跳转就会停止</li><li>中断导航用<code>next(false)</code>。如果浏览器的地址改变了(用户手动、浏览器后退操作) <code>url</code>会重置到<code>from</code>的地址(登录验证失败的时候处理)</li><li><code>next('/')</code>或者<code>next(path:'/')</code>当前的导航被中断,然后进行新的导航</li><li>在<code>beforeRouterEnter</code>中<code>next(vm=&gt;{})</code>内接受的回调函数的参数为当前组件的实例<code>vm</code>,这个回调函数是在<code>mounted</code>之后调用的,也就是说,他是所有的导航守卫和生命周期函数最后执行的</li><li><code>next(error)</code>,导航被中断而且错误给<code>router.onError()</code>注册过的回调函数</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目中问题</title>
      <link href="/2021/08/24/vue-xiang-mu-zhong-wen-ti/"/>
      <url>/2021/08/24/vue-xiang-mu-zhong-wen-ti/</url>
      
        <content type="html"><![CDATA[<ul><li><code>computer</code>中传参数的话需要使用闭包的方式</li><li><code>filter</code>中无法访问<code>this</code>,使用<code>filter</code>的前提是有个现成的变量</li><li>数字千分位处理并保留两位小数<code>nums.toFixed(2).replace(/(\d)(?=(\d{3}+.)/g,'$1')</code></li><li><code>splice(index,1)</code>返回的数据是被删除的那个数据或者数组 —– 会改变原数组</li><li><code>try/catch</code> 只能捕获同步函数的异常,包括async/await</li><li><code>Vue</code>项目中报错<code>Already include file name 'xxxx' differs from files name...</code>,解决办法是：去掉后面<code>.vue</code>后缀名既可</li><li>页面刷新之后,会重新加载<code>Vue</code>实例,<code>store</code>里面的值会被重新赋值,这样会造成页面刷新只会<code>Vuex</code>中数据丢失的问题,解决办法是：利用<code>Web</code>存储<code>(cookie\localStorage\sessionStorage)</code></li><li>每一个页面都是一个组件,路由跳转的时候组件就会被<code>销毁和重新建立</code>,跳转会经历一个完整的生命周期</li><li><code>babel</code> 又名通天塔,它的作用是<code>ES6</code>、<code>ES7</code>转成<code>ES5</code></li><li><code>CSS</code>中的行内元素水平居中直接在父元素中<code>text-align:center</code>,垂直居中设置行高和高度相等:<code>height:10px;line-height:10px</code></li><li><code>SSR</code>服务端渲染<ul><li>前后端分离的缺点(适合后台管理项目或者大量路由的项目)<ul><li><code>SEO</code>不友好:因为页面中只有一个<code>div</code>,其他页面的操作是通过JS来进行的,<code>SEO</code>是通过爬取<code>html</code>代码的,而不是<code>JS</code>代码</li><li>首屏加载慢:更多的加载和渲染的工作是由浏览器来完成的</li><li>性能的问题:理由同上,频繁的和服务端进行数据交互</li></ul></li><li>解决上述办法-&gt;<code>SSR</code>服务端渲染(适合官网项目和推广页项目)<ul><li>简单来说就是服务端拿到数据进行解析渲染,直接生成<code>html</code>片段返回给前端</li><li>传统的服务端模板引擎渲染整个页面</li><li>服务端渲染生成的<code>html</code>代码块,前端通过<code>ajax</code>获取然后通过<code>JS</code>动态的添加</li></ul></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用跨域</title>
      <link href="/2021/08/24/chang-yong-kua-yu/"/>
      <url>/2021/08/24/chang-yong-kua-yu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端访问服务器的时候数据因为跨域无法直接得到<br>服务端和服务端之间的通信是不存在跨域的,都是同源<br>前后端不分离的时候就是同源,前端和后端代码在同一个电脑上</p></blockquote><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li>script</li><li>img</li><li>link</li><li>iframe<blockquote><p>它们不受同源策略的影响</p></blockquote></li></ul><hr><p>它们通过<code>script</code>标签的<code>src</code>,<code>src</code>指向服务器的<code>api</code>地址,因为不受同源的影响,因此可以访问带数据,之后把本地浏览器端的一个函数<code>func</code>作为回调函数传递给服务器。服务器收到请求,同时也可以拿到传过来的函数<br>之后服务器做两件事</p><ol><li>服务端准备数据<code>data</code></li><li>给客户端返回数据(利用传过来的函数进行包装<code>data</code>数据=&gt;<code>func('JSON.stringify(data)+')</code>。客户端收到响应,发现数据格式就是自己全局函数<code>func</code>,于是对函数<code>fun</code>进行调用,执行<code>JSON.parse</code>得到<code>data</code></li></ol><p><em><strong>特点</strong></em></p><ul><li><code>JSONP</code>需要服务端的支持</li><li><code>func</code>必须为全局函数</li><li>服务端需要利用<code>func</code>进行数据包装</li><li>只支持<code>get</code>请求(限制了我平时在开发中,基本用不到它！！！)</li></ul><hr><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><ul><li>C端发送<code>axios/ajax</code>请求并做一些基本的配置</li><li>S端设置响应头的相关信息,但是需要做<code>options</code>试探性的请求(如果是利用<code>node</code>开服务的话,可以利用中间件进行相关的设置) </li></ul><h4 id="http-proxy-gt-webpack-webpack-dev-server"><a href="#http-proxy-gt-webpack-webpack-dev-server" class="headerlink" title="http proxy =>webpack + webpack-dev-server"></a>http proxy =&gt;webpack + webpack-dev-server</h4><p>正常开发的<code>Vue</code>项目的时候,下载<code>webpack-dev-serve</code>直接设置<code>webpack</code>配置文件既可以。<code>Vue-cli</code>已经集成,在<code>vue.config.js</code>中进行配置</p><h4 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain+iframe"></a>document.domain+iframe</h4><p>只能实现同一个主域,不同子域之间的同源</p><pre class="language-none"><code class="language-none">v.qq.comsports.qq.comqq.com是主域</code></pre><h4 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h4><p>不需要前端参与,后端在<code>linux</code>中进行配置</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-S数据基本过程</title>
      <link href="/2021/08/24/c-s-shu-ju-ji-ben-guo-cheng/"/>
      <url>/2021/08/24/c-s-shu-ju-ji-ben-guo-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一次http请求至少进行两次的数据转换,发送请求的时候一次,获取响应数据的时候一次</p></blockquote><table><thead><tr><th>顺序</th><th>层名</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>应用层</td><td>数据</td></tr><tr><td>2</td><td>传输层</td><td>数据+源端口+目标端口</td></tr><tr><td>3</td><td>网络层</td><td>数据+源端口+目标端口+源IP+目标IP</td></tr><tr><td>4</td><td>链路层</td><td>转换成数字信息进行传输</td></tr></tbody></table><h4 id="从客户端-1-gt-2-gt-3-gt-4"><a href="#从客户端-1-gt-2-gt-3-gt-4" class="headerlink" title="从客户端 1->2->3->4"></a>从客户端 1-&gt;2-&gt;3-&gt;4</h4><h4 id="从服务端-4-gt-3-gt-2-gt-1"><a href="#从服务端-4-gt-3-gt-2-gt-1" class="headerlink" title="从服务端 4->3->2->1"></a>从服务端 4-&gt;3-&gt;2-&gt;1</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/08/24/bi-bao/"/>
      <url>/2021/08/24/bi-bao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS的函数内部可以访问全局变量,但是在函数的外部是不可以读取内部的局部变量<br>闭包其实就是提供一个方式来读取函数内部的变量</p></blockquote><h4 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h4><ul><li><p>单纯的觉得闭包是拿到函数内部的变量是不对的,以下这种方式也可以拿到,但它不是闭包</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 外部可以拿到a,但不是闭包</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span><span class="token number">100</span>    <span class="token keyword">return</span> a<span class="token punctuation">}</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//101</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//101   此时函数f3已经被垃圾回收了,再次调用就是重新开始创建变量等一系列的过程</span></code></pre></li><li><p>闭包真正的原因是局部变量无法长久保存,全局变量又容易污染环境,希望可以找到一种既可以长久保存又不会造成全局污染的方法,这就是<code>闭包的机制</code>。所以看似代码复杂化,其实大有来头。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f2<span class="token punctuation">}</span><span class="token keyword">let</span> f <span class="token operator">=</span> f1 <span class="token comment">// f1执行的结果,其实就是return出来的f2函数 ===== 闭包</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 101</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 102</span><span class="token comment">/** * 1、f1的调用结果被赋给了全局变量f,全局变量f一直存在于内存中,f1函数执行完毕之后就会被释放,但是return出来了一个函数,也就是会造成内存泄漏的原因（变量a没有被释放） * 2、a是局部变量但是他不会被销毁。因为f2还保持着对a的引用（JS的垃圾回收机制之中的引用计数原则）*/</span></code></pre><p>用匿名函数简写</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li></ul><ol><li>注意全局变量一直存在于内存中,局部变量执行完之后被垃圾回收（包括函数）,再次执行该函数的时候又得重新开始</li><li>闭包的代码复杂的真正原因<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//1</span><span class="token function">s1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token function">s2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//3</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode中使用git</title>
      <link href="/2021/08/20/vscode-zhong-shi-yong-git/"/>
      <url>/2021/08/20/vscode-zhong-shi-yong-git/</url>
      
        <content type="html"><![CDATA[<p><strong>在VsCode中使用Git提交的过程</strong></p><ol><li>先确定提交的分支,”+”是提交到暂缓区,相当于<code>git add .</code></li><li>“√”是将暂缓区的代码提交到本地代码仓库,相当于<code>git commit -m ""</code></li><li>提交到<code>github</code>远程仓库之前，应该先”拉取”远程仓库，用来和本地的仓库做同步，如果有冲突，VsCode会自动跳出冲突，编辑解决完冲突之后，再进行下一步</li><li>最后一步”推送”，本地仓库的代码同步到<code>github</code>远程仓库</li></ol>]]></content>
      
      
      <categories>
          
          <category> VsCode </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bom知识总结</title>
      <link href="/2021/08/20/bom-zhi-shi-zong-jie/"/>
      <url>/2021/08/20/bom-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>好记性不如烂笔头！</p><h3 id="1-BOM-Browser-Object-Model"><a href="#1-BOM-Browser-Object-Model" class="headerlink" title="1.BOM: Browser Object Model"></a>1.BOM: Browser Object Model</h3><p>什么是: 专门操作浏览器窗口的API<br>没有标准, 导致浏览器兼容性问题<br>包括:<br>window<br>history<br>location<br>navigator<br>dom<br>event<br>screen</p><h3 id="2-window"><a href="#2-window" class="headerlink" title="2.window:"></a>2.window:</h3><p>属性: .innerWidth, .innerHeight 浏览器窗口中,文档显示区的宽和高<br>方法: .open() .close() .open(“url”,”name”)</p><p>三种:</p><pre class="language-none"><code class="language-none">CODE1.在当前窗口打开,可后退: .open("url","_self")2.在新窗口打开,可打开多个: .open("url","_blank")3.在新窗口打开,只能打开一个:   .open("url","自定义窗口名")</code></pre><h3 id="3-history-保存当前窗口打开后-成功访问过的url的历史记录栈"><a href="#3-history-保存当前窗口打开后-成功访问过的url的历史记录栈" class="headerlink" title="3.history: 保存当前窗口打开后,成功访问过的url的历史记录栈"></a>3.history: 保存当前窗口打开后,成功访问过的url的历史记录栈</h3><p>在当前窗口中,每访问一个新url,都会将新url压入history<br>API: history.go(n)</p><p>3种:</p><pre class="language-none"><code class="language-none">CODE前进: history.go(1)  后退: history.go(-1)  刷新: history.go(0)</code></pre><h3 id="4-location-保存当前窗口正在打开的url的对象"><a href="#4-location-保存当前窗口正在打开的url的对象" class="headerlink" title="4.location: 保存当前窗口正在打开的url的对象"></a>4.location: 保存当前窗口正在打开的url的对象</h3><p>属性:<br>.href 完整url地址<br>.protocol 协议<br>.host 主机名+端口号<br>.hostname 主机名<br>.port 端口号<br>.pathname 相对路径<br>.hash #锚点地址<br>.search ?查询字符串</p><p>方法:</p><ol><li>在当前窗口打开,可后退:<br>location.assign(url) =&gt; location.href=url =&gt; location=url</li><li>在当前窗口打开,禁止后退:<br>location.replace(url)</li><li>重新加载页面: 刷新: 2种:<ol><li>普通刷新:<br>优先从浏览器本地缓冲获取资源:<br>F5<br>history.go(0)<br>location.reload(/<em>false</em>/)</li><li>强制刷新:<br>无论本地是否有缓存,总是强制从服务器获取资源<br>location.reload(true)</li></ol></li></ol><h3 id="5-定时器-2种"><a href="#5-定时器-2种" class="headerlink" title="5.定时器: 2种:"></a>5.定时器: 2种:</h3><ol><li><p>周期性定时器:<br>什么是: 让程序每隔指定的时间间隔,反复执行一项任务<br>何时: 只要让程序按照指定的时间间隔,自动执行一项任务<br>如何: 3件事:<br>1.任务函数: 让定时器反复执行的任务<br>2.启动定时器: timer=setInterval(task, interval)</p><pre class="language-none"><code class="language-none">CODE让程序,每隔interval 毫秒自动执行一次task任务</code></pre><p>3.停止定时器: clearInterval(timer)</p><pre class="language-none"><code class="language-none">CODEtimer: 定时器的序号, 在内存中唯一标识定时器的整数 专门用于停止定时器 如何获得: 只能在启动定时器时获得。 何时: 只要一个定时器可能被停止,就要在启动时,先保存定时器序号 好的习惯: 在clearInterval之后,手动清除timer中残留的序号: timer=null;</code></pre><p>停止定时器: 2种情况:</p><ol><li>用户手动停止:</li><li>定时器可自动停止:<br>在任务函数中,设定临界值,如果没有达到临界值,则继续执行任务,否则,如果达到临界值,就自动调用clearInterval</li></ol></li></ol><p>2.一次性定时器:<br>什么是: 让程序先等待一段时间,再执行一次任务。执行后,自动停止。<br>何时: 只要让程序延迟执行一件事时<br>如何: 3件事:<br>1.task<br>2.启动定时器: timer=setTimeout(task,wait)</p><pre class="language-none"><code class="language-none">CODE让程序等待wait毫秒后,自动执行一次task,执行后自动停止</code></pre><p>3.停止定时器: clearTimeout(timer)</p><h3 id="6-定时器原理"><a href="#6-定时器原理" class="headerlink" title="6.定时器原理:"></a>6.定时器原理:</h3><p>定时器中的任务函数,必须等待主程序所有语句执行后,才能执行。</p><h3 id="7-navigator"><a href="#7-navigator" class="headerlink" title="7.navigator:"></a>7.navigator:</h3><p>1.什么是: 保存浏览器配置信息的对象<br>包括:<br>.cookieEnabled: 判断当前浏览器是否启用cookie</p><p>2.什么是cookie: 在客户端持久存储用户私密数据的小文件<br>为什么: 内存中所有数据都是临时的! 程序关闭,内存中一切变量都释放!<br>何时: 只要希望在客户端持久保存数据,都用cookie<br>.plugins: 包含浏览器所有插件信息的集合</p><p>3.什么是插件: 为浏览器添加新功能的小软件</p><pre class="language-none"><code class="language-none">CODE如何判断是否安装指定插件: </code></pre><p>.userAgent: 保存浏览器名称和版本号的字符串<br>何时: 只要判断浏览器名称和版本号</p><h3 id="8-event"><a href="#8-event" class="headerlink" title="8.event:"></a>8.event:</h3><p>什么是事件: 人为触发的,或浏览器自动触发的页面内容状态的改变。<br>什么是事件处理函数: 当事件发生时,自动执行的函数。<br>如何绑定: 3种:</p><ol><li>在HTML中绑定:<br>绑定:<br>当事件发生时: 自动执行js语句<br>问题: 不符合内容与行为分离的原则,不便于维护和重用<br>但是: 在组件开发中,反而要求内容,行为和样式集中定义在一个小组件内,自成体系。</li><li>在js中绑定, 每个事件只能绑定一个处理函数:<br>ANY.on事件名=function(){ … }<br>当事件发生时: ANY.on事件名() //this-&gt;ANY<br>问题: 用赋值方式绑定事件处理函数</li><li>在js中绑定,每个事件可绑定多个处理函数:<br>ANY.addEventListener(‘事件名’,handler)<br>在浏览器中为ANY元素的指定事件,添加一个事件监听对象。将事件监听对象加入到浏览器的监听队列中。<br>触发事件时: 浏览器会遍历监听队列中的每个监听对象,找到触发事件元素上对应事件的监听对象,调用其处理函数<br>移除事件监听:<br>ANY.removeEventListener(‘事件名’,handler)<br>说明: handler必须是绑定时使用的原函数对象<br>强调: 如果一个处理函数,有可能被移除,则不能使用匿名函数绑定。应使用有名的函数绑定</li></ol><h3 id="9-DOM事件模型"><a href="#9-DOM事件模型" class="headerlink" title="9.DOM事件模型:"></a>9.DOM事件模型:</h3><p>什么是: 从事件触发到处理函数执行,所经过的过程<br>3个阶段:</p><ol><li>捕获capture: 由外向内,记录各级父元素上绑定的事件处理函数。——仅记录,不触发!</li><li>目标触发: 优先触发实际点击的元素上绑定的处理函数</li><li>冒泡执行: 由内向外,按捕获阶段记录的处理函数的倒序,依次执行父元素上的处理函数。</li></ol><h3 id="10-事件对象"><a href="#10-事件对象" class="headerlink" title="10.事件对象:"></a>10.事件对象:</h3><p>什么是: 当事件发生时,自动创建的,封装事件信息的对象<br>何时: 只要希望获得事件信息,或修改事件的默认行为时<br>如何获取: 事件对象默认总是以处理函数第一个参数,自动传入<br>如何使用:</p><ol><li><p>取消冒泡: e.stopPropagation()</p></li><li><p>利用冒泡:<br>优化: 尽量减少事件监听的个数<br>为什么: 浏览器查找事件监听,采用的是遍历的方式</p><pre class="language-none"><code class="language-none">CODE事件监听多,浏览器查找就慢</code></pre><p>何时: 如果对多个子元素绑定相同事件时,都要利用冒泡<br>如何: 只要在父元素绑定一次,所有子元素共用即可!<br>2个难题:</p><pre class="language-none"><code class="language-none">CODE1. 获得目标元素:  目标元素: 最初实际触发事件的当前元素  如何获得:    错误: this-&gt;父元素   正确: e.target2. 筛选目标元素:  比如: 通过nodeName, class, 内容。。。</code></pre></li><li><p>阻止默认行为:<br>何时: 只要事件的默认行为不是想要的<br>如何: e.preventDefault();<br>何时:</p><ol><li>用a当按钮时,a会自动向地址栏中添加#锚点地址。</li><li>提交表单时,如果验证没通过,可阻止提交<br>自定义表单提交:<br>input button + onclick + form.submit<br>input submit + form.onsubmit事件 + e.preventDefault()</li><li>HTML5中拖拽API: 首先要阻止浏览器默认的拖拽行为</li></ol></li></ol><h3 id="11-鼠标坐标-3组"><a href="#11-鼠标坐标-3组" class="headerlink" title="11.鼠标坐标:(3组)"></a>11.鼠标坐标:(3组)</h3><pre class="language-none"><code class="language-none">CODE1. 相对于屏幕左上角: e.screenX,  e.screenY2. 相对于文档显示区左上角: e.clientX,  e.clientY3. 相对于当前元素左上角:  e.offsetX,   e.offsetY</code></pre><h3 id="12-页面滚动"><a href="#12-页面滚动" class="headerlink" title="12.页面滚动:"></a>12.页面滚动:</h3><p>事件: window.onscroll<br>获得页面滚动过的高度: body顶部超出文档显示区顶部的距离</p><pre class="language-none"><code class="language-none">CODEscrollTop=document.documentElement.scrollTop        ||document.body.scrollTop;</code></pre><p>滚动API:<br>window.scrollTo(left, top)<br>window.scrollBy(left的增量,top的增量)</p>]]></content>
      
      
      <categories>
          
          <category> BOM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BOM </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css知识总结</title>
      <link href="/2021/08/20/css-zhi-shi-zong-jie/"/>
      <url>/2021/08/20/css-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前端知识点总结——CSS"><a href="#前端知识点总结——CSS" class="headerlink" title="前端知识点总结——CSS"></a><strong>前端知识点总结——CSS</strong></h2><p>好记性不如烂笔头！</p><h3 id="1-CSS的概述"><a href="#1-CSS的概述" class="headerlink" title="1.CSS的概述"></a>1.CSS的概述</h3><p>1.什么是CSS?</p><pre class="language-none"><code class="language-none">CODECSS：Cascading Style Sheets层叠样式表,级联样式表（简称：样式表）</code></pre><p>2.作用</p><pre class="language-none"><code class="language-none">CODE设置HTML网页元素的样式</code></pre><p>3.HTML与CSS的关系</p><pre class="language-none"><code class="language-none">CODEHTML：负责内容的展示CSS：负责内容（元素）的修饰</code></pre><p>4.HTML与CSS之间的使用原则</p><pre class="language-none"><code class="language-none">CODEW3C建议尽量使用CSS属性去取代HTML属性来修饰元素</code></pre><h3 id="2-CSS语法规范"><a href="#2-CSS语法规范" class="headerlink" title="2.CSS语法规范"></a>2.CSS语法规范</h3><p>1.使用CSS样式的方式(重点)</p><pre class="language-none"><code class="language-none">CODE 1.内联样式   又称为行内样式   特点：将CSS样式定义在HTML开始标记中   语法：     &lt;ANY style="样式声明1；样式声明2"&gt;&lt;/ANY&gt; 样式声明：      1.由样式属性和值来组成      2.属性名与值之间用 冒号 连接      3.多个样式声明之间用 分号 分割        常用的CSS样式属性 和 值：      1.设置文本颜色的属性和值        属性：color    值：合法的颜色值（英文）      2.设置背景颜色的属性和值        属性：background    值：合法的颜色值（英文）      3.设置文字大小的属性和值        属性：font-size    值：以px或pt为单位的数字    ex：font-size:30px;      2.内部样式   在网页的头元素中增加一对&lt;style&gt;标记,在&lt;style&gt;标记声明该网页用到的样式规则   语法： &lt;head&gt;             &lt;style&gt;        /*注释*/        样式规则1        样式规则2        ...     &lt;/style&gt;      &lt;/head&gt;    样式规则：由选择器和样式声明组成选择器：规范了页面中哪些元素能够使用定义好的样式（就是把声明好的样式匹配给页面中的元素）元素选择器：由元素的名称作为选择器div,p,h1,span,a,img选择器{}ex：div{}    p{}样式规则：   选择器{      样式声明；   }ex:div{   color:red;   font-size:20px;}p{  color:blue;}h1{...} 3.外部样式   独立于任何网页的位置处,声明一个样式表文件（***.css为后缀）,   在.css文件中保存样式规则,然后在网页中引入.css文件。   使用步骤：       1.创建样式表文件,并编写样式规则   2.在网页中引入样式表文件     &lt;head&gt;        &lt;link rel="stylesheet" href="**.css"&gt;     &lt;/head&gt;</code></pre><h3 id="3-CSS样式特征"><a href="#3-CSS样式特征" class="headerlink" title="3.CSS样式特征"></a>3.CSS样式特征</h3><pre class="language-none"><code class="language-none">CODE1.继承性  大部分样式可以被继承（子元素继承父元素的样式特征）  必须是有层级关系的嵌套  &lt;div style="color:red;"&gt;     &lt;p&gt;p&lt;/p&gt;  &lt;/div&gt;2.层叠性   可以为一个元素定义多个样式,当样式属性不冲突时,可以同时将这些样式应用到元素上  div{     color:red;  }  div{     font-size:20px;  }  div{     background:gray;  }3.优先级  如果样式声明冲突时,会按照样式的优先级来应用定义的样式规则      由低到高：     浏览器默认设置       最低     内部样式和外部样式   中(就近原则)     内联样式             最高4.调整显示的优先级  !important规则：  调整显示的优先级  将!important添加在属性值之后,与值之间用空格隔开,就能优先使用当前样式  ex:    color:red !important;</code></pre><h3 id="4-CSS基础选择器（重点）"><a href="#4-CSS基础选择器（重点）" class="headerlink" title="4.CSS基础选择器（重点）"></a>4.CSS基础选择器（重点）</h3><pre class="language-none"><code class="language-none">CODE1.选择器的作用  规范页面中哪些元素能够使用定义好的样式2.选择器详解  1.通用选择器    作用：可以修饰页面上的任何元素语法：*{样式声明}效率较低,尽量少用ex:  *{    color:red;    font-size:40px;  }</code></pre><p>2.元素选择器</p><pre class="language-none"><code class="language-none">CODE    作用：设置页面上某种（类）元素的样式语法：标记名称{声明样式}ex：  div{}  p{}  span{}  </code></pre><p>3.类选择器</p><pre class="language-none"><code class="language-none">CODE    作用：定义页面上某个或某些元素的样式(谁想用谁就可以引用)特点：通过元素的class属性进行引用语法：   1.声明     .类名{样式声明}     注意：       1.类名是自定义的,但是注意类名不能以数字开头       2.类名不能包含特殊符号（&amp;,^,%,$,#,@）       3.可以包含（_,-）   2.引用     &lt;ANY class="类名"&gt;    特殊用法：       1.多类选择器     让一个元素同时引用多个类选择器     语法：     &lt;ANY class="类名1 类名2 类名3 ..."&gt;       2.分类选择器     将元素选择器和类选择器联合使用     对同一类元素中某些特殊的内容进行修饰     语法：元素名称.类选择器{样式声明}        ex:div.text{color:red;}      &lt;div class="text"&gt;dddd&lt;/div&gt;      &lt;div&gt;d1d1d1&lt;/div&gt;</code></pre><p>4.id选择器</p><pre class="language-none"><code class="language-none">CODE作用：设置指定ID元素的样式（专属定制）语法：#id值{样式声明}ex:  &lt;div id="one"&gt;&lt;/div&gt;  #one{    color:red;  }</code></pre><p>5.群组选择器</p><pre class="language-none"><code class="language-none">CODE作用：将多个选择器放在一起进行样式的声明定义语法：选择器1,选择器2,选择器3,...{样式声明} ex:   div,#main,.mycolor,p.text{color:red;}   等同于： div{color:red}; #main{color:red}; .mycolor{color:red}; p.text{color:red};</code></pre><p>6.后代选择器</p><pre class="language-none"><code class="language-none">CODE作用：通过元素的后代关系匹配元素（多级嵌套）语法：选择器1 选择器2 选择器3{样式声明}</code></pre><p>7.子代选择器</p><pre class="language-none"><code class="language-none">CODE作用：通过元素的子代（一层层级关系）关系匹配元素语法：选择器1&gt;选择器2{样式声明}</code></pre><p>8.伪类选择器</p><pre class="language-none"><code class="language-none">CODE作用：匹配元素不同的状态的选择器语法：   所有的伪类都是以：作为开始   选择器：伪类选择器{样式声明}1.连接伪类     :link 匹配元素尚未访问的状态 :visited 匹配元素访问过的状态2.动态伪类     :hover 匹配鼠标悬停在元素上时的状态 :active 匹配元素被激活时的状态（超链接,文本框,密码框点击的时候） :focus 匹配元素获取焦点时的状态（文本框和密码框）3.选择器的优先级  权值：标识当前选择器的重要程度,权值越大优先级越高。    元素选择器：1类选择器：  10伪类选择器：10ID选择择器：100内联样式：  1000选择器的权值加到一起,大的优先权值相同,以后定义的为主</code></pre><h3 id="5-尺寸与边框"><a href="#5-尺寸与边框" class="headerlink" title="5.尺寸与边框"></a>5.尺寸与边框</h3><p>1.单位</p><pre class="language-none"><code class="language-none">CODE1.尺寸单位  1.px：像素    1024*768  2.in:英寸    1in=2.54cm  3.pt：磅(1pt=1/72in)    多数用于表示文字的大小  4.cm:厘米  5.mm:毫米  6.em:相对于父元素乘以倍数(多个父元素2em)  7.rem:根相对（元素字体大小乘以倍数,html\body）2.颜色单位（颜色取值）  1.英文单词    red,blue,gray,green,yellow,black....  2.rgb(r,g,b)    r:0-255g:0-255b:0-255  3.rgba(r,g,b,alpha)    alpha:透明度,取值为0-1之间的小数,值越大,不透明度越高  4.#rrggbb    由6位16进制的数字\字母表示一个颜色0-9或A-f#000000:黑色#ffffff:白色#eeeeee:灰色#ff11aa  5.#rgb是上面的缩写形式    #000:黑色#fff:白色#f1a</code></pre><p>2.尺寸属性</p><pre class="language-none"><code class="language-none">CODE1.作用  设置元素的宽度和高度2.语法  1.宽度    width:宽度min-width:最小宽度max-width:最大宽度  2.高度    height：高度min-height:最小高度max-height:最大高度3.页面中哪些元素允许设置尺寸属性  1.所有的块级元素都允许设置尺寸    div,p,h1,h2..h6,ul,ol,dl,结构标记  2.本身具备width和height属性的行内元素是可以设置的    img,table  3.行内块允许设置尺寸    大部分的表单控件（单选按钮,复选框）  4.大部分的行内元素是无法设置尺寸    a,span,b,i,u,s等</code></pre><p>3.溢出处理</p><pre class="language-none"><code class="language-none">CODE当内容多,元素区域小的时候,就会产生溢出的效果,默认都是纵向溢出。属性：overflow,overflow-x,overflow-y取值：   1.visible     可见的,默认值,溢出可见   2.hidden     隐藏的,溢出的内容全部隐藏,溢出内容不可见   3.scroll     显示滚动条,溢出时,可用   4.auto     自动,溢出时才显示滚动条并可用</code></pre><p>4.边框</p><pre class="language-none"><code class="language-none">CODE1.边框属性  1.简写方式    border:width style color;     width:边框的宽度,以px为单位的数值     style:边框的样式       取值：         solid:实线     dotted:虚线边框(点)     dashed:虚线边框(线)     color:边框的颜色         取值：合法的颜色值     transparent:透明色     注意：       取消边框：border:0;或border:none;  2.单边定义    只设置某一条边的边框属性：border-方向:width style color;    方向：top/bottom/left/right       上   下     左   右  3.单属性定义    只设置四条边框的一个属性属性：border-width/style/color:值；  ex:border-width:3px;     border-style:dotted;     border-color:red;  4.单边单属性的定义    只设置某一个方向的某一个属性属性：  border-方向-属性：值；  方向：top/bottom/left/right  属性：width/style/color  ex：    border-left-color:blue;    border-right-style:solid;    border-bottom-width:6px;2.边框倒角  将元素的直角倒换成圆角  属性：border-radius  取值：        1.以px为单位的数值        2.百分比 %  设置圆形（50%）  单角设置：     border-top-left-radius:左上角 border-top-right-radius:右上角 border-bottom-left-radius:左下角 border-bottom-right-radius:右下角3.边框阴影 属性：box-shadow 取值：h-shadow v-shadow blur spread color inset    h-shadow:阴影在水平方向的偏移距离,必须值        取值为正：阴影向右偏移     取值为负：阴影向左偏移v-shadow:阴影在垂直方向的偏移距离,必须值        取值为正：阴影向下偏移     取值为负：阴影向上偏移blur:阴影模糊距离,取值越大,模糊效果越明显,以px为单位的数值（可选值）spread:阴影的大小,指定要在基础阴影上扩充出来的大小,取值以px为单位的数值（可选值）color:阴影颜色（可选值）inset:将默认的外阴影改为内阴影（可选值）4.轮廓  轮廓指的是边框的边框,绘制于边框外围的一条线  属性：     outline:width style color; widht:轮廓的宽度 style:轮廓的样式      取值：solid/dotted/dashed color:轮廓的颜色  取消轮廓：       outline:none/0;</code></pre><h3 id="6-框模型"><a href="#6-框模型" class="headerlink" title="6.框模型"></a>6.框模型</h3><p>1.什么是框模型</p><pre class="language-none"><code class="language-none">CODE框模型：box model,定义了元素框处理元素的内容,内边距,外边距以及边框的一种计算方式。外边距：元素与元素之间的空白间距内边距：元素边框与元素内容之间的间距框模型的计算模式：    元素的实际占地宽度=左右外边距+左右边框+左右内边距+width;元素的实际占地高度=上下外边距+上下边框+上下的内边距+height</code></pre><h3 id="7-外边距"><a href="#7-外边距" class="headerlink" title="7.外边距"></a>7.外边距</h3><p>1.什么是外边距</p><pre class="language-none"><code class="language-none">CODE围绕在元素边框外的空白距离,就是外边距也能表示当前元素与其他元素之间的空白距离</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：   margin 定义某个元素四个方向的外边距   margin-top/bottom/left/right 定义单边的外边距取值：   1.具体数值,以px为单位   2.取值为负     让元素向相反的方向移动 margin-left:  取值为正,让元素向右移动  取值为负,让元素向左移动 margin-top:  取值为正,让元素向下移动  取值为负,让元素向上移动   3.取值为%     外边距的值,是父元素的宽或高的占比（50%）   4.取值为auto     自动计算外边距的值（控制块级元素水平居中对齐）简写方式：    1.margin:value  四个方向的外边距2.margin:v1 v2;  v1:上下外边距  v2:左右外边距3.margin:v1 v2 v3;  v1:上外边距  v2:左右外边距  v3:下外边距3.margin:v1 v2 v3 v4;         上 右 下 左  （顺时针方向）</code></pre><p>3.自带外边距的元素</p><pre class="language-none"><code class="language-none">CODEbody,h1~h6,p,ul,ol,dl,dd,pre通过CSS Reset(css重写)的手段,来重置具备外边距的元素 body,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd,pre{    margin:0; }</code></pre><p>4.外边距的特殊效果</p><pre class="language-none"><code class="language-none">CODE1.外边距合并  当两个垂直外边距相遇时,他们将合并为一个,最终取决于两个外边距中距离较大的那个。  如果两个外边距相遇时值相等,那么取其中一个值。2.外边距的溢出  在某些条件下,为子元素设置上外边距时,有可能会作用到父元素上。      1.父元素没有上边框  2.为子元素设置上外边距时2.在d2中嵌套一个子元素div,id="d3",设置其尺寸为100*100,并设置其背景颜色3.设置d3的上外边距为50px,观察其结果。 解决溢出方案：    1.为父元素增加上边框  弊端：对父元素的高度有影响2.使用父元素的上内边距来取代子元素的上外边距  弊端：对父元素的高度有影响3.在父元素的第一个子元素位置处,增加一个空(table) 行内元素以及行内块元素的垂直外边距     1.行内元素垂直外边距无效（img除外） 2.行内块元素,设置垂直外边距时,整行元素都跟着发生改变</code></pre><h3 id="8-内边距"><a href="#8-内边距" class="headerlink" title="8.内边距"></a>8.内边距</h3><p>1.什么是内边距</p><pre class="language-none"><code class="language-none">CODE元素边框与内容之间的空白距离内边距会扩大元素边框占地区域</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：   padding 四个方向的内边距   padding-top/bottom/left/right 设置单边内边距取值：      以px为单位的数值      以%形式设置简写方式：      1.padding:value;  四个方向的内边距  2.padding:v1 v2;     v1:上下内边距    v2:左右内边距  3.padding:v1 v2 v3;    v1:上    v2:左右    v3:下  4.padding:v1 v2 v3 v4;            上 右 下 左 （顺时针）</code></pre><h3 id="9-属性：box-sizing"><a href="#9-属性：box-sizing" class="headerlink" title="9.属性：box-sizing"></a>9.属性：box-sizing</h3><p>作用：指定框模型的计算方式</p><pre class="language-none"><code class="language-none">CODE取值：   1.content-box     默认值,采用默认的计算元素的占地区域 实际占地宽度=左右边框+左右外边距+左右内边距+width; 实际占地高度=上下边框+上下外边距+上下内边距+height;   2.border-box     元素的尺寸,会包含border以及padding的值 实际占地宽度=width(包含了border和padding) 实际占地高度=height(包含了border和padding)</code></pre><p>3.背景属性<br>背景：可以是单一颜色或图片填充元素<br>1.背景色</p><pre class="language-none"><code class="language-none">CODE属性：background-color取值：合法的颜色值注意：背景颜色默认是从边框的位置处开始填充的</code></pre><p>2.背景图片</p><pre class="language-none"><code class="language-none">CODE属性：background-image取值：url(图片的路径);ex:background-image:url(a.jpg);</code></pre><p>3.背景图片平铺</p><pre class="language-none"><code class="language-none">CODE属性：background-repeat取值：   repeat 默认值,横向纵向都平铺   no-repeat 不平铺（图片只显示一次）   repeat-x 只在水平方向平铺   repeat-y 只在垂直方向平铺</code></pre><p>4.背景图片尺寸</p><pre class="language-none"><code class="language-none">CODE属性：background-size取值：   1.width/height  (ex:200px 300px)   2.width%/height%  (ex:50% 50% 是元素自己的高宽占比)   3.cover     将背景图等比放大,直到背景图完全覆盖到元素的所有区域为止。   4.contain     将背景图等比放大,直到背景图碰到元素的某一个边缘为止</code></pre><p>5.背景图片固定</p><pre class="language-none"><code class="language-none">CODE作用：将背景图固定在网页的某个位置处,一直在可视区域中,不会随着滚动条而发生位置的变化。属性：background-attachment取值：   1.scroll 默认值,滚动   2.fixed 固定</code></pre><p>6.背景图片定位</p><pre class="language-none"><code class="language-none">CODE作用：改变背景图在元素中的位置属性：background-position取值：   1.x y  具体的数值（px）     x:   背景图水平偏移距离   取值为正,向右移动   取值为负,向左移动 y:   背景图垂直偏移距离   取值为正,向下移动   取值为负,向上移动   2.x% y%     0% 0% 背景图在左上角 100% 100% 背景图在右下角 50% 50% 背景图在中间位置   3.关键字 x:left/center/right y:top/center/bottom ex:background-position:right top;</code></pre><p>7.背景简写属性</p><pre class="language-none"><code class="language-none">CODE在一个属性中指定背景的多个属性值属性：background取值：color url() repeat attachment positionex：  background:gray url(a.jpg);注意：  如果不设置其中某个属性值的话,该位置采用默认值。</code></pre><h3 id="8-渐变"><a href="#8-渐变" class="headerlink" title="8.渐变"></a>8.渐变</h3><p>1.什么是渐变</p><pre class="language-none"><code class="language-none">CODE渐变指定是多种颜色平缓变换的一种显示效果。</code></pre><p>2.渐变的主要因素</p><pre class="language-none"><code class="language-none">CODE1.色标：一种颜色及其出现的位置2.一个渐变是由多个色标组成（至少两个）</code></pre><p>3.渐变分类</p><pre class="language-none"><code class="language-none">CODE1.线性渐变  以直线的方向来填充效果2.径向渐变  以圆形的方式来实现填充3.重复渐变  将线性渐变或径向渐变 重复几次实现填充</code></pre><p>4.渐变详解</p><pre class="language-none"><code class="language-none">CODE1.线性渐变  属性：background-image  取值：linear-gradient(angle,color-point1,color-point2,....);    1.angle  表示渐变填充的方向或角度  取值：    1.关键字      to top 从下向上填充渐变色      to bottom 从上向下填充渐变色      to left 从右向左填充渐变色      to right 从左向右填充渐变色    2.角度值     0deg 从下向上填充,等同于to top     90deg 从左向右填充,等同于to right     180deg 从上到下填充,等同于to bottom     270deg 从右向左填充,等同于to left    2.color-point  色标：颜色 及其 位置  取值：颜色 以及 位置的组合,中间用空格分开  ex:    1.red 0%      在填充方向的开始位置处颜色为红色    2.green 50%      到填充方向一半的位置处,颜色变为绿色    3.blue 200px      到填充方向的200px的位置处,颜色变为蓝色2.径向渐变  属性：  background-image:radial-gradient([size at position],  color-point1,color-point2,...);  size at position:       size:半径,以px为单位的数值  position:圆心所在位置       1.x y 具体数值       2.x% y% 元素宽和高的占比       3.关键字         x:left,center,right     y:top,center,bottom  ex：    100px at right top 半径     右上角位置3.重复渐变  1.重复线性渐变    background-image:repeating-linear-gradient    (angle,color-point1,color-point2,...);color-point:位置一定要给绝对数值（px）,不要用相对单位%  2.重复径向渐变    background-image:repeating-radial-gradient    ([size at position],color-point1,color-point2,...);</code></pre><h3 id="9-浏览器兼容性"><a href="#9-浏览器兼容性" class="headerlink" title="9.浏览器兼容性"></a>9.浏览器兼容性</h3><pre class="language-none"><code class="language-none">CODE 各个浏览器的新版本都支持渐变属性对于不支持的浏览器版本,可以通过增加浏览器前缀的方式,让浏览器支持渐变属性Firefox:-moz-Chrome &amp; Sagari:-webkit-Opera:-o-IE:-ms-</code></pre><p>2.文本格式化属性<br>1.字体属性</p><pre class="language-none"><code class="language-none">CODE1.指定字体  属性：font-family  取值：字体名称,名称之间用逗号隔开  ex：  font-family:"微软雅黑",Arial,"黑体";2.字体大小  属性：font-size  取值：以px或pt为单位的数字3.字体加粗  属性：font-weight  取值：     1.bold 加粗（b,hn） 2.normal 正常 3.value 无单位的数字（整百倍）   400-900   400：等同于normal   900：等同于bold4.字体样式  属性：font-style  取值：     1.normal 正常显示  2.italic 斜体显示5.小型大写字母   将小写字符变成大写,但文本的大小与小写字符一致   属性：font-variant   取值：      1.normal 正常  2.small-caps 小型的大写字符6.字体属性简写  属性：font  取值：style variant weight size family;  注意：    如果用简写方式,必须设置family的值,否则无效。font:12px; 错误font:12px "黑体"; 正确</code></pre><p>2.文本格式</p><pre class="language-none"><code class="language-none">CODE1.文本颜色  属性：color  取值：合法的颜色值2.文本排列  作用：指定文本,行内,行内块元素的水平对齐方式。  属性：text-align  取值：left/center/right/justify(两端对齐)3.文字修饰（线条）  属性：text-decoration  取值：    none:无任何线条修饰underline:下划线修饰overline:上划线修饰    line-through:删除线修饰4.行高  作用:定义一行文本的高度  特点：如果行高的高度大于字体本身的大小,那么该行文本将在指定的行高内呈现垂直居中的效果。  属性:line-height  取值：以px为单位数值5.首行文本缩进  属性：text-indent  取值：以px为单位的数值6.文本阴影  属性：text-shadow  取值：h-shadow v-shadow blur color;</code></pre><h3 id="10-表格"><a href="#10-表格" class="headerlink" title="10.表格"></a>10.表格</h3><p>1.表格的常用属性</p><pre class="language-none"><code class="language-none">CODE1.边距属性：padding2.边框属性：border3.尺寸属性：width,height4.文本格式化属性：font-*,text-*,line-height5.背景属性：颜色,图片,渐变6.vertical-align  作用：指定单元格数据垂直对齐方式  取值：     top:上对齐 middle:居中对齐 bottom:下对齐 练习：创建网页,并在网页中添加表格     1.表格尺寸为400*400,4行4列; 2.每个单元格的尺寸为100*100,内容随意; 3.设置表格和单位元格的边框为1px solid #000; 4.设置每个单元格的左内边距为20px; 5.尝试为每个单元格增加上外边距15px。</code></pre><p>2.表格的特殊属性</p><pre class="language-none"><code class="language-none">CODE1.边框合并  取值：border-collapse  取值：     1.separate   默认值,即分离边框模式 2.collapse   边框合并2.边框边距  作用：设置单元格之间或单元格与表格之间的距离  属性：border-spacing  取值：    1.给定一个值：水平和垂直的间距相同2.给两个值：  第一个值 表示水平间距  第二个值 表示垂直间距注意：只有在边框分离模式下,边框边距才有效果,即border-collapse:separate时,border-spacing才有效。</code></pre><p>3.表格标题位置</p><pre class="language-none"><code class="language-none">CODE属性：caption-side取值：    1.top:默认值,标题在表格内容之上2.bottom:标题在表格内容之下</code></pre><p>4.显示规则</p><pre class="language-none"><code class="language-none">CODE作用：用来帮助浏览器指定如何布局一张表,也就是指定td尺寸的计算方式。属性：table-layout取值：   1.auto     默认值,即自动布局表格,列的尺寸实际上由内容来决定的。   2.fixed     固定表格布局,列的尺寸由设置的值为准自动表格布局VS固定表格布局：    1.自动表格布局  1.单元格的大小会适应内容  2.表格复杂时,加载速度较慢（缺点）  3.自动表格布局会比较灵活（优点）  4.适用于不确定每列大小时使用    2.固定表格布局  1.单元格的尺寸取决于设定的值  2.任何情况下都会加载显示表格（优点）  3.适用于确定每列大小时使用  4.固定表格布局不够灵活（缺点）</code></pre><h3 id="11-定位-浮动定位"><a href="#11-定位-浮动定位" class="headerlink" title="11.定位-浮动定位"></a>11.定位-浮动定位</h3><p>1.定位</p><pre class="language-none"><code class="language-none">CODE定位：指的是改变元素在页面中的默认位置</code></pre><p>2.定位的分类</p><pre class="language-none"><code class="language-none">CODE按照定位的效果,可以分成以下几类：   1.普通流定位（默认的定位方式）   2.浮动定位   3.相对定位   4.绝对定位   5.固定定位</code></pre><p>3.定位详解</p><pre class="language-none"><code class="language-none">CODE1.普通流定位  又称为文档流定位,页面中元素的默认定位方式  1.每个元素在页面中都有自己的空间  2.每个元素默认都是在其父元素的左上角开始显示  3.页面中的块级元素都是从上往下排列,每个元素独占一行  4.页面中的行内元素以及行内块都是按照从左到右的顺序来排列的  要解决的问题：让多个块级元素在一行中显示2.浮动定位  1.什么是浮动&amp;特点    1.元素一旦浮动起来,将不占据页面空间（脱离了文档流）,其它未浮动元素将上前补位。2.浮动元素会停靠在父元素的左边或右边,或其它已经浮动的元素的边缘上。3.浮动定位解决的问题：能够让多个块级元素在一行中显示。  2.语法    属性：float取值：   1.left     左浮动,让元素停靠在父元素的左边或挨着左侧已经浮动的元素   2.right     右浮动,让元素停靠在父元素的右边或挨着右侧已经浮动的元素   3.none     默认值,即无任何浮动效果</code></pre><h3 id="12-浮动引发的特殊效果"><a href="#12-浮动引发的特殊效果" class="headerlink" title="12.浮动引发的特殊效果"></a>12.浮动引发的特殊效果</h3><p>1.元素一旦浮动起来以后就会变成块级元素</p><pre class="language-none"><code class="language-none">CODE允许修改尺寸能正常处理垂直方向外边距</code></pre><p>2.当父元素显示不下所有已浮动元素时,最后一个将换行,但是,有可能被卡住；<br>3.元素一旦浮动起来后,宽度将以内容为主（未指定宽度情况下）；<br>4.文本,行内元素,行内块元素是采用环绕的方式来排列的,是不会别浮动元素压在底下的,而会巧妙的避开浮动元素。</p><h3 id="13-清除浮动带来的影响"><a href="#13-清除浮动带来的影响" class="headerlink" title="13.清除浮动带来的影响"></a>13.清除浮动带来的影响</h3><p>元素一旦浮动起来之后,就会对后续元素带来一定的位置影响（后续元素要上前补位）,如果后续元素不想被影响（不想补位）,那么就可以通过清除浮动的方式来解决<br>属性：clear<br>取值：</p><pre class="language-none"><code class="language-none">CODE1.left  清除当前元素前面的元素左浮动所带来的影响2.right  清除当前元素前面的元素右浮动所带来的影响3.both  清除当前元素前面元素任何一种浮动所带来的影响4.none  默认值,不做任何的清除浮动操作</code></pre><h3 id="14-浮动元素对父元素高度的影响"><a href="#14-浮动元素对父元素高度的影响" class="headerlink" title="14.浮动元素对父元素高度的影响"></a>14.浮动元素对父元素高度的影响</h3><p>1.元素的高度都是以未浮动元素的高度为准的,浮动元素是不占页面的高度的</p><pre class="language-none"><code class="language-none">CODE 解决父元素的高度方案如下：    1.直接设置父元素的高度  弊端：不是每次都知道父元素的高度2.设置父元素也浮动  弊端：不是任何时候父元素都需要浮动,而且浮动会影响后续元素3.为父元素设置overflow  取值：hidden或auto  弊端：如果有内容需要溢出显示的话,也会一同被隐藏4.在父元素中,追加空子元素(块级),并设置其clear:both;</code></pre><h3 id="15-显示"><a href="#15-显示" class="headerlink" title="15.显示"></a>15.显示</h3><p>1.显示方式</p><pre class="language-none"><code class="language-none">CODE1.什么是显示方式  决定了元素在网页中的表现形式（块级,行内,行内块）2.语法  属性：display  取值：     1.none 不显示元素-隐藏   特点：脱离文档流,不占据页面空间 2.block   让元素表现的和块级元素一致   特点：      独占一行,可是修改高宽 3.inline   让元素表现的和行内元素一致   特点：      不允许修改尺寸      多个元素在一行中显示      无法设置垂直外边距 4.inline-block   让元素表现的和行内块元素一致   特点：     多个元素在一行中显示,但是可以修改尺寸 5.table   让元素表现的与表格一致   特点：      尺寸以内容为准      每个元素独占一行      允许修改尺寸</code></pre><p>2.显示效果</p><pre class="language-none"><code class="language-none">CODE1.显示/隐藏  属性：visibility  取值：      1.visible:默认值,元素可见  2.hidden:元素不可见-隐藏  面试：display:none和visibility:hidden的区别        display:none 不占页面空间    visibility:hidden 占页面空间2.透明度  属性：opacity  取值：0.0（完全透明）~1.0（完全不透明）之间的小数3.垂直方向对齐方式  属性：vertical-align  场合：     1.表格中使用   取值：top/bottom/middle 2.图片（img）中使用   取值：      top：上      bottom：下      middle：中间      baseline:基线对齐,默认值</code></pre><h3 id="16-光标"><a href="#16-光标" class="headerlink" title="16.光标"></a>16.光标</h3><p>1.作用</p><pre class="language-none"><code class="language-none">CODE改变鼠标悬停在元素上时,鼠标的状态</code></pre><p>2.语法</p><pre class="language-none"><code class="language-none">CODE属性：cursor取值：    1.default: 默认2.pointer: 小手3.crosshair: +4.text: I5.wait: 等待6.help: 帮助 练习：   新建一个div元素,当鼠标移入到div上时,让光标变成小手状态。</code></pre><h3 id="17-列表"><a href="#17-列表" class="headerlink" title="17.列表"></a>17.列表</h3><p>1.列表项标记</p><pre class="language-none"><code class="language-none">CODE属性：list-style-type取值：   1.none   2.disc   3.circle   4.square</code></pre><p>2.列表项图像</p><pre class="language-none"><code class="language-none">CODE作用：使用自定义图像作为列表项标识属性：list-style-image取值：url(图像路径);</code></pre><p>3.列表项位置</p><pre class="language-none"><code class="language-none">CODE作用：将默认的列表项标识的位置,放到li里面属性：list-style-position取值：   1.outside 默认值,将标识显示在li外面的   2.inside 将标识放于li里面</code></pre><p>4.列表属性简写</p><pre class="language-none"><code class="language-none">CODE属性：list-style取值：type url() position;常用方式：list-style:none;列表的使用场合：   横向排列或纵向排列的内容,都可以使用列表来实现。</code></pre><h3 id="18-定位"><a href="#18-定位" class="headerlink" title="18.定位"></a>18.定位</h3><p>相对定位,绝对定位,固定定位<br>1.定位相关属性</p><pre class="language-none"><code class="language-none">CODE属性：position取值：   1.static:静态,默认值   2.relative:相对定位   3.absolute:绝对定位   4.fixed:固定定位</code></pre><p>2.偏移属性</p><pre class="language-none"><code class="language-none">CODEtop/bottom/left/right以上四个属性的取值均为数字ex:  top:150px 元素向下移动150px  left:20px 元素向右移动20px  right:-150px 元素向右移动150px注意：  只有已定位元素才能使用偏移属性</code></pre><p>3.定位详解</p><pre class="language-none"><code class="language-none">CODE1.相对定位  1.什么是相对定位    元素相对于它原来的位置偏移某个距离  2.使用场合    做元素位置微调时使用  3.语法      position:relative;      配合偏移属性来实现位置的移动      left:10px;      top:10px;2.绝对定位  1.什么是绝对定位&amp;特点    1.绝对定位的元素会脱离文档流-不占页面空间2.绝对定位的元素会相对于离他最近的,已定位的,祖先元素 去实现位置的初始化。3.如果没有已定位的祖先元素,那么该元素就相对于body去实现位置的初始化4.配合偏移属性 实现元素位置的修改  2.语法    position:absolute;配合偏移属性实现位置的修改  3.使用场合    1.有堆叠效果的元素2.弹出菜单  4.注意：    1.脱离文档流-不占据页面空间2.绝对定位元素会变成块级元素  5.堆叠顺序    一旦元素变为已定位元素的话,元素们则有可能出现堆叠的效果属性：z-index取值：无单位的数字,数字越大越靠上    注意：  1.只有已定位元素才能实现堆叠顺序的改变（z-index）  2.父子元素间,z-index无效,永远都是子元素压在父元素上方3.固定定位  1.什么是固定定位    将元素固定在网页的某个位置处,位置不会随着滚动条而发生改变,固定在可视区域中。  2.语法    position:fixed;配合偏移属性使用  注意：    1.固定定位的元素永远都是相对于body去实现位置的初始化和偏移。2.固定定位的元素会变成块级元素3.固定定位元素会脱离文档流-不占页面空间</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
